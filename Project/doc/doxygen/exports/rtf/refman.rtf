{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment Dijkstra's algorithm project  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
3.0 \par
}}Dijkstra's algorithm project}
{\comment Generated by doxygen.}
{\creatim \yr2021\mo7\dy16\hr20\min27\sec11}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt Dijkstra's algorithm project}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 3.0\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Fri Jul 16 2021 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Main Page\par \pard\plain 
{\tc \v Main Page}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 {\b Project about graphs and Dijkstra's algorithm:} } \par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 {\b Project content:} } \par}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 {\b Libraries:} } \par}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Graph} : library for graphs management and minimum cost path with Dijkstra's algorithm.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UI} : GUI (terminal I/O) library to print logo and coloured terminal feedbacks.\par}
\par{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 {\b Main} } \par}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Graph_test} : main test software to create a small graph and test Dijkstra's algorithm to find minimum cost path.\par}
\par{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 {\b Makefile} } \par}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Compile commands} :{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b make} : command to compile and link the whole project to executable (shortcut command).\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b make all} : same command as above, extended command.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b make run} : command to launch\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b make all_run} : command to compile/link the whole project to executable and run it.\par}
}
\par{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 {\b Project folders:} } \par}
\~.\par
 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b README.md}\par
 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 doc\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 abstract\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 abstract.aux\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 abstract.fdb_latexmk\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 abstract.fls\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 abstract.log\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b abstract.pdf} \par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 abstract.synctex.gz\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 abstract.tex\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 abstract.tex\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 doxygen\par
 \'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 doxygen_config\par
 \'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 exports\par
 \'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b html} \par
 \'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 rtf\par
 \'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 src\par
 \'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 logo.png\par
 \'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 sw\par
 \~\~\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 gnuplot\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b archs.dat}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b costs.dat}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 exports\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 imgs\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 pdf\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b graph_plot.cmd}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b nodes.dat}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b shortest_archs.dat}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b shortest_costs.dat}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b shortest_nodes.dat}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b shortest_plot.cmd}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 {\b src_dest_nodes.dat}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 lib\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 files\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b lib_files.c}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b lib_files.h}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 {\b lib_files.so}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 graph\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b lib_graph.c}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b lib_graph.h}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 {\b lib_graph.so}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 timer\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b lib_timer.c}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b lib_timer.h}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 {\b lib_timer.so}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 ui\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b lib_ui.c}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b lib_ui.h}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 {\b lib_ui.so}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 main\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b graph_test.c}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 {\b graph_test.o}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b graph_test} \par
 \~\~\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 {\b makefile} \par
18 directories, 35 files \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
General notes{\tc \v General notes}\par \pard\plain 
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
rfefrerf\par
Dijkstra's algorithm library test-software.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Cristian Merli \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
15/07/2021 \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
3.0 - Completed 15/05/2021\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Important notes:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Graphical effects are managed by gnuplot (based on data manipulated by test software main program), so it is highly recommended to have it installed.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
It is possibile to compile, run and execute further actions tacking advantege of makefile, for more informations see doxygen 'Main page' or {\b README.md} file. \par}
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Important warnings:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Pay attention, arch/node names must only be max 30 chars long. To modify max names lenght, change relative macros inside '{\b lib_graph.h}' header file: # and #.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cddcs.... \par}
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Bug:\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid No known bugs.\par
}
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Code title:
\par}
{\tc\tcl2 \v Code title:}
Polynomial interpolation with Newton algorithm and divided-differences.\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Code details:
\par}
{\tc\tcl3 \v Code details:}
Polynomial interpolation C code --> Newton algorithm with divided-differences to interpolate 'till 170 points, polynomial evaluation in given points and derivate calculation. \par}
\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Test-page{\tc \v Test-page}\par \pard\plain 
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'97. \par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Code title:
\par}
{\tc\tcl2 \v Code title:}
\'97.\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Code details:
\par}
{\tc\tcl3 \v Code details:}
Polynomial interpolation C code --> Newton algorithm with divided-differences to interpolate 'till 170 points, polynomial evaluation in given points and derivate calculation. \par}
\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Test-page{\tc \v Test-page}\par \pard\plain 
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'97. \par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Code title:
\par}
{\tc\tcl2 \v Code title:}
\'97.\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Code details:
\par}
{\tc\tcl3 \v Code details:}
Polynomial interpolation C code --> Newton algorithm with divided-differences to interpolate 'till 170 points, polynomial evaluation in given points and derivate calculation. \par}
\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Test-page{\tc \v Test-page}\par \pard\plain 
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'97. \par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Code title:
\par}
{\tc\tcl2 \v Code title:}
\'97.\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Code details:
\par}
{\tc\tcl3 \v Code details:}
Polynomial interpolation C code --> Newton algorithm with divided-differences to interpolate 'till 170 points, polynomial evaluation in given points and derivate calculation. \par}
\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Bug List{\tc \v Bug List}\par \pard\plain 
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Page {\b General notes}  \par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
No known bugs.\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Index\par \pard\plain 
{\tc \v Data Structure Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Data Structures\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the data structures with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b arch} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b connection} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAME \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b date_time} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b dijkstra_dataset} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b list_elem} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b node} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b street} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Street struct typedef for graph-library test (use crosses and streets as example of archs and nodes) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b graph_test} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b makefile} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b archs.dat} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b costs.dat} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b graph_plot.cmd} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b nodes.dat} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b shortest_archs.dat} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b shortest_costs.dat} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b shortest_nodes.dat} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b shortest_plot.cmd} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b src_dest_nodes.dat} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/files/{\b lib_files.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/files/{\b lib_files.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/files/{\b lib_files.so} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/graph/{\b lib_graph.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Csdcds })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/graph/{\b lib_graph.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Csdcds })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/graph/{\b lib_graph.so} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/timer/{\b lib_timer.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/timer/{\b lib_timer.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/timer/{\b lib_timer.so} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/ui/{\b lib_ui.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/ui/{\b lib_ui.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/ui/{\b lib_ui.so} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b main/{\b graph_test.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Csdcds })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b main/{\b graph_test.o} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Documentation{\tc \v Data Structure Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
arch Struct Reference\par \pard\plain 
{\tc\tcl2 \v arch}
{\xe \v arch}
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
\par
{
{\f2 #include <lib_graph.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b name} [{\b AR_STR_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Graph_node} {\b nd1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Real} {\b cost}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Graph_node} {\b nd2}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 61 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v cost\:arch}
{\xe \v arch\:cost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Real} arch::cost}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 64 of file lib_graph.h.}\par
}
{\xe \v name\:arch}
{\xe \v arch\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char arch::name[{\b AR_STR_LEN}]}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 62 of file lib_graph.h.}\par
}
{\xe \v nd1\:arch}
{\xe \v arch\:nd1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Graph_node} arch::nd1}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 63 of file lib_graph.h.}\par
}
{\xe \v nd2\:arch}
{\xe \v arch\:nd2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Graph_node} arch::nd2}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/graph/{\b lib_graph.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
connection Struct Reference\par \pard\plain 
{\tc\tcl2 \v connection}
{\xe \v connection}
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
\par
{
{\f2 #include <lib_graph.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Graph_node} {\b nd}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Graph_arch} {\b ar}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 76 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v ar\:connection}
{\xe \v connection\:ar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Graph_arch} connection::ar}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 78 of file lib_graph.h.}\par
}
{\xe \v nd\:connection}
{\xe \v connection\:nd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Graph_node} connection::nd}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/graph/{\b lib_graph.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
date_time Struct Reference\par \pard\plain 
{\tc\tcl2 \v date_time}
{\xe \v date_time}
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
\par
{
{\f2 #include <lib_timer.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b yyyy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mn}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b dd}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b hh}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mm}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ss}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 34 of file lib_timer.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v dd\:date_time}
{\xe \v date_time\:dd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int date_time::dd}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file lib_timer.h.}\par
}
{\xe \v hh\:date_time}
{\xe \v date_time\:hh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int date_time::hh}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file lib_timer.h.}\par
}
{\xe \v mm\:date_time}
{\xe \v date_time\:mm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int date_time::mm}}
\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file lib_timer.h.}\par
}
{\xe \v mn\:date_time}
{\xe \v date_time\:mn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int date_time::mn}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file lib_timer.h.}\par
}
{\xe \v ss\:date_time}
{\xe \v date_time\:ss}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int date_time::ss}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file lib_timer.h.}\par
}
{\xe \v yyyy\:date_time}
{\xe \v date_time\:yyyy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int date_time::yyyy}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file lib_timer.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/timer/{\b lib_timer.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
dijkstra_dataset Struct Reference\par \pard\plain 
{\tc\tcl2 \v dijkstra_dataset}
{\xe \v dijkstra_dataset}
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
\par
{
{\f2 #include <lib_graph.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Graph_node} {\b prev_nd}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Real} {\b min_path_cost}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Byte} {\b an_flg}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 70 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v an_flg\:dijkstra_dataset}
{\xe \v dijkstra_dataset\:an_flg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Byte} dijkstra_dataset::an_flg}}
\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file lib_graph.h.}\par
}
{\xe \v min_path_cost\:dijkstra_dataset}
{\xe \v dijkstra_dataset\:min_path_cost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Real} dijkstra_dataset::min_path_cost}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file lib_graph.h.}\par
}
{\xe \v prev_nd\:dijkstra_dataset}
{\xe \v dijkstra_dataset\:prev_nd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Graph_node} dijkstra_dataset::prev_nd}}
\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/graph/{\b lib_graph.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
list_elem Struct Reference\par \pard\plain 
{\tc\tcl2 \v list_elem}
{\xe \v list_elem}
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
\par
{
{\f2 #include <lib_graph.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b arch} * {\b ar}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b list_elem} * {\b nxt}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 46 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v ar\:list_elem}
{\xe \v list_elem\:ar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b arch}* list_elem::ar}}
\par
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file lib_graph.h.}\par
}
{\xe \v nxt\:list_elem}
{\xe \v list_elem\:nxt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b list_elem}* list_elem::nxt}}
\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/graph/{\b lib_graph.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
node Struct Reference\par \pard\plain 
{\tc\tcl2 \v node}
{\xe \v node}
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
\par
{
{\f2 #include <lib_graph.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b name} [{\b ND_STR_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b List} {\b archs_lst}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dijkstra_dataset} * {\b dd}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 53 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v archs_lst\:node}
{\xe \v node\:archs_lst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b List} node::archs_lst}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file lib_graph.h.}\par
}
{\xe \v dd\:node}
{\xe \v node\:dd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b dijkstra_dataset}* node::dd}}
\par
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file lib_graph.h.}\par
}
{\xe \v name\:node}
{\xe \v node\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char node::name[{\b ND_STR_LEN}]}}
\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 54 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/graph/{\b lib_graph.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
street Struct Reference\par \pard\plain 
{\tc\tcl2 \v street}
{\xe \v street}
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Street struct typedef for graph-library test (use crosses and streets as example of archs and nodes). }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b C_char} {\b name} [{\b AR_STR_LEN}]\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Street name (string length defined with macro {\b AR_STR_LEN}). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b C_real} {\b length}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Street length (arch cost). }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Street struct typedef for graph-library test (use crosses and streets as example of archs and nodes). \par
}{
Definition at line 125 of file graph_test.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v length\:street}
{\xe \v street\:length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b C_real} street::length}}
\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Street length (arch cost). }}\par
{
Definition at line 129 of file graph_test.c.}\par
}
{\xe \v name\:street}
{\xe \v street\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b C_char} street::name[{\b AR_STR_LEN}]}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Street name (string length defined with macro {\b AR_STR_LEN}). }}\par
{
Definition at line 127 of file graph_test.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
main/{\b graph_test.c}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/cristian/Comune/Coding/Project/README.md File Reference\par \pard\plain 
{\tc\tcl2 \v /home/cristian/Comune/Coding/Project/README.md}
{\xe \v /home/cristian/Comune/Coding/Project/README.md}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/archs.dat File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/archs.dat}
{\xe \v gnuplot/archs.dat}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/costs.dat File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/costs.dat}
{\xe \v gnuplot/costs.dat}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/graph_plot.cmd File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/graph_plot.cmd}
{\xe \v gnuplot/graph_plot.cmd}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/nodes.dat File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/nodes.dat}
{\xe \v gnuplot/nodes.dat}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/shortest_archs.dat File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/shortest_archs.dat}
{\xe \v gnuplot/shortest_archs.dat}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/shortest_costs.dat File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/shortest_costs.dat}
{\xe \v gnuplot/shortest_costs.dat}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/shortest_nodes.dat File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/shortest_nodes.dat}
{\xe \v gnuplot/shortest_nodes.dat}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/shortest_plot.cmd File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/shortest_plot.cmd}
{\xe \v gnuplot/shortest_plot.cmd}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/src_dest_nodes.dat File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/src_dest_nodes.dat}
{\xe \v gnuplot/src_dest_nodes.dat}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
graph_test File Reference\par \pard\plain 
{\tc\tcl2 \v graph_test}
{\xe \v graph_test}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/files/lib_files.c File Reference\par \pard\plain 
{\tc\tcl2 \v lib/files/lib_files.c}
{\xe \v lib/files/lib_files.c}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "lib_files.h"}\par
{\f2 #include "../ui/lib_ui.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Fl} {\b open_file} (const char *const filename, const char *const mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_int_on_file} ({\b Fl} file, {\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_str_on_file} ({\b Fl} file, const char *const str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_sep_on_file} ({\b Fl} file, {\b C_char} sep)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_nl_on_file} ({\b Fl} file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_tab_on_file} ({\b Fl} file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b read_from_file} ({\b Fl} file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b get_substr_line_from_file} ({\b Fl} file, const char *const tgt_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b get_line_str_from_file} ({\b Fl} file, {\b C_int} tgt_str_line_num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_file} ({\b Fl} file)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b file_in_buff} [{\b FILE_IN_BUFF_SIZE}] = ""\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v close_file\:lib_files.c}
{\xe \v lib_files.c\:close_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_file ({\b Fl}  {\i file})}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 157 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00157                         \{                                                                                   {\cf20 // Function to close file}\par
00158   {\cf20 /* Body */}\par
00159   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00160     C_int res = fclose(file);                                                                               {\cf20 // Close file}\par
00161     {\cf19 if} (res == EOF)\{                                                                                        {\cf20 // Check file close operation result}\par
00162       fbk_err({\cf22 "Ops! Encountred error during file close operation"});                                         {\cf20 // Print error fbk}\par
00163       perror({\cf22 "File close operation failed!"});                                                               {\cf20 // Print perror fbk}\par
00164     \}\par
00165   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00166     fbk_err({\cf22 "Ops! Null-file found during file-close operation"});                                            {\cf20 // Print error fbk}\par
00167     perror({\cf22 "File close operation failed!"});                                                                 {\cf20 // Print perror fbk}\par
00168   \}\par
00169 \}\par
}
}
{\xe \v get_line_str_from_file\:lib_files.c}
{\xe \v lib_files.c\:get_line_str_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* get_line_str_from_file ({\b Fl}  {\i file}, {\b C_int}  {\i tgt_str_line_num})}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 140 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00140                                                              \{                                              {\cf20 // Function to get line-string from file (by target-string line number, returns NULL for no-match found or error)}\par
00141   {\cf20 /* Body */}\par
00142   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00143     {\cf18 int} line_num = 0;                                                                                       {\cf20 // Line number counter}\par
00144     {\cf19 while} ( fgets(file_in_buff, FILE_IN_BUFF_SIZE, file) != NULL )\{                                         {\cf20 // In case of file found, scan lines 'till null line (last one)}\par
00145       ++line_num;                                                                                           {\cf20 // Line number val upd}\par
00146       {\cf19 if} (line_num == tgt_str_line_num)                                                                     {\cf20 // Scroll 'till target-string line number}\par
00147         {\cf19 return} file_in_buff;                                                                                {\cf20 // Return current line content as str}\par
00148     \}\par
00149   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00150     fbk_err({\cf22 "Ops! Null-file found during line-string returning operation (by line number)"});                {\cf20 // Print error fbk}\par
00151     perror({\cf22 "File line-string returning operation (by line number) failed!"});                                {\cf20 // Print perror fbk}\par
00152   \}\par
00153   {\cf19 return} NULL;                                                                                              {\cf20 // Return NULL for no-match found or error}\par
00154 \}\par
}
}
{\xe \v get_substr_line_from_file\:lib_files.c}
{\xe \v lib_files.c\:get_substr_line_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int get_substr_line_from_file ({\b Fl}  {\i file}, const char *const  {\i tgt_str})}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 123 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00123                                                                  \{                                          {\cf20 // Function to get sub-string line number from file (by target-string, returns -1 for no-match found or error)}\par
00124   {\cf20 /* Body */}\par
00125   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00126     {\cf18 int} line_num = 0;                                                                                       {\cf20 // Line number counter}\par
00127     {\cf19 while} ( fgets(file_in_buff, FILE_IN_BUFF_SIZE, file) != NULL )\{                                         {\cf20 // In case of file found, scan lines 'till null line (last one)}\par
00128       ++line_num;                                                                                           {\cf20 // Line number val upd}\par
00129       {\cf19 if} (strstr(file_in_buff, tgt_str) != NULL)                                                            {\cf20 // Check if substring is in current line}\par
00130         {\cf19 return} line_num;                                                                                    {\cf20 // Return current line-number}\par
00131     \}\par
00132   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00133     fbk_err({\cf22 "Ops! Null-file found during target-substring line number id operation"});                       {\cf20 // Print error fbk}\par
00134     perror({\cf22 "File target-substring line number id operation failed!"});                                       {\cf20 // Print perror fbk}\par
00135   \}\par
00136   {\cf19 return} -1;                                                                                                {\cf20 // Return -1 for no-match found or error}\par
00137 \}\par
}
}
{\xe \v open_file\:lib_files.c}
{\xe \v lib_files.c\:open_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Fl} open_file (const char *const  {\i filename}, const char *const  {\i mode})}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00020                                                                 \{                                           {\cf20 // Function to open file}\par
00021   {\cf20 /* Body */}\par
00022   FILE *file;                                                                                               {\cf20 // Define file obj pointer}\par
00023   file = fopen(filename, mode);                                                                             {\cf20 // Open defined file in specified mode (see the end of code)}\par
00024   {\cf19 if} (file == NULL)\{                                                                                        {\cf20 // Check open file operation result}\par
00025     fbk_err({\cf22 "Ops! Encountred error during file open operation"});                                            {\cf20 // Print error fbk}\par
00026     perror({\cf22 "File open operation failed!"});                                                                  {\cf20 // Print perror fbk}\par
00027   \}\par
00028   {\cf19 return} file;                                                                                              {\cf20 // Return file pointer}\par
00029 \}\par
}
}
{\xe \v read_from_file\:lib_files.c}
{\xe \v lib_files.c\:read_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void read_from_file ({\b Fl}  {\i file})}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 107 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00107                             \{                                                                               {\cf20 // Function to read from file}\par
00108   {\cf20 /* Body */}\par
00109   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00110     fbk_nl(1);                                                                                              {\cf20 // New line fbk}\par
00111     {\cf18 int} line_num = 0;                                                                                       {\cf20 // Line number counter}\par
00112     {\cf19 while} ( fgets(file_in_buff, FILE_IN_BUFF_SIZE, file) != NULL )\{                                         {\cf20 // In case of file found, scan lines 'till null line (last one)}\par
00113       ++line_num;                                                                                           {\cf20 // Line number val upd}\par
00114       printf({\cf22 "%s%d)\\t%s%s"}, BU, line_num, OG, file_in_buff);                                                {\cf20 // Print line number and val fbk}\par
00115     \}\par
00116   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00117     fbk_err({\cf22 "Ops! Null-file found during file-read operation"});                                             {\cf20 // Print error fbk}\par
00118     perror({\cf22 "File read operation failed!"});                                                                  {\cf20 // Print perror fbk}\par
00119   \}\par
00120 \}\par
}
}
{\xe \v write_int_on_file\:lib_files.c}
{\xe \v lib_files.c\:write_int_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_int_on_file ({\b Fl}  {\i file}, {\b C_int}  {\i num})}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00032                                           \{                                                                 {\cf20 // Function to write int on file}\par
00033   {\cf20 /* Body */}\par
00034   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00035     C_int res = fprintf(file, {\cf22 "%d"}, num);                                                                   {\cf20 // Insert number in file}\par
00036     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00037       fbk_err({\cf22 "Ops! Encountred error during int value file write operation"});                               {\cf20 // Print error fbk}\par
00038       perror({\cf22 "File write operation of int value, failed!"});                                                 {\cf20 // Print perror fbk}\par
00039     \}\par
00040   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00041     fbk_err({\cf22 "Ops! Null-file found during int value file write-operation"});                                  {\cf20 // Print error fbk}\par
00042     perror({\cf22 "File write operation of int value, failed!"});                                                   {\cf20 // Print perror fbk}\par
00043   \}\par
00044 \}\par
}
}
{\xe \v write_nl_on_file\:lib_files.c}
{\xe \v lib_files.c\:write_nl_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_nl_on_file ({\b Fl}  {\i file})}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00077                               \{                                                                             {\cf20 // Function to write new line on file}\par
00078   {\cf20 /* Body */}\par
00079   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00080     C_int res = fprintf(file, {\cf22 "\\n"});                                                                        {\cf20 // Insert new line in file}\par
00081     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00082       fbk_err({\cf22 "Ops! Encountred error during new line file write operation"});                                {\cf20 // Print error fbk}\par
00083       perror({\cf22 "File write operation of new line failed!"});                                                   {\cf20 // Print perror fbk}\par
00084     \}\par
00085   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00086     fbk_err({\cf22 "Ops! Null-file found during new line file-write operation"});                                   {\cf20 // Print error fbk}\par
00087     perror({\cf22 "File write operation of new line failed!"});                                                     {\cf20 // Print perror fbk}\par
00088   \}\par
00089 \}\par
}
}
{\xe \v write_sep_on_file\:lib_files.c}
{\xe \v lib_files.c\:write_sep_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_sep_on_file ({\b Fl}  {\i file}, {\b C_char}  {\i sep})}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 62 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00062                                            \{                                                                {\cf20 // Function to write separator on file}\par
00063   {\cf20 /* Body */}\par
00064   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00065     C_int res = fprintf(file, {\cf22 "%c"}, sep);                                                                   {\cf20 // Insert separator in file}\par
00066     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00067       fbk_err({\cf22 "Ops! Encountred error during separator char file write operation"});                          {\cf20 // Print error fbk}\par
00068       perror({\cf22 "File write operation of separator char failed!"});                                             {\cf20 // Print perror fbk}\par
00069     \}\par
00070   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00071     fbk_err({\cf22 "Ops! Null-file found during separator char file-write operation"});                             {\cf20 // Print error fbk}\par
00072     perror({\cf22 "File write operation of separator char failed!"});                                               {\cf20 // Print perror fbk}\par
00073   \}\par
00074 \}\par
}
}
{\xe \v write_str_on_file\:lib_files.c}
{\xe \v lib_files.c\:write_str_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_str_on_file ({\b Fl}  {\i file}, const char *const  {\i str})}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00047                                                       \{                                                     {\cf20 // Function to write string on file}\par
00048   {\cf20 /* Body */}\par
00049   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00050     C_int res = fprintf(file, {\cf22 "%s"}, str);                                                                   {\cf20 // Insert string in file}\par
00051     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00052       fbk_err({\cf22 "Ops! Encountred error during string file write operation"});                                  {\cf20 // Print error fbk}\par
00053       perror({\cf22 "File write operation of string failed!"});                                                     {\cf20 // Print perror fbk}\par
00054     \}\par
00055   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00056     fbk_err({\cf22 "Ops! Null-file found during string file write-operation"});                                     {\cf20 // Print error fbk}\par
00057     perror({\cf22 "File write operation of string failed!"});                                                       {\cf20 // Print perror fbk}\par
00058   \}\par
00059 \}\par
}
}
{\xe \v write_tab_on_file\:lib_files.c}
{\xe \v lib_files.c\:write_tab_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_tab_on_file ({\b Fl}  {\i file})}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 92 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00092                                \{                                                                            {\cf20 // Function to write tab on file}\par
00093   {\cf20 /* Body */}\par
00094   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00095     C_int res = fprintf(file, {\cf22 "\\t"});                                                                        {\cf20 // Insert tab in file}\par
00096     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00097       fbk_err({\cf22 "Ops! Encountred error during tab file write operation"});                                     {\cf20 // Print error fbk}\par
00098       perror({\cf22 "File write operation of tab failed!"});                                                        {\cf20 // Print perror fbk}\par
00099     \}\par
00100   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00101     fbk_err({\cf22 "Ops! Null-file found during tab file-write operation"});                                        {\cf20 // Print error fbk}\par
00102     perror({\cf22 "File write operation of tab failed!"});                                                          {\cf20 // Print perror fbk}\par
00103   \}\par
00104 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v file_in_buff\:lib_files.c}
{\xe \v lib_files.c\:file_in_buff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char file_in_buff[{\b FILE_IN_BUFF_SIZE}] = ""}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file lib_files.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/files/lib_files.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/files/lib_files.h}
{\xe \v lib/files/lib_files.h}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FILE_IN_BUFF_SIZE}\~ 1024\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef FILE * {\b Fl}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Fl} {\b open_file} (const char *const filename, const char *const mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_int_on_file} ({\b Fl} file, const int num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_str_on_file} ({\b Fl} file, const char *const str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_sep_on_file} ({\b Fl} file, const char sep)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_nl_on_file} ({\b Fl} file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_tab_on_file} ({\b Fl} file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b read_from_file} ({\b Fl} file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b get_substr_line_from_file} ({\b Fl} file, const char *const tgt_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b get_line_str_from_file} ({\b Fl} file, const int tgt_str_line_num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_file} ({\b Fl} file)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b file_in_buff} [{\b FILE_IN_BUFF_SIZE}]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v FILE_IN_BUFF_SIZE\:lib_files.h}
{\xe \v lib_files.h\:FILE_IN_BUFF_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FILE_IN_BUFF_SIZE\~ 1024}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file lib_files.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v Fl\:lib_files.h}
{\xe \v lib_files.h\:Fl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef FILE* {\b Fl}}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file lib_files.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v close_file\:lib_files.h}
{\xe \v lib_files.h\:close_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_file ({\b Fl}  {\i file})}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 157 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00157                         \{                                                                                   {\cf20 // Function to close file}\par
00158   {\cf20 /* Body */}\par
00159   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00160     C_int res = fclose(file);                                                                               {\cf20 // Close file}\par
00161     {\cf19 if} (res == EOF)\{                                                                                        {\cf20 // Check file close operation result}\par
00162       fbk_err({\cf22 "Ops! Encountred error during file close operation"});                                         {\cf20 // Print error fbk}\par
00163       perror({\cf22 "File close operation failed!"});                                                               {\cf20 // Print perror fbk}\par
00164     \}\par
00165   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00166     fbk_err({\cf22 "Ops! Null-file found during file-close operation"});                                            {\cf20 // Print error fbk}\par
00167     perror({\cf22 "File close operation failed!"});                                                                 {\cf20 // Print perror fbk}\par
00168   \}\par
00169 \}\par
}
}
{\xe \v get_line_str_from_file\:lib_files.h}
{\xe \v lib_files.h\:get_line_str_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* get_line_str_from_file ({\b Fl}  {\i file}, const int  {\i tgt_str_line_num})}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get_substr_line_from_file\:lib_files.h}
{\xe \v lib_files.h\:get_substr_line_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int get_substr_line_from_file ({\b Fl}  {\i file}, const char *const  {\i tgt_str})}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 123 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00123                                                                  \{                                          {\cf20 // Function to get sub-string line number from file (by target-string, returns -1 for no-match found or error)}\par
00124   {\cf20 /* Body */}\par
00125   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00126     {\cf18 int} line_num = 0;                                                                                       {\cf20 // Line number counter}\par
00127     {\cf19 while} ( fgets(file_in_buff, FILE_IN_BUFF_SIZE, file) != NULL )\{                                         {\cf20 // In case of file found, scan lines 'till null line (last one)}\par
00128       ++line_num;                                                                                           {\cf20 // Line number val upd}\par
00129       {\cf19 if} (strstr(file_in_buff, tgt_str) != NULL)                                                            {\cf20 // Check if substring is in current line}\par
00130         {\cf19 return} line_num;                                                                                    {\cf20 // Return current line-number}\par
00131     \}\par
00132   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00133     fbk_err({\cf22 "Ops! Null-file found during target-substring line number id operation"});                       {\cf20 // Print error fbk}\par
00134     perror({\cf22 "File target-substring line number id operation failed!"});                                       {\cf20 // Print perror fbk}\par
00135   \}\par
00136   {\cf19 return} -1;                                                                                                {\cf20 // Return -1 for no-match found or error}\par
00137 \}\par
}
}
{\xe \v open_file\:lib_files.h}
{\xe \v lib_files.h\:open_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Fl} open_file (const char *const  {\i filename}, const char *const  {\i mode})}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00020                                                                 \{                                           {\cf20 // Function to open file}\par
00021   {\cf20 /* Body */}\par
00022   FILE *file;                                                                                               {\cf20 // Define file obj pointer}\par
00023   file = fopen(filename, mode);                                                                             {\cf20 // Open defined file in specified mode (see the end of code)}\par
00024   {\cf19 if} (file == NULL)\{                                                                                        {\cf20 // Check open file operation result}\par
00025     fbk_err({\cf22 "Ops! Encountred error during file open operation"});                                            {\cf20 // Print error fbk}\par
00026     perror({\cf22 "File open operation failed!"});                                                                  {\cf20 // Print perror fbk}\par
00027   \}\par
00028   {\cf19 return} file;                                                                                              {\cf20 // Return file pointer}\par
00029 \}\par
}
}
{\xe \v read_from_file\:lib_files.h}
{\xe \v lib_files.h\:read_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void read_from_file ({\b Fl}  {\i file})}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 107 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00107                             \{                                                                               {\cf20 // Function to read from file}\par
00108   {\cf20 /* Body */}\par
00109   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00110     fbk_nl(1);                                                                                              {\cf20 // New line fbk}\par
00111     {\cf18 int} line_num = 0;                                                                                       {\cf20 // Line number counter}\par
00112     {\cf19 while} ( fgets(file_in_buff, FILE_IN_BUFF_SIZE, file) != NULL )\{                                         {\cf20 // In case of file found, scan lines 'till null line (last one)}\par
00113       ++line_num;                                                                                           {\cf20 // Line number val upd}\par
00114       printf({\cf22 "%s%d)\\t%s%s"}, BU, line_num, OG, file_in_buff);                                                {\cf20 // Print line number and val fbk}\par
00115     \}\par
00116   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00117     fbk_err({\cf22 "Ops! Null-file found during file-read operation"});                                             {\cf20 // Print error fbk}\par
00118     perror({\cf22 "File read operation failed!"});                                                                  {\cf20 // Print perror fbk}\par
00119   \}\par
00120 \}\par
}
}
{\xe \v write_int_on_file\:lib_files.h}
{\xe \v lib_files.h\:write_int_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_int_on_file ({\b Fl}  {\i file}, const int  {\i num})}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v write_nl_on_file\:lib_files.h}
{\xe \v lib_files.h\:write_nl_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_nl_on_file ({\b Fl}  {\i file})}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00077                               \{                                                                             {\cf20 // Function to write new line on file}\par
00078   {\cf20 /* Body */}\par
00079   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00080     C_int res = fprintf(file, {\cf22 "\\n"});                                                                        {\cf20 // Insert new line in file}\par
00081     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00082       fbk_err({\cf22 "Ops! Encountred error during new line file write operation"});                                {\cf20 // Print error fbk}\par
00083       perror({\cf22 "File write operation of new line failed!"});                                                   {\cf20 // Print perror fbk}\par
00084     \}\par
00085   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00086     fbk_err({\cf22 "Ops! Null-file found during new line file-write operation"});                                   {\cf20 // Print error fbk}\par
00087     perror({\cf22 "File write operation of new line failed!"});                                                     {\cf20 // Print perror fbk}\par
00088   \}\par
00089 \}\par
}
}
{\xe \v write_sep_on_file\:lib_files.h}
{\xe \v lib_files.h\:write_sep_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_sep_on_file ({\b Fl}  {\i file}, const char  {\i sep})}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v write_str_on_file\:lib_files.h}
{\xe \v lib_files.h\:write_str_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_str_on_file ({\b Fl}  {\i file}, const char *const  {\i str})}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00047                                                       \{                                                     {\cf20 // Function to write string on file}\par
00048   {\cf20 /* Body */}\par
00049   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00050     C_int res = fprintf(file, {\cf22 "%s"}, str);                                                                   {\cf20 // Insert string in file}\par
00051     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00052       fbk_err({\cf22 "Ops! Encountred error during string file write operation"});                                  {\cf20 // Print error fbk}\par
00053       perror({\cf22 "File write operation of string failed!"});                                                     {\cf20 // Print perror fbk}\par
00054     \}\par
00055   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00056     fbk_err({\cf22 "Ops! Null-file found during string file write-operation"});                                     {\cf20 // Print error fbk}\par
00057     perror({\cf22 "File write operation of string failed!"});                                                       {\cf20 // Print perror fbk}\par
00058   \}\par
00059 \}\par
}
}
{\xe \v write_tab_on_file\:lib_files.h}
{\xe \v lib_files.h\:write_tab_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_tab_on_file ({\b Fl}  {\i file})}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 92 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00092                                \{                                                                            {\cf20 // Function to write tab on file}\par
00093   {\cf20 /* Body */}\par
00094   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00095     C_int res = fprintf(file, {\cf22 "\\t"});                                                                        {\cf20 // Insert tab in file}\par
00096     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00097       fbk_err({\cf22 "Ops! Encountred error during tab file write operation"});                                     {\cf20 // Print error fbk}\par
00098       perror({\cf22 "File write operation of tab failed!"});                                                        {\cf20 // Print perror fbk}\par
00099     \}\par
00100   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00101     fbk_err({\cf22 "Ops! Null-file found during tab file-write operation"});                                        {\cf20 // Print error fbk}\par
00102     perror({\cf22 "File write operation of tab failed!"});                                                          {\cf20 // Print perror fbk}\par
00103   \}\par
00104 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v file_in_buff\:lib_files.h}
{\xe \v lib_files.h\:file_in_buff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char file_in_buff[{\b FILE_IN_BUFF_SIZE}]}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file lib_files.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/files/lib_files.so File Reference\par \pard\plain 
{\tc\tcl2 \v lib/files/lib_files.so}
{\xe \v lib/files/lib_files.so}
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/graph/lib_graph.c File Reference\par \pard\plain 
{\tc\tcl2 \v lib/graph/lib_graph.c}
{\xe \v lib/graph/lib_graph.c}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
csdcds }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "lib_graph.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b iaddr} ({\b C_int} i, {\b C_int} j, {\b C_int} lda)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b List_elem} * {\b allocate_new_list_elems} ({\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b add_elem_at_list_head} ({\b List} *list, {\b List_elem} *const el_to_add)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b add_elem_at_list_pos} ({\b List} *list, {\b List_elem} *const el_to_add, {\b C_int} pos)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b add_elem_at_list_tail} ({\b List} *list, {\b List_elem} *const el_to_add)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b free_list_elems} ({\b List} *list_head, {\b Verbose_mode} v_mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b allocate_new_archs} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b allocate_new_nodes} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b reallocate_new_archs} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b reallocate_new_nodes} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b allocate_new_dijk_dataset_vect} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b reallocate_dijk_dataset_vect} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b Connection} * {\b allocate_new_nd_conn_vect} ({\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b reallocate_nd_conn_vect} ({\b Connection} **nd_conn_vect, {\b C_int} size)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b Connection} * {\b not_an_node_conn} ({\b Node} *nd, int *const vect_size)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b print_min_paths} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b print_shortest_path} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b idx_by_name} ({\b Obj_type} object_type, {\b C_str} object_name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add_new_arch} ({\b C_str} name, {\b C_real} cost)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add_new_node} ({\b C_str} name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b connect_node_arch} ({\b C_str} ar_name, {\b C_str} nd_name, {\b Node_pos_in_arch} nd_pos, {\b Arch_pos_typ} ar_pos,...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dijkstra_alg} ({\b C_str} src_nd_name, {\b Verbose_mode} v_mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b buid_shortest_path} ({\b C_str} dest_nd_name, {\b Verbose_mode} v_mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b free_graph} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Real} {\b _REAL_MAX_} = __DBL_MAX__\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ars_collect_size} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b nds_collect_size} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b min_pth_conn_vect_size} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Arch} * {\b archs_collect_vect} = NULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Node} * {\b nodes_collect_vect} = NULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Connection} * {\b min_path_conn_vect} = NULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b src_node_idx} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b dest_node_idx} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Dijkstra_dataset} * {\b dijk_dataset_vect} = NULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Byte} {\b realloc_flg} = 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
csdcds \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
saxxasxsa \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v add_elem_at_list_head\:lib_graph.c}
{\xe \v lib_graph.c\:add_elem_at_list_head}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void add_elem_at_list_head ({\b List} *  {\i list}, {\b List_elem} *const  {\i el_to_add}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00072                                                                          \{                                  {\cf20 // Function to add a new element in list (head position)}\par
00073   {\cf20 /* Body */}\par
00074   {\cf19 if} (el_to_add != NULL)\{                                                                                   {\cf20 // Check element to add not null}\par
00075     List tmp_el_head = *list;                                                                               {\cf20 // Copy the old list head addr in tmp var}\par
00076     el_to_add->nxt = NULL;                                                                                  {\cf20 // Set new element as list tail (in case it's the only element in list - head&tail, otherwise connect it to the old head element)}\par
00077     *list = el_to_add;                                                                                      {\cf20 // Set list head addr equal to new elment addr}\par
00078     el_to_add->nxt = tmp_el_head;                                                                           {\cf20 // Reconnect the new element to the list}\par
00079   \} {\cf19 else} \{                                                                                                  {\cf20 // If specified position is less (or equal) than one}\par
00080     fbk_nl(1);  fbk_err({\cf22 "Error, element to add in list must be not null"});                                  {\cf20 // Print error fbk}\par
00081   \}\par
00082 \}\par
}
}
{\xe \v add_elem_at_list_pos\:lib_graph.c}
{\xe \v lib_graph.c\:add_elem_at_list_pos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void add_elem_at_list_pos ({\b List} *  {\i list}, {\b List_elem} *const  {\i el_to_add}, {\b C_int}  {\i pos}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 85 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00085                                                                                    \{                        {\cf20 // Function to add a new element at a specific position of the list (non-zero index)}\par
00086   {\cf20 /* Body */}\par
00087   {\cf19 if} (pos >= 1 && el_to_add != NULL)\{                                                                       {\cf20 // Check specified postion greater (or equal) than one and element to add not null}\par
00088     {\cf19 if} (pos == 1 || *list == NULL)                                                                          {\cf20 // If specified position is equal to one or list is null (empty list)}\par
00089       add_elem_at_list_head(list, el_to_add);                                                               {\cf20 // Add element in list (head position)}\par
00090     {\cf19 else} \{                                                                                                  {\cf20 // Else if specified position is greater than one or list ain't null (list not empty)}\par
00091       List tmp_list = *list;                                                                                {\cf20 // Copy old list in tmp var}\par
00092       {\cf19 for} ({\cf18 int} idx = 1; idx < pos-1 && tmp_list->nxt != NULL; tmp_list = tmp_list->nxt, ++idx);             {\cf20 // Scroll list 'till specified position reached, or tail if position > elements in list}\par
00093       el_to_add->nxt = tmp_list->nxt;                                                                       {\cf20 // Once target position is reached, set new element connection equal to target position element connection}\par
00094       tmp_list->nxt = el_to_add;                                                                            {\cf20 // Set target position element connection equal to new element}\par
00095     \}\par
00096   \} {\cf19 else} \{                                                                                                  {\cf20 // If specified position is less (or equal) than one}\par
00097     fbk_nl(1);                                                                                              {\cf20 // New line fbk}\par
00098     fbk_err({\cf22 "Error, position in list must be greater than one (non-zero index), and element not null"});     {\cf20 // Print error fbk}\par
00099   \}\par
00100 \}\par
}
}
{\xe \v add_elem_at_list_tail\:lib_graph.c}
{\xe \v lib_graph.c\:add_elem_at_list_tail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void add_elem_at_list_tail ({\b List} *  {\i list}, {\b List_elem} *const  {\i el_to_add}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 103 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00103                                                                          \{                                  {\cf20 // Function to add a new element in list (tail position)}\par
00104   {\cf20 /* Body */}\par
00105   {\cf19 if} (el_to_add != NULL)\{                                                                                   {\cf20 // Check element to add not null}\par
00106     {\cf19 if} (*list != NULL)\{                                                                                     {\cf20 // If objects list has been already initialized}\par
00107       List tmp_list = *list;                                                                                {\cf20 // Copy old list in tmp var}\par
00108       {\cf19 for} (; tmp_list->nxt != NULL; tmp_list = tmp_list->nxt);                                              {\cf20 // Scroll the whole list 'till list tail, to find last element}\par
00109       el_to_add->nxt = NULL;                                                                                {\cf20 // Set new element as list tail}\par
00110       tmp_list->nxt = el_to_add;                                                                            {\cf20 // Cotnnect last element to the new element to add}\par
00111     \} {\cf19 else}                                                                                                  {\cf20 // Else if objects list ain't been already initialized}\par
00112       add_elem_at_list_head(list, el_to_add);                                                               {\cf20 // Add element in list (head position)}\par
00113   \} {\cf19 else} \{                                                                                                  {\cf20 // If specified position is less (or equal) than one}\par
00114     fbk_nl(1);  fbk_err({\cf22 "Error, element to add in list must be not null"});                                  {\cf20 // Print error fbk}\par
00115   \}\par
00116 \}\par
}
}
{\xe \v add_new_arch\:lib_graph.c}
{\xe \v lib_graph.c\:add_new_arch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void add_new_arch ({\b C_str}  {\i name}, {\b C_real}  {\i cost})}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 352 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00352                                           \{                                                                 {\cf20 // Function to add new graph arch (arch allocated inside heap)}\par
00353   {\cf20 /* Body */}\par
00354   fbk_nl(1);  fbk_gn_pu({\cf22 "Adding new graph arch..."});                                                        {\cf20 // Adding new graph arch fbk}\par
00355   {\cf19 if} (cost > 0.0)\{                                                                                          {\cf20 // If cost is positive}\par
00356     {\cf19 if} (archs_collect_vect == NULL)                                                                         {\cf20 // Check arches collection vector, if null}\par
00357       allocate_new_archs();                                                                                 {\cf20 // Allocate a new graph arch inside arches collection vector (vect calloc)}\par
00358     {\cf19 else}                                                                                                    {\cf20 // Else if not null}\par
00359       reallocate_new_archs();                                                                               {\cf20 // Allocate a new graph arch inside arches collection vector (vect realloc)}\par
00360     {\cf19 if} (strlen(name) > 0 && strlen(name) < AR_STR_LEN)\{                                                     {\cf20 // Check arch name length consistency, if ok}\par
00361       strcpy(archs_collect_vect[ars_collect_size-1].name, name);  fbk_nl(1);                                {\cf20 // Copy name inside arch name var}\par
00362     \} {\cf19 else} \{                                                                                                {\cf20 // Else if arch name length consistency ain't ok}\par
00363       fbk_err({\cf22 "Error, invalid arch name size! Overriding arch name with arch number in collection"});        {\cf20 // Print error fbk}\par
00364       {\cf18 char} name_ovrd[AR_STR_LEN];                                                                           {\cf20 // Define new name to override input name}\par
00365       sprintf(name_ovrd, {\cf22 "%d"}, ars_collect_size);                                                           {\cf20 // Define override-name as arch number in arches collection vect}\par
00366       strcpy(archs_collect_vect[ars_collect_size-1].name, name_ovrd);                                       {\cf20 // Copy override-name inside arch name var}\par
00367     \}\par
00368     archs_collect_vect[ars_collect_size-1].cost = cost;                                                     {\cf20 // Define arch cost}\par
00369     archs_collect_vect[ars_collect_size-1].nd1 = NULL;                                                      {\cf20 // Set node1 connection to NULL}\par
00370     archs_collect_vect[ars_collect_size-1].nd2 = NULL;                                                      {\cf20 // Set node2 connection to NULL}\par
00371     fbk_gn_lbu_ye_str({\cf22 "New arch name"}, archs_collect_vect[ars_collect_size-1].name);                        {\cf20 // New graph arch name fbk}\par
00372     fbk_nl(1);  fbk_gn_lbu_ye_real({\cf22 "New arch cost"}, archs_collect_vect[ars_collect_size-1].cost);           {\cf20 // New graph arch cost fbk}\par
00373     fbk_nl(1);  fbk_gn_cy({\cf22 "New graph arch correctly added!\\n"});                                             {\cf20 // New graph arch correctly added fbk}\par
00374   \} {\cf19 else} \{                                                                                                  {\cf20 // Else if cost ain't positive}\par
00375     fbk_err({\cf22 "Ops! Encountred error during graph data management"});                                          {\cf20 // Error fbk}\par
00376     perror({\cf22 "Found error during arch object creation, its cost must be strictly positive!"});                 {\cf20 // Print perror fbk}\par
00377     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00378     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00379   \}\par
00380 \}\par
}
}
{\xe \v add_new_node\:lib_graph.c}
{\xe \v lib_graph.c\:add_new_node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void add_new_node ({\b C_str}  {\i name})}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 383 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00383                              \{                                                                              {\cf20 // Function to add new graph node (node allocated inside heap)}\par
00384   {\cf20 /* Body */}\par
00385   fbk_nl(1);  fbk_gn_pu({\cf22 "Adding new graph node..."});                                                        {\cf20 // Adding new graph node fbk}\par
00386   {\cf19 if} (nodes_collect_vect == NULL)                                                                           {\cf20 // Check nodes collection vector, if null}\par
00387     allocate_new_nodes();                                                                                   {\cf20 // Allocate a new graph node inside nodes collection vector (vect calloc)}\par
00388   {\cf19 else}                                                                                                      {\cf20 // Else if not null}\par
00389     reallocate_new_nodes();                                                                                 {\cf20 // Allocate a new graph node inside nodes collection vector (vect realloc)}\par
00390   {\cf19 if} (strlen(name) > 0 && strlen(name) < ND_STR_LEN)\{                                                       {\cf20 // Check node name length consistency, if ok}\par
00391     strcpy(nodes_collect_vect[nds_collect_size-1].name, name);  fbk_nl(1);                                  {\cf20 // Copy name inside node name var}\par
00392   \} {\cf19 else} \{                                                                                                  {\cf20 // Else if node name length consistency ain't ok}\par
00393     fbk_err({\cf22 "Error, invalid node name size! Overriding arch name with node number in collection"});          {\cf20 // Print error fbk}\par
00394     {\cf18 char} name_ovrd[ND_STR_LEN];                                                                             {\cf20 // Define new name to override input name}\par
00395     sprintf(name_ovrd, {\cf22 "%d"}, nds_collect_size);                                                             {\cf20 // Define override-name as node number in arches collection vect}\par
00396     strcpy(nodes_collect_vect[nds_collect_size-1].name, name_ovrd);                                         {\cf20 // Copy override-name inside node name var}\par
00397   \}\par
00398   nodes_collect_vect[nds_collect_size-1].archs_lst = NULL;                                                  {\cf20 // Set node arches list to NULL}\par
00399   nodes_collect_vect[nds_collect_size-1].dd = NULL;                                                         {\cf20 // Set node Dijkstra-dataset to NULL}\par
00400   fbk_gn_lbu_ye_str({\cf22 "New node name"}, nodes_collect_vect[nds_collect_size-1].name);                          {\cf20 // New graph arch name fbk}\par
00401   fbk_nl(1);  fbk_gn_cy({\cf22 "New graph node correctly added!\\n"});                                               {\cf20 // New graph node correctly added fbk}\par
00402 \}\par
}
}
{\xe \v allocate_new_archs\:lib_graph.c}
{\xe \v lib_graph.c\:allocate_new_archs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void allocate_new_archs (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 136 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00136                                 \{                                                                           {\cf20 // Function to allocate new graph arches (single/vect)}\par
00137   {\cf20 /* Body */}\par
00138   ars_collect_size = 0;                                                                                     {\cf20 // Make sure to have arches collection vect size set to zero}\par
00139   archs_collect_vect = calloc(1, {\cf17 sizeof}(Arch));                                                             {\cf20 // Tmp graph arch ptr creation to point at first allocated memo cell inside heap}\par
00140   {\cf19 if} (archs_collect_vect == NULL)\{                                                                          {\cf20 // Check calloc funct output to detect dynamic memory allocation errors}\par
00141     fbk_err({\cf22 "Ops! Encountred error during graph data management"});                                          {\cf20 // Error fbk}\par
00142     perror({\cf22 "Found error during graph arches dynamic memory allocation with calloc!"});                       {\cf20 // Print perror fbk}\par
00143     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00144     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00145   \} {\cf19 else}                                                                                                    {\cf20 // In case of dyn memo allocation OK}\par
00146     ++ars_collect_size;                                                                                     {\cf20 // Upd arches collection vect size}\par
00147 \}\par
}
}
{\xe \v allocate_new_dijk_dataset_vect\:lib_graph.c}
{\xe \v lib_graph.c\:allocate_new_dijk_dataset_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void allocate_new_dijk_dataset_vect (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 190 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00190                                             \{                                                               {\cf20 // Function to allocate new Dijkstra-dataset vector}\par
00191   {\cf20 /* Body */}\par
00192   dijk_dataset_vect = calloc(({\cf18 size_t})nds_collect_size, {\cf17 sizeof}(Dijkstra_dataset));                           {\cf20 // Dijkstra-dataset vect ptr creation to point at first allocated memo cell inside heap}\par
00193   {\cf19 if} (dijk_dataset_vect == NULL || nds_collect_size == 0)\{                                                  {\cf20 // Check calloc funct output to detect dynamic memory allocation errors}\par
00194     fbk_err({\cf22 "Ops! Encountred error during graph data management"});                                          {\cf20 // Error fbk}\par
00195     perror({\cf22 "Found error during Dijkstra-dataset vector dynamic memory allocation with calloc!"});            {\cf20 // Print perror fbk}\par
00196     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00197     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00198   \}\par
00199 \}\par
}
}
{\xe \v allocate_new_list_elems\:lib_graph.c}
{\xe \v lib_graph.c\:allocate_new_list_elems}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b List_elem}* allocate_new_list_elems ({\b C_int}  {\i num}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00059                                                     \{                                                       {\cf20 // Function to allocate new list elements (single/vect)}\par
00060   {\cf20 /* Body */}\par
00061   List_elem* tmp_list_elems = calloc(({\cf18 size_t})num, {\cf17 sizeof}(List_elem));                                       {\cf20 // Tmp list element ptr creation to point at first allocated memo cell inside heap}\par
00062   {\cf19 if} (tmp_list_elems == NULL || num == 0)\{                                                                  {\cf20 // Check calloc funct output to detect dynamic memory allocation errors}\par
00063     fbk_err({\cf22 "Ops! Encountred error during lists data management"});                                          {\cf20 // Error fbk}\par
00064     perror({\cf22 "Found error during list elements dynamic memory allocation with calloc!"});                      {\cf20 // Print perror fbk}\par
00065     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00066     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00067   \}\par
00068   {\cf19 return} tmp_list_elems;                                                                                    {\cf20 // Return tmp list elements, firtst allocated memo cell inside heap (pointer)}\par
00069 \}\par
}
}
{\xe \v allocate_new_nd_conn_vect\:lib_graph.c}
{\xe \v lib_graph.c\:allocate_new_nd_conn_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b Connection}* allocate_new_nd_conn_vect ({\b C_int}  {\i num}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 214 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00214                                                        \{                                                    {\cf20 // Function to allocate new node connections vector}\par
00215   {\cf20 /* Body */}\par
00216   Connection* tmp_nd_conn_ptr = calloc(({\cf18 size_t})num, {\cf17 sizeof}(Connection));                                    {\cf20 // Tmp node connection ptr creation to point at first allocated memo cell inside heap}\par
00217   {\cf19 if} (tmp_nd_conn_ptr == NULL || num == 0)\{                                                                 {\cf20 // Check calloc funct output to detect dynamic memory allocation errors}\par
00218     fbk_err({\cf22 "Ops! Encountred error during graph data management"});                                          {\cf20 // Error fbk}\par
00219     perror({\cf22 "Found error during node connections vector dynamic memory allocation with calloc!"});            {\cf20 // Print perror fbk}\par
00220     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00221     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00222   \}\par
00223   {\cf19 return} tmp_nd_conn_ptr;                                                                                   {\cf20 // Return tmp node connection ptr, firtst allocated memo cell inside heap (pointer)}\par
00224 \}\par
}
}
{\xe \v allocate_new_nodes\:lib_graph.c}
{\xe \v lib_graph.c\:allocate_new_nodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void allocate_new_nodes (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 150 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00150                                 \{                                                                           {\cf20 // Function to allocate new graph nodes (single/vect)}\par
00151   {\cf20 /* Body */}\par
00152   nds_collect_size = 0;                                                                                     {\cf20 // Make sure to have nodes collection vect size set to zero}\par
00153   nodes_collect_vect = calloc(1, {\cf17 sizeof}(Node));                                                             {\cf20 // Tmp graph node ptr creation to point at first allocated memo cell inside heap}\par
00154   {\cf19 if} (nodes_collect_vect == NULL)\{                                                                          {\cf20 // Check calloc funct output to detect dynamic memory allocation errors}\par
00155     fbk_err({\cf22 "Ops! Encountred error during graph data management"});                                          {\cf20 // Error fbk}\par
00156     perror({\cf22 "Found error during graph nodes dynamic memory allocation with calloc!"});                        {\cf20 // Print perror fbk}\par
00157     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00158     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00159   \} {\cf19 else}                                                                                                    {\cf20 // In case of dyn memo allocation OK}\par
00160     ++nds_collect_size;                                                                                     {\cf20 // Upd nodes collection vect size}\par
00161 \}\par
}
}
{\xe \v buid_shortest_path\:lib_graph.c}
{\xe \v lib_graph.c\:buid_shortest_path}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void buid_shortest_path ({\b C_str}  {\i dest_nd_name}, {\b Verbose_mode}  {\i v_mode})}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 530 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00530                                                                 \{                                           {\cf20 // Reconstruct shortest path to specified destination node from source node (pre-defined in Dijkstra's algorithm, min path connections vect allocated/reallocated inside heap) - Y/N for verbose mode}\par
00531   {\cf20 /* Body */}\par
00532   fbk_nl(1);  fbk_gn_pu({\cf22 "Building min cost path from pre-defined source to specified destination..."});      {\cf20 // Print reconstructin' shortest path from pre-defined source to specified destination fbk}\par
00533   {\cf19 if} (realloc_flg != 0)\{                                                                                    {\cf20 // If Dijkstra's algorithm has already been called at least once}\par
00534     {\cf20 // Print info fbks}\par
00535     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "--> Source node name"}, nodes_collect_vect[src_node_idx].name);           {\cf20 // Print src-nd name fbk}\par
00536     {\cf18 int} dest_nd_num = idx_by_name(ND, dest_nd_name);                                                        {\cf20 // Get destination node idx by-name}\par
00537     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "--> Destination node name"}, dest_nd_name);                               {\cf20 // Print dest-nd name fbk}\par
00538     {\cf19 if} (dest_nd_num >= 0)\{                                                                                  {\cf20 // Check error conditions ok}\par
00539       dest_node_idx = dest_nd_num;                                                                          {\cf20 // Set/upd destination node idx lib-var val}\par
00540       {\cf19 if} (nodes_collect_vect[dest_nd_num].dd->min_path_cost < _REAL_MAX_ && dest_nd_num != src_node_idx)\{   {\cf20 // If destination node is reachble from pre-defined source node}\par
00541         fbk_nl(1);                                                                                          {\cf20 // Print new-line fbk}\par
00542         fbk_gn_lbu_ye_real({\cf22 "Min path cost to node"}, nodes_collect_vect[dest_nd_num].dd->min_path_cost);     {\cf20 // Print min path cost to reach destination node from pre-defined source node fbk}\par
00543       \} {\cf19 else} {\cf19 if} (dest_nd_num == src_node_idx)\{                                                              {\cf20 // Else if destination node memo addr corresponds to the source node memo addr}\par
00544         fbk_nl(1);                                                                                          {\cf20 // Print new-line fbk}\par
00545         fbk_gn_lbu_ye_str({\cf22 "Min path cost to node"}, {\cf22 "Destination corresponds to pre-defined source node!"});  {\cf20 // Print destination node correspondin' to the pre-defined source node fbk}\par
00546       \} {\cf19 else} \{                                                                                              {\cf20 // Else if destination node is unreachble from pre-defined source node}\par
00547         fbk_nl(1);                                                                                          {\cf20 // Print new-line fbk}\par
00548         fbk_gn_lbu_ye_str({\cf22 "Min path cost to node"}, {\cf22 "Destination unreachble from pre-defined source node!"}); {\cf20 // Print destination node unreachble fbk}\par
00549       \}\par
00550       {\cf20 // Find min-cost path archs & nodes goin' backward from destination to source node}\par
00551       Graph_node tmp_nd = &nodes_collect_vect[dest_nd_num];                                                 {\cf20 // Init tmp node var to reconstruct min-cost path backwards}\par
00552       List_elem* tmpl = NULL;                                                                               {\cf20 // Def tmp list ptr var (for archs) to reconstruct min-cost path backwards}\par
00553       {\cf19 if} (min_pth_conn_vect_size != 0)                                                                      {\cf20 // If min-cost paths vector size ain't zero}\par
00554         min_pth_conn_vect_size = 0;                                                                         {\cf20 // Make it zero}\par
00555       {\cf19 while} (tmp_nd != NULL)\{                                                                               {\cf20 // Scroll min-cost path backwars 'till src node}\par
00556         {\cf19 if} (realloc_flg == 0)\{                                                                              {\cf20 // If realloc flag ain't been set}\par
00557           min_path_conn_vect = allocate_new_nd_conn_vect(++min_pth_conn_vect_size);                         {\cf20 // Allocate (inside heap) a new min path connections vector}\par
00558           ++realloc_flg;                                                                                    {\cf20 // And then upd realloc flag val to use reallocs instead of callocs 'till "free_graph()" funct call}\par
00559         \} {\cf19 else}                                                                                              {\cf20 // Else if realloc flag has already been set}\par
00560           reallocate_nd_conn_vect(&min_path_conn_vect, ++min_pth_conn_vect_size);                           {\cf20 // Reallocate (inside heap) the min path connections vector}\par
00561         tmpl = tmp_nd->archs_lst;                                                                           {\cf20 // Init tmp archs list ptr var}\par
00562         {\cf19 for} (; tmpl != NULL; tmpl = tmpl->nxt)\{                                                             {\cf20 // Scroll min-cost parh node connection archs list to find min-cost path connection arch}\par
00563           {\cf19 if} ((tmp_nd == tmpl->ar->nd1 && tmpl->ar->nd2 == tmp_nd->dd->prev_nd) ||\par
00564               (tmp_nd == tmpl->ar->nd2 && tmpl->ar->nd1 == tmp_nd->dd->prev_nd))\{                           {\cf20 // Min-cost path connection arch detectin' cond}\par
00565             (min_path_conn_vect+iaddr(V, min_pth_conn_vect_size-1, min_pth_conn_vect_size))->ar = tmpl->ar; {\cf20 // Save arch ptr val inside min path connections vector (min-path connection arch)}\par
00566           \}\par
00567         \}\par
00568         (min_path_conn_vect+iaddr(V, min_pth_conn_vect_size-1, min_pth_conn_vect_size))->nd = tmp_nd;       {\cf20 // Save node ptr val inside min path connections vector (min-path connection node)}\par
00569         tmp_nd = tmp_nd->dd->prev_nd;                                                                       {\cf20 // Upd tmp node var to reconstruct min-cost path backwards}\par
00570       \}\par
00571       {\cf20 // Swap elements to obtain shortest path (backward-to-forward path conversion)}\par
00572       Connection tmp_conn;                                                                                  {\cf20 // Tmp connection var to swap connections}\par
00573       {\cf19 for} ({\cf18 int} i = 0; i < min_pth_conn_vect_size/2; ++i)\{                                                   {\cf20 // Half min path connections vector scrollin' FOR cycle}\par
00574         tmp_conn = min_path_conn_vect[i];                                                                   {\cf20 // Define tmp var to swap connections}\par
00575         min_path_conn_vect[i] = min_path_conn_vect[min_pth_conn_vect_size-1-i];                             {\cf20 // Swap-step1}\par
00576         min_path_conn_vect[min_pth_conn_vect_size-i-1] = tmp_conn;                                          {\cf20 // Swap-step2}\par
00577       \}\par
00578       {\cf20 // Print shortest path from pre-defined source node to specified destination node}\par
00579       {\cf19 if} (v_mode == Y)                                                                                      {\cf20 // If verbose mode is enabled, print fbks}\par
00580         print_shortest_path();                                                                              {\cf20 // Print shortest path funct call}\par
00581       fbk_nl(1);  fbk_gn_cy({\cf22 "Destination node min cost path correctly identified!\\n"});                      {\cf20 // Print destination node min cost path correctly identified fbk}\par
00582     \} {\cf19 else}                                                                                                  {\cf20 // If error conditions ain't ok}\par
00583       fbk_err({\cf22 "Error, not able to find destination node min cost path with Dijkstra's algorithm"});          {\cf20 // Print error fbk}\par
00584   \} {\cf19 else}                                                                                                    {\cf20 // Else if Dijkstra's algorithm ain't been called}\par
00585     fbk_err({\cf22 "Error, min path can be reconstructed only after having called Dijkstra's algorithm!"});         {\cf20 // Print error fbk}\par
00586 \}\par
}
}
{\xe \v connect_node_arch\:lib_graph.c}
{\xe \v lib_graph.c\:connect_node_arch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void connect_node_arch ({\b C_str}  {\i ar_name}, {\b C_str}  {\i nd_name}, {\b Node_pos_in_arch}  {\i nd_pos}, {\b Arch_pos_typ}  {\i ar_pos},   {\i ...})}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 405 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00405                                                                                                        \{    {\cf20 // Function to connect arch-node in graph (new arch list element allocated inside heap, opt param --> arch pos in arches list, non-zero index)}\par
00406   {\cf20 /* Body */}\par
00407   fbk_nl(1);  fbk_gn_pu({\cf22 "Creating bidirectional connection between node and arch..."});                      {\cf20 // Creatin' bidirectional connection between node and arch}\par
00408   {\cf18 int} ar_num = idx_by_name(AR, ar_name);                                                                    {\cf20 // Get arch idx by-name}\par
00409   {\cf18 int} nd_num = idx_by_name(ND, nd_name);                                                                    {\cf20 // Get node idx by-name}\par
00410   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Working on node"}, nd_name);                                                {\cf20 // Print node name fbk}\par
00411   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Working on arch"}, ar_name);                                                {\cf20 // Print arch name fbk}\par
00412   {\cf18 int} lst_pos = 0;                                                                                          {\cf20 // List position in which arch must be placed in node conn. arches list}\par
00413   {\cf20 // Function optional parameters management}\par
00414   {\cf19 if} (ar_pos == LIST_POS)\{                                                                                  {\cf20 // If selected arch position type in list is specific position, read list position optional parameter}\par
00415     va_list args_lst;                                                                                       {\cf20 // Function optional parameters list int}\par
00416     va_start(args_lst, ar_pos);                                                                             {\cf20 // Define optional params list startin' point}\par
00417     lst_pos = va_arg(args_lst, {\cf18 int});                                                                        {\cf20 // Read the first optional parameter in funct opt params list (= define list position)}\par
00418   \}\par
00419   {\cf19 if} (nd_num >= 0 && ar_num >= 0 && ((ar_pos == LIST_POS && lst_pos >= 1) || ar_pos != LIST_POS))\{          {\cf20 // Check error conditions ok}\par
00420     {\cf20 // Assign node to arch}\par
00421     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Connecting node to"}, node_pos_in_arch_str[nd_pos]);                      {\cf20 // Connectin' node to arch fbk}\par
00422     {\cf19 switch} (nd_pos)\{                                                                                        {\cf20 // Node assignin' position in arch switch-case (where to assign node in arch)}\par
00423       {\cf19 case} ARCH_ND1:                                                                                        {\cf20 // Case: assign node to arch node1 position}\par
00424         archs_collect_vect[ar_num].nd1 = &nodes_collect_vect[nd_num];                                       {\cf20 // Assign node to arch node1 pos}\par
00425         {\cf19 break};\par
00427       {\cf19 case} ARCH_ND2:                                                                                        {\cf20 // Case: assign node to arch node2 position}\par
00428         archs_collect_vect[ar_num].nd2 = &nodes_collect_vect[nd_num];                                       {\cf20 // Assign node to arch node2 pos}\par
00429         {\cf19 break};\par
00431       {\cf19 default}:                                                                                              {\cf20 // Unknown case}\par
00432         fbk_err({\cf22 "Error, bad parameter value! A function got an unexpected patameter value"});                {\cf20 // Print error fbk}\par
00433         perror({\cf22 "Wrong \\"nd_pos\\" parameter value passsed to \\"connect_node_arch\\" function!"});              {\cf20 // Print perror fbk}\par
00434         {\cf19 break};\par
00435     \}\par
00436     {\cf20 // Assign arch to node}\par
00437     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Connecting arch to node connection archs"}, arch_pos_typ_str[ar_pos]);    {\cf20 // Connectin' node to arch fbk}\par
00438     List_elem* tmp_el = allocate_new_list_elems(1);                                                         {\cf20 // Tmp list element ptr creation}\par
00439     tmp_el->ar = &archs_collect_vect[ar_num];                                                               {\cf20 // Tmp list element ptr def with input arch memo cell addr}\par
00440     {\cf19 switch} (ar_pos)\{                                                                                        {\cf20 // Arch assignin' position type in node arches list switch-case (where to assign arch in node arches connections list) switch-case}\par
00441       {\cf19 case} LIST_HEAD:                                                                                       {\cf20 // Case: assign arch to node arches connections list (head position)}\par
00442         add_elem_at_list_head(&nodes_collect_vect[nd_num].archs_lst, tmp_el);                               {\cf20 // Assign arch (in tmp list element) to the specified node conn. arches list (head position)}\par
00443         {\cf19 break};\par
00445       {\cf19 case} LIST_POS:                                                                                        {\cf20 // Case: assign arch to node arches connections list (specific position, pos from optional funct param)}\par
00446         fbk_nl(1);  fbk_gn_lbu_ye_int({\cf22 "Specific list position number"}, lst_pos);                            {\cf20 // Specific list position num fbk}\par
00447         add_elem_at_list_pos(&nodes_collect_vect[nd_num].archs_lst, tmp_el, lst_pos);                       {\cf20 // Assign arch (in tmp list element) to the specified node conn. arches list (specific position, non-zero index)}\par
00448         {\cf19 break};\par
00450       {\cf19 case} LIST_TAIL:                                                                                       {\cf20 // Case: assign arch to node arches connections list (tail position)}\par
00451         add_elem_at_list_tail(&nodes_collect_vect[nd_num].archs_lst, tmp_el);                               {\cf20 // Assign arch (in tmp list element) to the specified node conn. arches list (tail position)}\par
00452         {\cf19 break};\par
00454       {\cf19 default}:                                                                                              {\cf20 // Unknown case}\par
00455         fbk_err({\cf22 "Error, bad parameter value! A function got an unexpected patameter value"});                {\cf20 // Print error fbk}\par
00456         perror({\cf22 "Wrong \\"ar_pos\\" parameter value passsed to \\"connect_node_arch\\" function!"});              {\cf20 // Print perror fbk}\par
00457         {\cf19 break};\par
00458     \}\par
00459     fbk_nl(1);  fbk_gn_cy({\cf22 "Bidirectional node-arch connetion correctly created!\\n"});                        {\cf20 // Bidirectional node-arch connection correctly created fbk}\par
00460   \} {\cf19 else} \{                                                                                                  {\cf20 // If error conditions ain't ok}\par
00461     fbk_err({\cf22 "Error, not able to create arch-node connection! Connection not created"});                      {\cf20 // Print error fbk}\par
00462     {\cf19 if} (ar_pos == LIST_POS && lst_pos < 1)                                                                  {\cf20 // List pos err detect cond}\par
00463       fbk_err({\cf22 "Error casued by specific list position flag enabled and invalid position value"});            {\cf20 // Print error fbk}\par
00464   \}\par
00465 \}\par
}
}
{\xe \v dijkstra_alg\:lib_graph.c}
{\xe \v lib_graph.c\:dijkstra_alg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dijkstra_alg ({\b C_str}  {\i src_nd_name}, {\b Verbose_mode}  {\i v_mode})}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 468 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00468                                                          \{                                                  {\cf20 // Dijkstra's alg to find min graph-path btwn source and each destination node (Dijkstra-dataset vect allocated/reallocated inside heap) - Y/N for verbose mode}\par
00469   {\cf20 /* Body */}\par
00470   fbk_nl(1);  fbk_gn_pu({\cf22 "Looking for min path costs from specified source with Dijkstra's algorithm..."});   {\cf20 // Print lookin' 4 shortest path btwn spec src and each dest nd fbk}\par
00471   {\cf18 int} src_nd_num = idx_by_name(ND, src_nd_name);                                                            {\cf20 // Get source node idx by-name}\par
00472   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Source node name"}, src_nd_name);                                           {\cf20 // Print source node name}\par
00473   {\cf19 if} (src_nd_num >= 0)\{                                                                                     {\cf20 // Check error conditions ok}\par
00474     {\cf20 // Algorithm inits}\par
00475     {\cf18 int} min_cost_idx = 0;                                                                                   {\cf20 // Min cost node idx in dataset var init}\par
00476     Real min_cost_val = 0.0;                                                                                {\cf20 // Min cost node val in dataset var init}\par
00477     {\cf18 int} nan_nd_conn_vect_size = 0;                                                                          {\cf20 // Node (non-analyzed) connections vector size var to store selected node non-analyzed connections init}\par
00478     Real new_cost = 0.0;                                                                                    {\cf20 // New cost var init}\par
00479     Connection* nan_nd_conn_vect = NULL;                                                                    {\cf20 // Node (non-analyzed) connections vector ptr var decl}\par
00480     {\cf19 if} (realloc_flg == 0)\{                                                                                  {\cf20 // If realloc flag ain't set}\par
00481       allocate_new_dijk_dataset_vect();                                                                     {\cf20 // Dijkstra-dataset vect init (vector allocated inside heap)}\par
00482       ++realloc_flg;                                                                                        {\cf20 // Set realloc flg}\par
00483     \} {\cf19 else}                                                                                                  {\cf20 // Else if realloc flag has been set}\par
00484       reallocate_dijk_dataset_vect();                                                                       {\cf20 // Dijkstra-dataset vect realloc (vector reallocated inside heap)}\par
00485     {\cf19 for} ({\cf18 int} i = 0; i < nds_collect_size; ++i)\{                                                             {\cf20 // Inits FOR cycle}\par
00486       nodes_collect_vect[i].dd = &dijk_dataset_vect[i];                                                     {\cf20 // Define and init nodes Dijkstra-datasets}\par
00487       nodes_collect_vect[i].dd->prev_nd = NULL;                                                             {\cf20 // Node dataset prev node init}\par
00488       nodes_collect_vect[i].dd->an_flg = 0;                                                                 {\cf20 // Node dataset analyzed flag val preset (as not analyzed)}\par
00489       {\cf19 if} (i != src_nd_num)                                                                                  {\cf20 // If node is different from source node}\par
00490         nodes_collect_vect[i].dd->min_path_cost = _REAL_MAX_;                                               {\cf20 // Init unknown min costs from source node (preset val --> +inf)}\par
00491       {\cf19 else}                                                                                                  {\cf20 // Else if node ain't different from source node}\par
00492         nodes_collect_vect[i].dd->min_path_cost = 0;                                                        {\cf20 // Init source-to-source cost (preset val --> zero)}\par
00493     \}\par
00494     src_node_idx = src_nd_num;                                                                              {\cf20 // Set/upd source node idx lib-var val}\par
00495     {\cf20 // Algorithm loop}\par
00496     {\cf19 for} ({\cf18 int} j = 0; j < nds_collect_size-1; ++j)\{                                                           {\cf20 // Main algo loop}\par
00497       {\cf20 // Select node with min-cost path}\par
00498       min_cost_val = _REAL_MAX_;                                                                            {\cf20 // Min cost node val in dataset upd}\par
00499       {\cf19 for} ({\cf18 int} k = 0; k < nds_collect_size; ++k)\{                                                           {\cf20 // Scroll the entire nodes collection 2 detect min cost path node}\par
00500         {\cf19 if} (nodes_collect_vect[k].dd->an_flg == 0 &&\par
00501             nodes_collect_vect[k].dd->min_path_cost < min_cost_val)\{                                        {\cf20 // Min cost path node detectin' cond (min val and node not alredy analized)}\par
00502           min_cost_val = nodes_collect_vect[k].dd->min_path_cost;                                           {\cf20 // If detectin' cond is met, upd min cost node val}\par
00503           min_cost_idx = k;                                                                                 {\cf20 // And upd min cost node idx}\par
00504         \}\par
00505       \}\par
00506       ++nodes_collect_vect[min_cost_idx].dd->an_flg;                                                        {\cf20 // Mark selected node as alredy analized b4 processin' it}\par
00507       {\cf20 // Find non-analyzed connections of selected node}\par
00508       nan_nd_conn_vect_size = 0;                                                                            {\cf20 // Node (non-analyzed) connections vector size var to store selected node non-analyzed connections (rst)}\par
00509       nan_nd_conn_vect = not_an_node_conn(&nodes_collect_vect[min_cost_idx], &nan_nd_conn_vect_size);       {\cf20 // Define selected node non-analyzed connections vect (vector allocated inside heap)}\par
00510       {\cf19 for} ({\cf18 int} l = 0; l < nan_nd_conn_vect_size; ++l)\{                                                      {\cf20 // Scroll selected node non-analyzed connections vect}\par
00511         new_cost = nodes_collect_vect[min_cost_idx].dd->min_path_cost+nan_nd_conn_vect[l].ar->cost;         {\cf20 // New cost val upd}\par
00512         {\cf20 // Upd min path cost and previous node in shortest path}\par
00513         {\cf19 if} (new_cost < nan_nd_conn_vect[l].nd->dd->min_path_cost)\{                                          {\cf20 // In case new cost val is less than min cost val}\par
00514           nan_nd_conn_vect[l].nd->dd->min_path_cost = new_cost;                                             {\cf20 // Upd min cost val}\par
00515           nan_nd_conn_vect[l].nd->dd->prev_nd = &nodes_collect_vect[min_cost_idx];                          {\cf20 // Upd previous min path node}\par
00516         \}\par
00517       \}\par
00518       {\cf19 if} (nan_nd_conn_vect != NULL)                                                                         {\cf20 // If node non-analyzed connections vector was correctly defined}\par
00519         free(nan_nd_conn_vect);                                                                             {\cf20 // Free node non-analyzed connections vector allocated inside heap}\par
00520     \}\par
00521     {\cf20 // Print each min path cost to reach every single accessible node from specified source-node}\par
00522     {\cf19 if} (v_mode == Y)                                                                                        {\cf20 // If verbose mode is enabled, print fbks}\par
00523       print_min_paths();                                                                                    {\cf20 // Print min paths funct call}\par
00524     fbk_nl(1);  fbk_gn_cy({\cf22 "Min path costs correctly found!\\n"});                                             {\cf20 // Print min path costs correctly found fbk}\par
00525   \} {\cf19 else}                                                                                                    {\cf20 // If error conditions ain't ok}\par
00526     fbk_err({\cf22 "Error, not able to find min path costs with Dijkstra's algorithm"});                            {\cf20 // Print error fbk}\par
00527 \}\par
}
}
{\xe \v free_graph\:lib_graph.c}
{\xe \v lib_graph.c\:free_graph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void free_graph ()}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 589 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00589                  \{                                                                                          {\cf20 // Function to free graph allocated memory inside heap}\par
00590   {\cf20 /* Body */}\par
00591   fbk_nl(1);  fbk_gn_pu({\cf22 "Clearing the whole graph structure..."});                                           {\cf20 // Clearing the whole graph from heap fbk}\par
00592   {\cf19 for} ({\cf18 int} i = 0; i < nds_collect_size; ++i)                                                                {\cf20 // Graph nodes scrollin' FOR cycle}\par
00593     {\cf19 if} (nodes_collect_vect[i].archs_lst != NULL)\{                                                           {\cf20 // If node arches list ain't null}\par
00594       free_list_elems(&nodes_collect_vect[i].archs_lst, N);                                                 {\cf20 // Free graph arches list elems associated to each graph node - NO --> without verbose mode}\par
00595       nodes_collect_vect[i].archs_lst = NULL;                                                               {\cf20 // Set node arches list to null}\par
00596     \}\par
00597   {\cf19 if} (archs_collect_vect != NULL)\{                                                                          {\cf20 // If arches collection vector needs to be cleared from heap}\par
00598     free(archs_collect_vect);                                                                               {\cf20 // Free arches collection vector allocated memo inside heap}\par
00599     archs_collect_vect = NULL;                                                                              {\cf20 // Set arches collection vector to null}\par
00600   \}\par
00601   {\cf19 if} (nodes_collect_vect != NULL)\{                                                                          {\cf20 // If nodes collection vector needs to be cleared from heap}\par
00602     free(nodes_collect_vect);                                                                               {\cf20 // Free nodes collection vector allocated memo inside heap}\par
00603     nodes_collect_vect = NULL;                                                                              {\cf20 // Set nodes collection vector to null}\par
00604   \}\par
00605   {\cf19 if} (dijk_dataset_vect != NULL)\{                                                                           {\cf20 // If Dijkstra-dataset vector needs to be cleared from heap}\par
00606     free(dijk_dataset_vect);                                                                                {\cf20 // Free Dijkstra-dataset vector allocated memo inside heap}\par
00607     dijk_dataset_vect = NULL;                                                                               {\cf20 // Set Dijkstra-dataset vector to null}\par
00608   \}\par
00609   {\cf19 if} (min_path_conn_vect != NULL)\{                                                                          {\cf20 // If min path connections vector needs to be cleared from heap}\par
00610     free(min_path_conn_vect);                                                                               {\cf20 // Free min path connections vector allocated memo inside heap}\par
00611     min_path_conn_vect = NULL;                                                                              {\cf20 // Set min path connections vector to null}\par
00612   \}\par
00613   ars_collect_size = 0;                                                                                     {\cf20 // Set graph arches number back to zero}\par
00614   nds_collect_size = 0;                                                                                     {\cf20 // Set graph nodes number back to zero}\par
00615   min_pth_conn_vect_size = 0;                                                                               {\cf20 // Set min path connections vector size back to zero}\par
00616   realloc_flg = 0;                                                                                          {\cf20 // Realloc flag rst}\par
00617   fbk_nl(1);  fbk_gn_cy({\cf22 "Graph structure correctly erased!\\n"});                                             {\cf20 // Graph structure correctly created erased from heap fbk}\par
00618 \}\par
}
}
{\xe \v free_list_elems\:lib_graph.c}
{\xe \v lib_graph.c\:free_list_elems}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void free_list_elems ({\b List} *  {\i list_head}, {\b Verbose_mode}  {\i v_mode}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 119 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00119                                                                  \{                                          {\cf20 // Function to free allocated elements inside heap, startin' from specified list (or sub-list) head, 'till list (or sub-list) tail - Y/N for verbose mode}\par
00120   {\cf20 /* Body */}\par
00121   List tmp_list_head = *list_head;                                                                          {\cf20 // Tmp var to clear allocated memo inside heap (list element)}\par
00122   List tmp_nxt_el = *list_head;                                                                             {\cf20 // Tmp var to store next element in list memo inside heap}\par
00123   {\cf19 for} ({\cf18 int} i = 0; tmp_list_head != NULL; tmp_list_head = tmp_nxt_el, ++i)\{                                  {\cf20 // List (or sub-list) scrollin' FOR cycle to clear heap allocated memo}\par
00124     {\cf19 if} (tmp_list_head != NULL)\{                                                                             {\cf20 // If allocated element ain't null}\par
00125       {\cf19 if} (v_mode == Y)\{                                                                                     {\cf20 // If verbose mode is enabled, print fbk}\par
00126         fbk_nl(1);  fbk_gn_lbu_ye_int({\cf22 "Removing allocated list element from heap, element number"}, i+1);    {\cf20 // Print removing element from heap fbk}\par
00127       \}\par
00128       tmp_nxt_el = tmp_list_head->nxt;                                                                      {\cf20 // Updn ext element in list var}\par
00129       free(tmp_list_head);                                                                                  {\cf20 // Clear allocated elements}\par
00130     \}\par
00131   \}\par
00132   *list_head = NULL;                                                                                        {\cf20 // Set elements list (or sub-list) head to null}\par
00133 \}\par
}
}
{\xe \v iaddr\:lib_graph.c}
{\xe \v lib_graph.c\:iaddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int iaddr ({\b C_int}  {\i i}, {\b C_int}  {\i j}, {\b C_int}  {\i lda}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00045                                              \{                                                              {\cf20 // Arrays/vectors memo addressing}\par
00046   {\cf20 /* Body */}\par
00047   {\cf19 if} (i >= 0 && j >= 0 && lda >= 0)                                                                         {\cf20 // Check params ok}\par
00048     {\cf19 return} (i*lda)+j;                                                                                       {\cf20 // Return index number}\par
00049   {\cf19 else} \{                                                                                                    {\cf20 // If params ain't ok}\par
00050     fbk_err({\cf22 "Ops! Encountred error during arrays data management"});                                         {\cf20 // Error fbk}\par
00051     perror({\cf22 "Found error during array-elements access with 'iaddr' function! Parameters must be positive!"}); {\cf20 // Print perror fbk}\par
00052     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00053     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00054     {\cf19 return} -1;                                                                                              {\cf20 // Random return to avoid compile-errors}\par
00055   \}\par
00056 \}\par
}
}
{\xe \v idx_by_name\:lib_graph.c}
{\xe \v lib_graph.c\:idx_by_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int idx_by_name ({\b Obj_type}  {\i object_type}, {\b C_str}  {\i object_name})}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 324 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00324                                                         \{                                                   {\cf20 // Function to get object (arch/node) vector index by name (-1 = No match found / -2 = Error)}\par
00325   {\cf20 /* Body */}\par
00326   {\cf18 int} match_found = -1;                                                                                     {\cf20 // Match found idx (-1 = No match found / -2 = Error)}\par
00327   {\cf19 switch} (object_type)\{                                                                                     {\cf20 // Object type switch-case}\par
00328     {\cf19 case} AR:                                                                                                {\cf20 // Object type = arch}\par
00329       {\cf19 for} ({\cf18 int} i = 0; i < ars_collect_size; ++i)                                                            {\cf20 // Search match by-name in arches collection vector}\par
00330         {\cf19 if} (strcmp(object_name, archs_collect_vect[i].name) == 0)                                           {\cf20 // Match detecting condition}\par
00331           match_found = i;                                                                                  {\cf20 // Retun match idx in vect}\par
00332       {\cf19 break};\par
00334     {\cf19 case} ND:                                                                                                {\cf20 // Object type = node}\par
00335       {\cf19 for} ({\cf18 int} j = 0; j < nds_collect_size; ++j)                                                            {\cf20 // Search match by-name in nodes collection vector}\par
00336         {\cf19 if} (strcmp(object_name, nodes_collect_vect[j].name) == 0)                                           {\cf20 // Match detecting condition}\par
00337           match_found = j;                                                                                  {\cf20 // Retun match idx in vect}\par
00338       {\cf19 break};\par
00340     {\cf19 default}:                                                                                                {\cf20 // Unknown object type}\par
00341       fbk_err({\cf22 "Error, bad parameter value! A function got an unexpected patameter value"});                  {\cf20 // Print error fbk}\par
00342       perror({\cf22 "Wrong \\"object_type\\" parameter value passsed to \\"idx_by_name\\" function!"});                 {\cf20 // Print perror fbk}\par
00343       --match_found;                                                                                        {\cf20 // Decrease match found val to indicate error}\par
00344       {\cf19 break};\par
00345   \}\par
00346   {\cf19 if} (match_found == -1)                                                                                    {\cf20 // No march found cond}\par
00347     fbk_err({\cf22 "Error, no match found! Specified name probably wrong or not present in collection"});           {\cf20 // Print err fbk}\par
00348   {\cf19 return} match_found;                                                                                       {\cf20 // Return val}\par
00349 \}\par
}
}
{\xe \v not_an_node_conn\:lib_graph.c}
{\xe \v lib_graph.c\:not_an_node_conn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b Connection}* not_an_node_conn ({\b Node} *  {\i nd}, int *const  {\i vect_size}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 239 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00239                                                                    \{                                        {\cf20 // Function to get a vector of non-analyzed connections associated to a specific node (vector allocated inside heap)}\par
00240   {\cf20 /* Body */}\par
00241   List_elem* tmp_el = nd->archs_lst;                                                                        {\cf20 // Define tmp list elem ptr var (to scroll arches inside node conn. arches list)}\par
00242   Connection* nan_nd_conn_vect = NULL;                                                                      {\cf20 // Vector of non-analyzed connections associated to a specific node}\par
00243   *vect_size = 0;                                                                                           {\cf20 // Number of non-analyzed connections associated to a specific node (rst)}\par
00244   {\cf19 for} (; tmp_el != NULL; tmp_el = tmp_el->nxt)\{                                                             {\cf20 // Scroll node conn. arches list, upd num of non-analyzed connections associated to a specific node, resize node connections vect inside heap and define vector elements}\par
00245     {\cf19 if} ((nd == tmp_el->ar->nd1 && tmp_el->ar->nd2->dd->an_flg == 0) ||\par
00246         (nd == tmp_el->ar->nd2 && tmp_el->ar->nd1->dd->an_flg == 0))\{                                       {\cf20 // Add node non-analyzed connection only if the destination node ain't been already analyzed}\par
00247       {\cf19 if} (*vect_size == 0)                                                                                  {\cf20 // If it's the first iteration, allocate vector of non-analyzed connections associated to a specific node}\par
00248         nan_nd_conn_vect = allocate_new_nd_conn_vect(*vect_size+1);                                         {\cf20 // Init node non-analyzed connections vect inside heap}\par
00249       {\cf19 else}                                                                                                  {\cf20 // If it's not the first iteration, reallocate vector of non-analyzed connections associated to a specific node (resize)}\par
00250         reallocate_nd_conn_vect(&nan_nd_conn_vect, *vect_size+1);                                           {\cf20 // Resize node non-analyzed connections vect inside heap}\par
00251       {\cf19 if} (nd == tmp_el->ar->nd1)                                                                            {\cf20 // If specified node memo addr corresponds to the arch conn. node1, assign arch conn. node2 in newly allocated element inside vect}\par
00252         (nan_nd_conn_vect+iaddr(V, *vect_size, *vect_size+1))->nd = tmp_el->ar->nd2;                        {\cf20 // Define elements of node (non-analyzed) connections vect inside heap (connection node)}\par
00253       {\cf19 else}                                                                                                  {\cf20 // If specified node memo addr doesn't correspond to the arch conn. node1, assign arch conn. node1 in newly allocated element inside vect}\par
00254         (nan_nd_conn_vect+iaddr(V, *vect_size, *vect_size+1))->nd = tmp_el->ar->nd1;                        {\cf20 // Define elements of node (non-analyzed) connections vect inside heap (connection node)}\par
00255       (nan_nd_conn_vect+iaddr(V, *vect_size, *vect_size+1))->ar = tmp_el->ar;                               {\cf20 // Define elements of node (non-analyzed) connections vect inside heap (connection arch)}\par
00256       ++*vect_size;                                                                                         {\cf20 // Vector of non-analyzed connections associated to a specific node size val upd}\par
00257     \}\par
00258   \}\par
00259   {\cf19 return} nan_nd_conn_vect;                                                                                  {\cf20 // Return vector of non-analyzed connections associated to a specific node}\par
00260 \}\par
}
}
{\xe \v print_min_paths\:lib_graph.c}
{\xe \v lib_graph.c\:print_min_paths}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void print_min_paths (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 263 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00263                              \{                                                                              {\cf20 // Function to print each min path cost to reach every single accessible node from specified source-node}\par
00264   {\cf20 /* Body */}\par
00265   {\cf19 for} ({\cf18 int} m = 0; m < nds_collect_size; ++m)\{                                                               {\cf20 // Min path costs printin' FOR cycle}\par
00266     fbk_nl(1);  fbk_separator(SEP_CHR, GN);                                                                 {\cf20 // Print separator fbk}\par
00267     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "--> Node name"}, nodes_collect_vect[m].name);                             {\cf20 // Print node name fbk}\par
00268     {\cf19 if} (nodes_collect_vect[m].dd->min_path_cost < _REAL_MAX_ &&\par
00269         &nodes_collect_vect[m] != &nodes_collect_vect[src_node_idx])\{                                       {\cf20 // If node is reachble from specified source node}\par
00270       fbk_nl(1); fbk_gn_lbu_ye_real({\cf22 "Min path cost to node"}, nodes_collect_vect[m].dd->min_path_cost);      {\cf20 // Print min path cost to reach that node from specified source-node fbk}\par
00271     \} {\cf19 else} \{                                                                                                {\cf20 // Else if node is unreachble from specified source node}\par
00272       {\cf19 if} (&nodes_collect_vect[m] == &nodes_collect_vect[src_node_idx])\{                                     {\cf20 // Else if node memo addr corresponds to the source node memo addr}\par
00273         fbk_nl(1);                                                                                          {\cf20 // Print new-line fbk}\par
00274         fbk_gn_lbu_ye_str({\cf22 "Min path cost to node"}, {\cf22 "This node is the specified source node!"});              {\cf20 // Print node correspondin' to the specified source node fbk}\par
00275       \} {\cf19 else} \{                                                                                              {\cf20 // Else if node is unreachble from specified source node}\par
00276         fbk_nl(1);                                                                                          {\cf20 // Print new-line fbk}\par
00277         fbk_gn_lbu_ye_str({\cf22 "Min path cost to node"}, {\cf22 "Node unreachble from specified source node!"});          {\cf20 // Print node unreachble fbk}\par
00278       \}\par
00279     \}\par
00280   \}\par
00281   fbk_nl(1);  fbk_separator(SEP_CHR, GN);                                                                   {\cf20 // Print separator fbk}\par
00282 \}\par
}
}
{\xe \v print_shortest_path\:lib_graph.c}
{\xe \v lib_graph.c\:print_shortest_path}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void print_shortest_path (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 285 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00285                                  \{                                                                          {\cf20 // Print shortest path from pre-defined source node to specified destination node}\par
00286   {\cf20 /* Body */}\par
00287   {\cf19 if} (min_pth_conn_vect_size >= 2)\{                                                                         {\cf20 // If destination node is reachble and it's different from source node}\par
00288     fbk_nl(1);                                                                                              {\cf20 // New line fbk}\par
00289     fbk_gn_lbu_ye_int({\cf22 "Number of nodes between source and destination node"}, min_pth_conn_vect_size-2);     {\cf20 // Print num of nodes btwn source and destination node fbk}\par
00290     fbk_nl(1);                                                                                              {\cf20 // New line fbk}\par
00291     fbk_gn_lbu_ye_int({\cf22 "Number of arches between source and destination node"}, min_pth_conn_vect_size-1);    {\cf20 // Print num of archs btwn source and destination node fbk}\par
00292     fbk_nl(1);  fbk_separator(SHORT_PTH_SEP_CHR, LGN);                                                      {\cf20 // Print separator fbk}\par
00293     fbk_nl(1);  fbk_gn_pu({\cf22 "Showing shortest path between specified source and destination nodes:"});         {\cf20 // Showin' shortest path fbk}\par
00294     delay(PRINT_DLY_MS);                                                                                    {\cf20 // Wait dly time}\par
00295     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Status"}, {\cf22 "STARTING"});                                                    {\cf20 // Print startin' from source node fbk}\par
00296     delay(PRINT_DLY_MS);                                                                                    {\cf20 // Wait dly time}\par
00297     fbk_nl(1);                                                                                              {\cf20 // New line fbk}\par
00298     fbk_gn_lbu_ye_str({\cf22 "Source-node name"}, min_path_conn_vect[0].nd->name);                                  {\cf20 // Source node name fbk}\par
00299     delay(PRINT_DLY_MS);                                                                                    {\cf20 // Wait dly time}\par
00300     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Path-arch name"}, min_path_conn_vect[1].ar->name);                        {\cf20 // Path arch name fbk}\par
00301     fbk_tabs(1);  fbk_gn_lbu_ye_real({\cf22 "Arch cost"}, min_path_conn_vect[1].ar->cost);                          {\cf20 // Path arch cost fbk}\par
00302     delay(PRINT_DLY_MS);                                                                                    {\cf20 // Wait dly time}\par
00303     {\cf19 for} ({\cf18 int} i = 1; i < min_pth_conn_vect_size-1; ++i)\{                                                     {\cf20 // Min path scrollin' and printin' FOR cycle (btwn src and dest nodes)}\par
00304       fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Path-node name"}, min_path_conn_vect[i].nd->name);                      {\cf20 // Path node name fbk}\par
00305       delay(PRINT_DLY_MS);                                                                                  {\cf20 // Wait dly time}\par
00306       fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Path-arch name"}, min_path_conn_vect[i+1].ar->name);                    {\cf20 // Path arch name fbk}\par
00307       fbk_tabs(1);  fbk_gn_lbu_ye_real({\cf22 "Arch cost"}, min_path_conn_vect[i+1].ar->cost);                      {\cf20 // Path arch cost fbk}\par
00308       delay(PRINT_DLY_MS);                                                                                  {\cf20 // Wait dly time}\par
00309     \}\par
00310     fbk_nl(1);                                                                                              {\cf20 // New line fbk}\par
00311     fbk_gn_lbu_ye_str({\cf22 "Destination-node name"}, min_path_conn_vect[min_pth_conn_vect_size-1].nd->name);      {\cf20 // Destination node name fbk}\par
00312     delay(PRINT_DLY_MS);                                                                                    {\cf20 // Wait dly time}\par
00313     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Status"}, {\cf22 "ARRIVED"});                                                     {\cf20 // Print arrived to destination node fbk}\par
00314     fbk_nl(1);  fbk_separator(SHORT_PTH_SEP_CHR, LGN);                                                      {\cf20 // Print separator fbk}\par
00315     delay(PRINT_DLY_MS);                                                                                    {\cf20 // Wait dly time}\par
00316   \} {\cf19 else} \{                                                                                                  {\cf20 // Else if destination node is unreachble or it's equal to source node}\par
00317     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Number of nodes between source and destination node"}, {\cf22 "-"});              {\cf20 // Print no nodes btwn src and dest nodes}\par
00318     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Path-node name"}, {\cf22 "-"});                                                   {\cf20 // Print no archs btwn src and dest nodes}\par
00319   \}\par
00320 \}\par
}
}
{\xe \v reallocate_dijk_dataset_vect\:lib_graph.c}
{\xe \v lib_graph.c\:reallocate_dijk_dataset_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void reallocate_dijk_dataset_vect (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 202 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00202                                           \{                                                                 {\cf20 // Function to reallocate Dijkstra-dataset vector (resize)}\par
00203   {\cf20 /* Body */}\par
00204   dijk_dataset_vect = realloc(dijk_dataset_vect, ({\cf18 size_t})nds_collect_size*{\cf17 sizeof}(Dijkstra_dataset));        {\cf20 // Dijkstra-dataset vect ptr addr upd to make sure it points at first reallocated memo cell inside heap}\par
00205   {\cf19 if} (dijk_dataset_vect == NULL || nds_collect_size == 0)\{                                                  {\cf20 // Check realloc funct output to detect dynamic memory allocation errors}\par
00206     fbk_err({\cf22 "Ops! Encountred error during graph data management"});                                          {\cf20 // Error fbk}\par
00207     perror({\cf22 "Found error during Dijkstra-dataset vector dynamic memory reallocation with realloc!"});         {\cf20 // Print perror fbk}\par
00208     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00209     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00210   \}\par
00211 \}\par
}
}
{\xe \v reallocate_nd_conn_vect\:lib_graph.c}
{\xe \v lib_graph.c\:reallocate_nd_conn_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void reallocate_nd_conn_vect ({\b Connection} **  {\i nd_conn_vect}, {\b C_int}  {\i size}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 227 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00227                                                                           \{                                 {\cf20 // Function to reallocate node connections vector (resize)}\par
00228   {\cf20 /* Body */}\par
00229   *nd_conn_vect = realloc(*nd_conn_vect, ({\cf18 size_t})size*{\cf17 sizeof}(Connection));                                  {\cf20 // Node connections vect ptr addr upd to make sure it points at first reallocated memo cell inside heap}\par
00230   {\cf19 if} (*nd_conn_vect == NULL || size == 0)\{                                                                  {\cf20 // Check realloc funct output to detect dynamic memory allocation errors}\par
00231     fbk_err({\cf22 "Ops! Encountred error during graph data management"});                                          {\cf20 // Error fbk}\par
00232     perror({\cf22 "Found error during node connections vector dynamic memory reallocation with realloc!"});         {\cf20 // Print perror fbk}\par
00233     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00234     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00235   \}\par
00236 \}\par
}
}
{\xe \v reallocate_new_archs\:lib_graph.c}
{\xe \v lib_graph.c\:reallocate_new_archs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void reallocate_new_archs (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 164 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00164                                   \{                                                                         {\cf20 // Function to reallocate new graph arches (single/vect)}\par
00165   {\cf20 /* Body */}\par
00166   archs_collect_vect = realloc(archs_collect_vect, ({\cf18 size_t})(ars_collect_size+1)*{\cf17 sizeof}(Arch));              {\cf20 // Tmp graph arch ptr creation to point at first allocated memo cell inside heap}\par
00167   {\cf19 if} (archs_collect_vect == NULL)\{                                                                          {\cf20 // Check realloc funct output to detect dynamic memory allocation errors}\par
00168     fbk_err({\cf22 "Ops! Encountred error during graph data management"});                                          {\cf20 // Error fbk}\par
00169     perror({\cf22 "Found error during graph arches dynamic memory reallocation with realloc!"});                    {\cf20 // Print perror fbk}\par
00170     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00171     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00172   \} {\cf19 else}                                                                                                    {\cf20 // In case of dyn memo reallocation OK}\par
00173     ++ars_collect_size;                                                                                     {\cf20 // Upd arches collection vect size}\par
00174 \}\par
}
}
{\xe \v reallocate_new_nodes\:lib_graph.c}
{\xe \v lib_graph.c\:reallocate_new_nodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void reallocate_new_nodes (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 177 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00177                                   \{                                                                         {\cf20 // Function to reallocate new graph nodes (single/vect)}\par
00178   {\cf20 /* Body */}\par
00179   nodes_collect_vect = realloc(nodes_collect_vect, ({\cf18 size_t})(nds_collect_size+1)*{\cf17 sizeof}(Node));              {\cf20 // Tmp graph node ptr creation to point at first allocated memo cell inside heap}\par
00180   {\cf19 if} (nodes_collect_vect == NULL)\{                                                                          {\cf20 // Check realloc funct output to detect dynamic memory allocation errors}\par
00181     fbk_err({\cf22 "Ops! Encountred error during graph data management"});                                          {\cf20 // Error fbk}\par
00182     perror({\cf22 "Found error during graph nodes dynamic memory reallocation with realloc!"});                     {\cf20 // print Perror fbk}\par
00183     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00184     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00185   \} {\cf19 else}                                                                                                    {\cf20 // In case of dyn memo reallocation OK}\par
00186     ++nds_collect_size;                                                                                     {\cf20 // Upd nodes collection vect size}\par
00187 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v _REAL_MAX_\:lib_graph.c}
{\xe \v lib_graph.c\:_REAL_MAX_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Real} _REAL_MAX_ = __DBL_MAX__}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file lib_graph.c.}\par
}
{\xe \v archs_collect_vect\:lib_graph.c}
{\xe \v lib_graph.c\:archs_collect_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Arch}* archs_collect_vect = NULL}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file lib_graph.c.}\par
}
{\xe \v ars_collect_size\:lib_graph.c}
{\xe \v lib_graph.c\:ars_collect_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ars_collect_size = 0}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file lib_graph.c.}\par
}
{\xe \v dest_node_idx\:lib_graph.c}
{\xe \v lib_graph.c\:dest_node_idx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int dest_node_idx = 0}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file lib_graph.c.}\par
}
{\xe \v dijk_dataset_vect\:lib_graph.c}
{\xe \v lib_graph.c\:dijk_dataset_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Dijkstra_dataset}* dijk_dataset_vect = NULL}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file lib_graph.c.}\par
}
{\xe \v min_path_conn_vect\:lib_graph.c}
{\xe \v lib_graph.c\:min_path_conn_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Connection}* min_path_conn_vect = NULL}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file lib_graph.c.}\par
}
{\xe \v min_pth_conn_vect_size\:lib_graph.c}
{\xe \v lib_graph.c\:min_pth_conn_vect_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int min_pth_conn_vect_size = 0}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file lib_graph.c.}\par
}
{\xe \v nds_collect_size\:lib_graph.c}
{\xe \v lib_graph.c\:nds_collect_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int nds_collect_size = 0}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file lib_graph.c.}\par
}
{\xe \v nodes_collect_vect\:lib_graph.c}
{\xe \v lib_graph.c\:nodes_collect_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Node}* nodes_collect_vect = NULL}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file lib_graph.c.}\par
}
{\xe \v realloc_flg\:lib_graph.c}
{\xe \v lib_graph.c\:realloc_flg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Byte} realloc_flg = 0}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file lib_graph.c.}\par
}
{\xe \v src_node_idx\:lib_graph.c}
{\xe \v lib_graph.c\:src_node_idx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int src_node_idx = 0}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file lib_graph.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/graph/lib_graph.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/graph/lib_graph.h}
{\xe \v lib/graph/lib_graph.h}
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
csdcds }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../ui/lib_ui.h"}\par
{\f2 #include "../timer/lib_timer.h"}\par
{\f2 #include <limits.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b list_elem}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b node}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b arch}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dijkstra_dataset}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b connection}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ND_STR_LEN}\~ 31\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Max node-names lenth in chars (30 + '\\0'). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AR_STR_LEN}\~ 31\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Max arch-names lenth in chars (30 + '\\0'). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SEP_CHR}\~ '-'\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Char used to create separator lines by library in output feedbacks }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHORT_PTH_SEP_CHR}\~ '*'\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Char used to create separator lines by library in shortest-path output feedbacks }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PRINT_DLY_MS}\~ 500\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Printing delay in shortest-path description }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b list_elem} {\b List_elem}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b List_elem} * {\b List}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b node} {\b Node}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b Node} * {\b Graph_node}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b arch} {\b Arch}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b Arch} * {\b Graph_arch}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b dijkstra_dataset} {\b Dijkstra_dataset}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b connection} {\b Connection}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b vect_coords} {\b Vect_coords}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b verbose_mode} {\b Verbose_mode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b obj_type} {\b Obj_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b node_pos_in_arch} {\b Node_pos_in_arch}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b arch_pos_typ} {\b Arch_pos_typ}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b vect_coords} \{ {\b V}, 
{\b V2}, 
{\b V3}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b verbose_mode} \{ {\b Y}, 
{\b N}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b obj_type} \{ {\b AR}, 
{\b ND}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b node_pos_in_arch} \{ {\b ARCH_ND1}, 
{\b ARCH_ND2}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b arch_pos_typ} \{ {\b LIST_HEAD}, 
{\b LIST_POS}, 
{\b LIST_TAIL}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b idx_by_name} ({\b Obj_type} object_type, {\b C_str} object_name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add_new_arch} ({\b C_str}, {\b C_real} cost)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add_new_node} ({\b C_str} name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b connect_node_arch} ({\b C_str} ar_name, {\b C_str} nd_name, {\b Node_pos_in_arch} nd_pos, {\b Arch_pos_typ} ar_pos,...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dijkstra_alg} ({\b C_str} src_nd_name, {\b Verbose_mode} v_mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b buid_shortest_path} ({\b C_str} dest_nd_name, {\b Verbose_mode} v_mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b free_graph} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b C_str} {\b node_pos_in_arch_str} [] = \{"ARCH NODE1 POSITION", "ARCH NODE2 POSITION"\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b C_str} {\b arch_pos_typ_str} [] = \{"LIST HEAD POSITION", "LIST SPECIFIC POSITION", "LIST TAIL POSITION"\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Real} {\b _REAL_MAX}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ars_collect_size}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b nds_collect_size}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b min_pth_conn_vect_size}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Arch} * {\b archs_collect_vect}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Node} * {\b nodes_collect_vect}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Connection} * {\b min_path_conn_vect}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
csdcds \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
saxxasxsa \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v AR_STR_LEN\:lib_graph.h}
{\xe \v lib_graph.h\:AR_STR_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AR_STR_LEN\~ 31}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Max arch-names lenth in chars (30 + '\\0'). }}\par
{
Definition at line 36 of file lib_graph.h.}\par
}
{\xe \v ND_STR_LEN\:lib_graph.h}
{\xe \v lib_graph.h\:ND_STR_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ND_STR_LEN\~ 31}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Max node-names lenth in chars (30 + '\\0'). }}\par
{
Definition at line 34 of file lib_graph.h.}\par
}
{\xe \v PRINT_DLY_MS\:lib_graph.h}
{\xe \v lib_graph.h\:PRINT_DLY_MS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PRINT_DLY_MS\~ 500}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Printing delay in shortest-path description }}\par
{
Definition at line 42 of file lib_graph.h.}\par
}
{\xe \v SEP_CHR\:lib_graph.h}
{\xe \v lib_graph.h\:SEP_CHR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SEP_CHR\~ '-'}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Char used to create separator lines by library in output feedbacks }}\par
{
Definition at line 38 of file lib_graph.h.}\par
}
{\xe \v SHORT_PTH_SEP_CHR\:lib_graph.h}
{\xe \v lib_graph.h\:SHORT_PTH_SEP_CHR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHORT_PTH_SEP_CHR\~ '*'}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Char used to create separator lines by library in shortest-path output feedbacks }}\par
{
Definition at line 40 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v Arch\:lib_graph.h}
{\xe \v lib_graph.h\:Arch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b arch} {\b Arch}}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Arch_pos_typ\:lib_graph.h}
{\xe \v lib_graph.h\:Arch_pos_typ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b arch_pos_typ} {\b Arch_pos_typ}}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Connection\:lib_graph.h}
{\xe \v lib_graph.h\:Connection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b connection} {\b Connection}}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Dijkstra_dataset\:lib_graph.h}
{\xe \v lib_graph.h\:Dijkstra_dataset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b dijkstra_dataset} {\b Dijkstra_dataset}}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Graph_arch\:lib_graph.h}
{\xe \v lib_graph.h\:Graph_arch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b Arch}* {\b Graph_arch}}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 68 of file lib_graph.h.}\par
}
{\xe \v Graph_node\:lib_graph.h}
{\xe \v lib_graph.h\:Graph_node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b Node}* {\b Graph_node}}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file lib_graph.h.}\par
}
{\xe \v List\:lib_graph.h}
{\xe \v lib_graph.h\:List}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b List_elem}* {\b List}}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 51 of file lib_graph.h.}\par
}
{\xe \v List_elem\:lib_graph.h}
{\xe \v lib_graph.h\:List_elem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b list_elem} {\b List_elem}}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Node\:lib_graph.h}
{\xe \v lib_graph.h\:Node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b node} {\b Node}}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Node_pos_in_arch\:lib_graph.h}
{\xe \v lib_graph.h\:Node_pos_in_arch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b node_pos_in_arch} {\b Node_pos_in_arch}}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Obj_type\:lib_graph.h}
{\xe \v lib_graph.h\:Obj_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b obj_type} {\b Obj_type}}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Vect_coords\:lib_graph.h}
{\xe \v lib_graph.h\:Vect_coords}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b vect_coords} {\b Vect_coords}}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Verbose_mode\:lib_graph.h}
{\xe \v lib_graph.h\:Verbose_mode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b verbose_mode} {\b Verbose_mode}}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v arch_pos_typ\:lib_graph.h}
{\xe \v lib_graph.h\:arch_pos_typ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b arch_pos_typ}}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v LIST_HEAD\:lib_graph.h}
{\xe \v lib_graph.h\:LIST_HEAD}
{\qr LIST_HEAD{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
\cell }{\cell }{\row }
{\xe \v LIST_POS\:lib_graph.h}
{\xe \v lib_graph.h\:LIST_POS}
{\qr LIST_POS{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
\cell }{\cell }{\row }
{\xe \v LIST_TAIL\:lib_graph.h}
{\xe \v lib_graph.h\:LIST_TAIL}
{\qr LIST_TAIL{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
\cell }{\cell }{\row }
}
\par
{
Definition at line 92 of file lib_graph.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00092 \{LIST_HEAD, LIST_POS, LIST_TAIL\} Arch_pos_typ;                                    {\cf20 // Position type to add arch in node arches connections list enum typedef}\par
}
}
{\xe \v node_pos_in_arch\:lib_graph.h}
{\xe \v lib_graph.h\:node_pos_in_arch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b node_pos_in_arch}}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v ARCH_ND1\:lib_graph.h}
{\xe \v lib_graph.h\:ARCH_ND1}
{\qr ARCH_ND1{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
\cell }{\cell }{\row }
{\xe \v ARCH_ND2\:lib_graph.h}
{\xe \v lib_graph.h\:ARCH_ND2}
{\qr ARCH_ND2{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
\cell }{\cell }{\row }
}
\par
{
Definition at line 89 of file lib_graph.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00089 \{ARCH_ND1, ARCH_ND2\} Node_pos_in_arch;                                  {\cf20 // Node position in arch enum typedef}\par
}
}
{\xe \v obj_type\:lib_graph.h}
{\xe \v lib_graph.h\:obj_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b obj_type}}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v AR\:lib_graph.h}
{\xe \v lib_graph.h\:AR}
{\qr AR{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
\cell }{\cell }{\row }
{\xe \v ND\:lib_graph.h}
{\xe \v lib_graph.h\:ND}
{\qr ND{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
\cell }{\cell }{\row }
}
\par
{
Definition at line 87 of file lib_graph.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00087 \{AR, ND\} Obj_type;                                                              {\cf20 // Object type enum typedef (arch/node)}\par
}
}
{\xe \v vect_coords\:lib_graph.h}
{\xe \v lib_graph.h\:vect_coords}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b vect_coords}}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v V\:lib_graph.h}
{\xe \v lib_graph.h\:V}
{\qr V{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
\cell }{\cell }{\row }
{\xe \v V2\:lib_graph.h}
{\xe \v lib_graph.h\:V2}
{\qr V2{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
\cell }{\cell }{\row }
{\xe \v V3\:lib_graph.h}
{\xe \v lib_graph.h\:V3}
{\qr V3{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
\cell }{\cell }{\row }
}
\par
{
Definition at line 83 of file lib_graph.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00083 \{V, V2, V3\} Vect_coords;                                                     {\cf20 // Matrix/vectors enum typedef}\par
}
}
{\xe \v verbose_mode\:lib_graph.h}
{\xe \v lib_graph.h\:verbose_mode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b verbose_mode}}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Y\:lib_graph.h}
{\xe \v lib_graph.h\:Y}
{\qr Y{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
\cell }{\cell }{\row }
{\xe \v N\:lib_graph.h}
{\xe \v lib_graph.h\:N}
{\qr N{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
\cell }{\cell }{\row }
}
\par
{
Definition at line 85 of file lib_graph.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00085 \{Y, N\} Verbose_mode;                                                        {\cf20 // Verbose mode enum typedef}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v add_new_arch\:lib_graph.h}
{\xe \v lib_graph.h\:add_new_arch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void add_new_arch ({\b C_str} , {\b C_real}  {\i cost})}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 352 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00352                                           \{                                                                 {\cf20 // Function to add new graph arch (arch allocated inside heap)}\par
00353   {\cf20 /* Body */}\par
00354   fbk_nl(1);  fbk_gn_pu({\cf22 "Adding new graph arch..."});                                                        {\cf20 // Adding new graph arch fbk}\par
00355   {\cf19 if} (cost > 0.0)\{                                                                                          {\cf20 // If cost is positive}\par
00356     {\cf19 if} (archs_collect_vect == NULL)                                                                         {\cf20 // Check arches collection vector, if null}\par
00357       allocate_new_archs();                                                                                 {\cf20 // Allocate a new graph arch inside arches collection vector (vect calloc)}\par
00358     {\cf19 else}                                                                                                    {\cf20 // Else if not null}\par
00359       reallocate_new_archs();                                                                               {\cf20 // Allocate a new graph arch inside arches collection vector (vect realloc)}\par
00360     {\cf19 if} (strlen(name) > 0 && strlen(name) < AR_STR_LEN)\{                                                     {\cf20 // Check arch name length consistency, if ok}\par
00361       strcpy(archs_collect_vect[ars_collect_size-1].name, name);  fbk_nl(1);                                {\cf20 // Copy name inside arch name var}\par
00362     \} {\cf19 else} \{                                                                                                {\cf20 // Else if arch name length consistency ain't ok}\par
00363       fbk_err({\cf22 "Error, invalid arch name size! Overriding arch name with arch number in collection"});        {\cf20 // Print error fbk}\par
00364       {\cf18 char} name_ovrd[AR_STR_LEN];                                                                           {\cf20 // Define new name to override input name}\par
00365       sprintf(name_ovrd, {\cf22 "%d"}, ars_collect_size);                                                           {\cf20 // Define override-name as arch number in arches collection vect}\par
00366       strcpy(archs_collect_vect[ars_collect_size-1].name, name_ovrd);                                       {\cf20 // Copy override-name inside arch name var}\par
00367     \}\par
00368     archs_collect_vect[ars_collect_size-1].cost = cost;                                                     {\cf20 // Define arch cost}\par
00369     archs_collect_vect[ars_collect_size-1].nd1 = NULL;                                                      {\cf20 // Set node1 connection to NULL}\par
00370     archs_collect_vect[ars_collect_size-1].nd2 = NULL;                                                      {\cf20 // Set node2 connection to NULL}\par
00371     fbk_gn_lbu_ye_str({\cf22 "New arch name"}, archs_collect_vect[ars_collect_size-1].name);                        {\cf20 // New graph arch name fbk}\par
00372     fbk_nl(1);  fbk_gn_lbu_ye_real({\cf22 "New arch cost"}, archs_collect_vect[ars_collect_size-1].cost);           {\cf20 // New graph arch cost fbk}\par
00373     fbk_nl(1);  fbk_gn_cy({\cf22 "New graph arch correctly added!\\n"});                                             {\cf20 // New graph arch correctly added fbk}\par
00374   \} {\cf19 else} \{                                                                                                  {\cf20 // Else if cost ain't positive}\par
00375     fbk_err({\cf22 "Ops! Encountred error during graph data management"});                                          {\cf20 // Error fbk}\par
00376     perror({\cf22 "Found error during arch object creation, its cost must be strictly positive!"});                 {\cf20 // Print perror fbk}\par
00377     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00378     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00379   \}\par
00380 \}\par
}
}
{\xe \v add_new_node\:lib_graph.h}
{\xe \v lib_graph.h\:add_new_node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void add_new_node ({\b C_str}  {\i name})}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 383 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00383                              \{                                                                              {\cf20 // Function to add new graph node (node allocated inside heap)}\par
00384   {\cf20 /* Body */}\par
00385   fbk_nl(1);  fbk_gn_pu({\cf22 "Adding new graph node..."});                                                        {\cf20 // Adding new graph node fbk}\par
00386   {\cf19 if} (nodes_collect_vect == NULL)                                                                           {\cf20 // Check nodes collection vector, if null}\par
00387     allocate_new_nodes();                                                                                   {\cf20 // Allocate a new graph node inside nodes collection vector (vect calloc)}\par
00388   {\cf19 else}                                                                                                      {\cf20 // Else if not null}\par
00389     reallocate_new_nodes();                                                                                 {\cf20 // Allocate a new graph node inside nodes collection vector (vect realloc)}\par
00390   {\cf19 if} (strlen(name) > 0 && strlen(name) < ND_STR_LEN)\{                                                       {\cf20 // Check node name length consistency, if ok}\par
00391     strcpy(nodes_collect_vect[nds_collect_size-1].name, name);  fbk_nl(1);                                  {\cf20 // Copy name inside node name var}\par
00392   \} {\cf19 else} \{                                                                                                  {\cf20 // Else if node name length consistency ain't ok}\par
00393     fbk_err({\cf22 "Error, invalid node name size! Overriding arch name with node number in collection"});          {\cf20 // Print error fbk}\par
00394     {\cf18 char} name_ovrd[ND_STR_LEN];                                                                             {\cf20 // Define new name to override input name}\par
00395     sprintf(name_ovrd, {\cf22 "%d"}, nds_collect_size);                                                             {\cf20 // Define override-name as node number in arches collection vect}\par
00396     strcpy(nodes_collect_vect[nds_collect_size-1].name, name_ovrd);                                         {\cf20 // Copy override-name inside node name var}\par
00397   \}\par
00398   nodes_collect_vect[nds_collect_size-1].archs_lst = NULL;                                                  {\cf20 // Set node arches list to NULL}\par
00399   nodes_collect_vect[nds_collect_size-1].dd = NULL;                                                         {\cf20 // Set node Dijkstra-dataset to NULL}\par
00400   fbk_gn_lbu_ye_str({\cf22 "New node name"}, nodes_collect_vect[nds_collect_size-1].name);                          {\cf20 // New graph arch name fbk}\par
00401   fbk_nl(1);  fbk_gn_cy({\cf22 "New graph node correctly added!\\n"});                                               {\cf20 // New graph node correctly added fbk}\par
00402 \}\par
}
}
{\xe \v buid_shortest_path\:lib_graph.h}
{\xe \v lib_graph.h\:buid_shortest_path}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void buid_shortest_path ({\b C_str}  {\i dest_nd_name}, {\b Verbose_mode}  {\i v_mode})}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 530 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00530                                                                 \{                                           {\cf20 // Reconstruct shortest path to specified destination node from source node (pre-defined in Dijkstra's algorithm, min path connections vect allocated/reallocated inside heap) - Y/N for verbose mode}\par
00531   {\cf20 /* Body */}\par
00532   fbk_nl(1);  fbk_gn_pu({\cf22 "Building min cost path from pre-defined source to specified destination..."});      {\cf20 // Print reconstructin' shortest path from pre-defined source to specified destination fbk}\par
00533   {\cf19 if} (realloc_flg != 0)\{                                                                                    {\cf20 // If Dijkstra's algorithm has already been called at least once}\par
00534     {\cf20 // Print info fbks}\par
00535     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "--> Source node name"}, nodes_collect_vect[src_node_idx].name);           {\cf20 // Print src-nd name fbk}\par
00536     {\cf18 int} dest_nd_num = idx_by_name(ND, dest_nd_name);                                                        {\cf20 // Get destination node idx by-name}\par
00537     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "--> Destination node name"}, dest_nd_name);                               {\cf20 // Print dest-nd name fbk}\par
00538     {\cf19 if} (dest_nd_num >= 0)\{                                                                                  {\cf20 // Check error conditions ok}\par
00539       dest_node_idx = dest_nd_num;                                                                          {\cf20 // Set/upd destination node idx lib-var val}\par
00540       {\cf19 if} (nodes_collect_vect[dest_nd_num].dd->min_path_cost < _REAL_MAX_ && dest_nd_num != src_node_idx)\{   {\cf20 // If destination node is reachble from pre-defined source node}\par
00541         fbk_nl(1);                                                                                          {\cf20 // Print new-line fbk}\par
00542         fbk_gn_lbu_ye_real({\cf22 "Min path cost to node"}, nodes_collect_vect[dest_nd_num].dd->min_path_cost);     {\cf20 // Print min path cost to reach destination node from pre-defined source node fbk}\par
00543       \} {\cf19 else} {\cf19 if} (dest_nd_num == src_node_idx)\{                                                              {\cf20 // Else if destination node memo addr corresponds to the source node memo addr}\par
00544         fbk_nl(1);                                                                                          {\cf20 // Print new-line fbk}\par
00545         fbk_gn_lbu_ye_str({\cf22 "Min path cost to node"}, {\cf22 "Destination corresponds to pre-defined source node!"});  {\cf20 // Print destination node correspondin' to the pre-defined source node fbk}\par
00546       \} {\cf19 else} \{                                                                                              {\cf20 // Else if destination node is unreachble from pre-defined source node}\par
00547         fbk_nl(1);                                                                                          {\cf20 // Print new-line fbk}\par
00548         fbk_gn_lbu_ye_str({\cf22 "Min path cost to node"}, {\cf22 "Destination unreachble from pre-defined source node!"}); {\cf20 // Print destination node unreachble fbk}\par
00549       \}\par
00550       {\cf20 // Find min-cost path archs & nodes goin' backward from destination to source node}\par
00551       Graph_node tmp_nd = &nodes_collect_vect[dest_nd_num];                                                 {\cf20 // Init tmp node var to reconstruct min-cost path backwards}\par
00552       List_elem* tmpl = NULL;                                                                               {\cf20 // Def tmp list ptr var (for archs) to reconstruct min-cost path backwards}\par
00553       {\cf19 if} (min_pth_conn_vect_size != 0)                                                                      {\cf20 // If min-cost paths vector size ain't zero}\par
00554         min_pth_conn_vect_size = 0;                                                                         {\cf20 // Make it zero}\par
00555       {\cf19 while} (tmp_nd != NULL)\{                                                                               {\cf20 // Scroll min-cost path backwars 'till src node}\par
00556         {\cf19 if} (realloc_flg == 0)\{                                                                              {\cf20 // If realloc flag ain't been set}\par
00557           min_path_conn_vect = allocate_new_nd_conn_vect(++min_pth_conn_vect_size);                         {\cf20 // Allocate (inside heap) a new min path connections vector}\par
00558           ++realloc_flg;                                                                                    {\cf20 // And then upd realloc flag val to use reallocs instead of callocs 'till "free_graph()" funct call}\par
00559         \} {\cf19 else}                                                                                              {\cf20 // Else if realloc flag has already been set}\par
00560           reallocate_nd_conn_vect(&min_path_conn_vect, ++min_pth_conn_vect_size);                           {\cf20 // Reallocate (inside heap) the min path connections vector}\par
00561         tmpl = tmp_nd->archs_lst;                                                                           {\cf20 // Init tmp archs list ptr var}\par
00562         {\cf19 for} (; tmpl != NULL; tmpl = tmpl->nxt)\{                                                             {\cf20 // Scroll min-cost parh node connection archs list to find min-cost path connection arch}\par
00563           {\cf19 if} ((tmp_nd == tmpl->ar->nd1 && tmpl->ar->nd2 == tmp_nd->dd->prev_nd) ||\par
00564               (tmp_nd == tmpl->ar->nd2 && tmpl->ar->nd1 == tmp_nd->dd->prev_nd))\{                           {\cf20 // Min-cost path connection arch detectin' cond}\par
00565             (min_path_conn_vect+iaddr(V, min_pth_conn_vect_size-1, min_pth_conn_vect_size))->ar = tmpl->ar; {\cf20 // Save arch ptr val inside min path connections vector (min-path connection arch)}\par
00566           \}\par
00567         \}\par
00568         (min_path_conn_vect+iaddr(V, min_pth_conn_vect_size-1, min_pth_conn_vect_size))->nd = tmp_nd;       {\cf20 // Save node ptr val inside min path connections vector (min-path connection node)}\par
00569         tmp_nd = tmp_nd->dd->prev_nd;                                                                       {\cf20 // Upd tmp node var to reconstruct min-cost path backwards}\par
00570       \}\par
00571       {\cf20 // Swap elements to obtain shortest path (backward-to-forward path conversion)}\par
00572       Connection tmp_conn;                                                                                  {\cf20 // Tmp connection var to swap connections}\par
00573       {\cf19 for} ({\cf18 int} i = 0; i < min_pth_conn_vect_size/2; ++i)\{                                                   {\cf20 // Half min path connections vector scrollin' FOR cycle}\par
00574         tmp_conn = min_path_conn_vect[i];                                                                   {\cf20 // Define tmp var to swap connections}\par
00575         min_path_conn_vect[i] = min_path_conn_vect[min_pth_conn_vect_size-1-i];                             {\cf20 // Swap-step1}\par
00576         min_path_conn_vect[min_pth_conn_vect_size-i-1] = tmp_conn;                                          {\cf20 // Swap-step2}\par
00577       \}\par
00578       {\cf20 // Print shortest path from pre-defined source node to specified destination node}\par
00579       {\cf19 if} (v_mode == Y)                                                                                      {\cf20 // If verbose mode is enabled, print fbks}\par
00580         print_shortest_path();                                                                              {\cf20 // Print shortest path funct call}\par
00581       fbk_nl(1);  fbk_gn_cy({\cf22 "Destination node min cost path correctly identified!\\n"});                      {\cf20 // Print destination node min cost path correctly identified fbk}\par
00582     \} {\cf19 else}                                                                                                  {\cf20 // If error conditions ain't ok}\par
00583       fbk_err({\cf22 "Error, not able to find destination node min cost path with Dijkstra's algorithm"});          {\cf20 // Print error fbk}\par
00584   \} {\cf19 else}                                                                                                    {\cf20 // Else if Dijkstra's algorithm ain't been called}\par
00585     fbk_err({\cf22 "Error, min path can be reconstructed only after having called Dijkstra's algorithm!"});         {\cf20 // Print error fbk}\par
00586 \}\par
}
}
{\xe \v connect_node_arch\:lib_graph.h}
{\xe \v lib_graph.h\:connect_node_arch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void connect_node_arch ({\b C_str}  {\i ar_name}, {\b C_str}  {\i nd_name}, {\b Node_pos_in_arch}  {\i nd_pos}, {\b Arch_pos_typ}  {\i ar_pos},   {\i ...})}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 405 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00405                                                                                                        \{    {\cf20 // Function to connect arch-node in graph (new arch list element allocated inside heap, opt param --> arch pos in arches list, non-zero index)}\par
00406   {\cf20 /* Body */}\par
00407   fbk_nl(1);  fbk_gn_pu({\cf22 "Creating bidirectional connection between node and arch..."});                      {\cf20 // Creatin' bidirectional connection between node and arch}\par
00408   {\cf18 int} ar_num = idx_by_name(AR, ar_name);                                                                    {\cf20 // Get arch idx by-name}\par
00409   {\cf18 int} nd_num = idx_by_name(ND, nd_name);                                                                    {\cf20 // Get node idx by-name}\par
00410   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Working on node"}, nd_name);                                                {\cf20 // Print node name fbk}\par
00411   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Working on arch"}, ar_name);                                                {\cf20 // Print arch name fbk}\par
00412   {\cf18 int} lst_pos = 0;                                                                                          {\cf20 // List position in which arch must be placed in node conn. arches list}\par
00413   {\cf20 // Function optional parameters management}\par
00414   {\cf19 if} (ar_pos == LIST_POS)\{                                                                                  {\cf20 // If selected arch position type in list is specific position, read list position optional parameter}\par
00415     va_list args_lst;                                                                                       {\cf20 // Function optional parameters list int}\par
00416     va_start(args_lst, ar_pos);                                                                             {\cf20 // Define optional params list startin' point}\par
00417     lst_pos = va_arg(args_lst, {\cf18 int});                                                                        {\cf20 // Read the first optional parameter in funct opt params list (= define list position)}\par
00418   \}\par
00419   {\cf19 if} (nd_num >= 0 && ar_num >= 0 && ((ar_pos == LIST_POS && lst_pos >= 1) || ar_pos != LIST_POS))\{          {\cf20 // Check error conditions ok}\par
00420     {\cf20 // Assign node to arch}\par
00421     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Connecting node to"}, node_pos_in_arch_str[nd_pos]);                      {\cf20 // Connectin' node to arch fbk}\par
00422     {\cf19 switch} (nd_pos)\{                                                                                        {\cf20 // Node assignin' position in arch switch-case (where to assign node in arch)}\par
00423       {\cf19 case} ARCH_ND1:                                                                                        {\cf20 // Case: assign node to arch node1 position}\par
00424         archs_collect_vect[ar_num].nd1 = &nodes_collect_vect[nd_num];                                       {\cf20 // Assign node to arch node1 pos}\par
00425         {\cf19 break};\par
00427       {\cf19 case} ARCH_ND2:                                                                                        {\cf20 // Case: assign node to arch node2 position}\par
00428         archs_collect_vect[ar_num].nd2 = &nodes_collect_vect[nd_num];                                       {\cf20 // Assign node to arch node2 pos}\par
00429         {\cf19 break};\par
00431       {\cf19 default}:                                                                                              {\cf20 // Unknown case}\par
00432         fbk_err({\cf22 "Error, bad parameter value! A function got an unexpected patameter value"});                {\cf20 // Print error fbk}\par
00433         perror({\cf22 "Wrong \\"nd_pos\\" parameter value passsed to \\"connect_node_arch\\" function!"});              {\cf20 // Print perror fbk}\par
00434         {\cf19 break};\par
00435     \}\par
00436     {\cf20 // Assign arch to node}\par
00437     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Connecting arch to node connection archs"}, arch_pos_typ_str[ar_pos]);    {\cf20 // Connectin' node to arch fbk}\par
00438     List_elem* tmp_el = allocate_new_list_elems(1);                                                         {\cf20 // Tmp list element ptr creation}\par
00439     tmp_el->ar = &archs_collect_vect[ar_num];                                                               {\cf20 // Tmp list element ptr def with input arch memo cell addr}\par
00440     {\cf19 switch} (ar_pos)\{                                                                                        {\cf20 // Arch assignin' position type in node arches list switch-case (where to assign arch in node arches connections list) switch-case}\par
00441       {\cf19 case} LIST_HEAD:                                                                                       {\cf20 // Case: assign arch to node arches connections list (head position)}\par
00442         add_elem_at_list_head(&nodes_collect_vect[nd_num].archs_lst, tmp_el);                               {\cf20 // Assign arch (in tmp list element) to the specified node conn. arches list (head position)}\par
00443         {\cf19 break};\par
00445       {\cf19 case} LIST_POS:                                                                                        {\cf20 // Case: assign arch to node arches connections list (specific position, pos from optional funct param)}\par
00446         fbk_nl(1);  fbk_gn_lbu_ye_int({\cf22 "Specific list position number"}, lst_pos);                            {\cf20 // Specific list position num fbk}\par
00447         add_elem_at_list_pos(&nodes_collect_vect[nd_num].archs_lst, tmp_el, lst_pos);                       {\cf20 // Assign arch (in tmp list element) to the specified node conn. arches list (specific position, non-zero index)}\par
00448         {\cf19 break};\par
00450       {\cf19 case} LIST_TAIL:                                                                                       {\cf20 // Case: assign arch to node arches connections list (tail position)}\par
00451         add_elem_at_list_tail(&nodes_collect_vect[nd_num].archs_lst, tmp_el);                               {\cf20 // Assign arch (in tmp list element) to the specified node conn. arches list (tail position)}\par
00452         {\cf19 break};\par
00454       {\cf19 default}:                                                                                              {\cf20 // Unknown case}\par
00455         fbk_err({\cf22 "Error, bad parameter value! A function got an unexpected patameter value"});                {\cf20 // Print error fbk}\par
00456         perror({\cf22 "Wrong \\"ar_pos\\" parameter value passsed to \\"connect_node_arch\\" function!"});              {\cf20 // Print perror fbk}\par
00457         {\cf19 break};\par
00458     \}\par
00459     fbk_nl(1);  fbk_gn_cy({\cf22 "Bidirectional node-arch connetion correctly created!\\n"});                        {\cf20 // Bidirectional node-arch connection correctly created fbk}\par
00460   \} {\cf19 else} \{                                                                                                  {\cf20 // If error conditions ain't ok}\par
00461     fbk_err({\cf22 "Error, not able to create arch-node connection! Connection not created"});                      {\cf20 // Print error fbk}\par
00462     {\cf19 if} (ar_pos == LIST_POS && lst_pos < 1)                                                                  {\cf20 // List pos err detect cond}\par
00463       fbk_err({\cf22 "Error casued by specific list position flag enabled and invalid position value"});            {\cf20 // Print error fbk}\par
00464   \}\par
00465 \}\par
}
}
{\xe \v dijkstra_alg\:lib_graph.h}
{\xe \v lib_graph.h\:dijkstra_alg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dijkstra_alg ({\b C_str}  {\i src_nd_name}, {\b Verbose_mode}  {\i v_mode})}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 468 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00468                                                          \{                                                  {\cf20 // Dijkstra's alg to find min graph-path btwn source and each destination node (Dijkstra-dataset vect allocated/reallocated inside heap) - Y/N for verbose mode}\par
00469   {\cf20 /* Body */}\par
00470   fbk_nl(1);  fbk_gn_pu({\cf22 "Looking for min path costs from specified source with Dijkstra's algorithm..."});   {\cf20 // Print lookin' 4 shortest path btwn spec src and each dest nd fbk}\par
00471   {\cf18 int} src_nd_num = idx_by_name(ND, src_nd_name);                                                            {\cf20 // Get source node idx by-name}\par
00472   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Source node name"}, src_nd_name);                                           {\cf20 // Print source node name}\par
00473   {\cf19 if} (src_nd_num >= 0)\{                                                                                     {\cf20 // Check error conditions ok}\par
00474     {\cf20 // Algorithm inits}\par
00475     {\cf18 int} min_cost_idx = 0;                                                                                   {\cf20 // Min cost node idx in dataset var init}\par
00476     Real min_cost_val = 0.0;                                                                                {\cf20 // Min cost node val in dataset var init}\par
00477     {\cf18 int} nan_nd_conn_vect_size = 0;                                                                          {\cf20 // Node (non-analyzed) connections vector size var to store selected node non-analyzed connections init}\par
00478     Real new_cost = 0.0;                                                                                    {\cf20 // New cost var init}\par
00479     Connection* nan_nd_conn_vect = NULL;                                                                    {\cf20 // Node (non-analyzed) connections vector ptr var decl}\par
00480     {\cf19 if} (realloc_flg == 0)\{                                                                                  {\cf20 // If realloc flag ain't set}\par
00481       allocate_new_dijk_dataset_vect();                                                                     {\cf20 // Dijkstra-dataset vect init (vector allocated inside heap)}\par
00482       ++realloc_flg;                                                                                        {\cf20 // Set realloc flg}\par
00483     \} {\cf19 else}                                                                                                  {\cf20 // Else if realloc flag has been set}\par
00484       reallocate_dijk_dataset_vect();                                                                       {\cf20 // Dijkstra-dataset vect realloc (vector reallocated inside heap)}\par
00485     {\cf19 for} ({\cf18 int} i = 0; i < nds_collect_size; ++i)\{                                                             {\cf20 // Inits FOR cycle}\par
00486       nodes_collect_vect[i].dd = &dijk_dataset_vect[i];                                                     {\cf20 // Define and init nodes Dijkstra-datasets}\par
00487       nodes_collect_vect[i].dd->prev_nd = NULL;                                                             {\cf20 // Node dataset prev node init}\par
00488       nodes_collect_vect[i].dd->an_flg = 0;                                                                 {\cf20 // Node dataset analyzed flag val preset (as not analyzed)}\par
00489       {\cf19 if} (i != src_nd_num)                                                                                  {\cf20 // If node is different from source node}\par
00490         nodes_collect_vect[i].dd->min_path_cost = _REAL_MAX_;                                               {\cf20 // Init unknown min costs from source node (preset val --> +inf)}\par
00491       {\cf19 else}                                                                                                  {\cf20 // Else if node ain't different from source node}\par
00492         nodes_collect_vect[i].dd->min_path_cost = 0;                                                        {\cf20 // Init source-to-source cost (preset val --> zero)}\par
00493     \}\par
00494     src_node_idx = src_nd_num;                                                                              {\cf20 // Set/upd source node idx lib-var val}\par
00495     {\cf20 // Algorithm loop}\par
00496     {\cf19 for} ({\cf18 int} j = 0; j < nds_collect_size-1; ++j)\{                                                           {\cf20 // Main algo loop}\par
00497       {\cf20 // Select node with min-cost path}\par
00498       min_cost_val = _REAL_MAX_;                                                                            {\cf20 // Min cost node val in dataset upd}\par
00499       {\cf19 for} ({\cf18 int} k = 0; k < nds_collect_size; ++k)\{                                                           {\cf20 // Scroll the entire nodes collection 2 detect min cost path node}\par
00500         {\cf19 if} (nodes_collect_vect[k].dd->an_flg == 0 &&\par
00501             nodes_collect_vect[k].dd->min_path_cost < min_cost_val)\{                                        {\cf20 // Min cost path node detectin' cond (min val and node not alredy analized)}\par
00502           min_cost_val = nodes_collect_vect[k].dd->min_path_cost;                                           {\cf20 // If detectin' cond is met, upd min cost node val}\par
00503           min_cost_idx = k;                                                                                 {\cf20 // And upd min cost node idx}\par
00504         \}\par
00505       \}\par
00506       ++nodes_collect_vect[min_cost_idx].dd->an_flg;                                                        {\cf20 // Mark selected node as alredy analized b4 processin' it}\par
00507       {\cf20 // Find non-analyzed connections of selected node}\par
00508       nan_nd_conn_vect_size = 0;                                                                            {\cf20 // Node (non-analyzed) connections vector size var to store selected node non-analyzed connections (rst)}\par
00509       nan_nd_conn_vect = not_an_node_conn(&nodes_collect_vect[min_cost_idx], &nan_nd_conn_vect_size);       {\cf20 // Define selected node non-analyzed connections vect (vector allocated inside heap)}\par
00510       {\cf19 for} ({\cf18 int} l = 0; l < nan_nd_conn_vect_size; ++l)\{                                                      {\cf20 // Scroll selected node non-analyzed connections vect}\par
00511         new_cost = nodes_collect_vect[min_cost_idx].dd->min_path_cost+nan_nd_conn_vect[l].ar->cost;         {\cf20 // New cost val upd}\par
00512         {\cf20 // Upd min path cost and previous node in shortest path}\par
00513         {\cf19 if} (new_cost < nan_nd_conn_vect[l].nd->dd->min_path_cost)\{                                          {\cf20 // In case new cost val is less than min cost val}\par
00514           nan_nd_conn_vect[l].nd->dd->min_path_cost = new_cost;                                             {\cf20 // Upd min cost val}\par
00515           nan_nd_conn_vect[l].nd->dd->prev_nd = &nodes_collect_vect[min_cost_idx];                          {\cf20 // Upd previous min path node}\par
00516         \}\par
00517       \}\par
00518       {\cf19 if} (nan_nd_conn_vect != NULL)                                                                         {\cf20 // If node non-analyzed connections vector was correctly defined}\par
00519         free(nan_nd_conn_vect);                                                                             {\cf20 // Free node non-analyzed connections vector allocated inside heap}\par
00520     \}\par
00521     {\cf20 // Print each min path cost to reach every single accessible node from specified source-node}\par
00522     {\cf19 if} (v_mode == Y)                                                                                        {\cf20 // If verbose mode is enabled, print fbks}\par
00523       print_min_paths();                                                                                    {\cf20 // Print min paths funct call}\par
00524     fbk_nl(1);  fbk_gn_cy({\cf22 "Min path costs correctly found!\\n"});                                             {\cf20 // Print min path costs correctly found fbk}\par
00525   \} {\cf19 else}                                                                                                    {\cf20 // If error conditions ain't ok}\par
00526     fbk_err({\cf22 "Error, not able to find min path costs with Dijkstra's algorithm"});                            {\cf20 // Print error fbk}\par
00527 \}\par
}
}
{\xe \v free_graph\:lib_graph.h}
{\xe \v lib_graph.h\:free_graph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void free_graph ()}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 589 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00589                  \{                                                                                          {\cf20 // Function to free graph allocated memory inside heap}\par
00590   {\cf20 /* Body */}\par
00591   fbk_nl(1);  fbk_gn_pu({\cf22 "Clearing the whole graph structure..."});                                           {\cf20 // Clearing the whole graph from heap fbk}\par
00592   {\cf19 for} ({\cf18 int} i = 0; i < nds_collect_size; ++i)                                                                {\cf20 // Graph nodes scrollin' FOR cycle}\par
00593     {\cf19 if} (nodes_collect_vect[i].archs_lst != NULL)\{                                                           {\cf20 // If node arches list ain't null}\par
00594       free_list_elems(&nodes_collect_vect[i].archs_lst, N);                                                 {\cf20 // Free graph arches list elems associated to each graph node - NO --> without verbose mode}\par
00595       nodes_collect_vect[i].archs_lst = NULL;                                                               {\cf20 // Set node arches list to null}\par
00596     \}\par
00597   {\cf19 if} (archs_collect_vect != NULL)\{                                                                          {\cf20 // If arches collection vector needs to be cleared from heap}\par
00598     free(archs_collect_vect);                                                                               {\cf20 // Free arches collection vector allocated memo inside heap}\par
00599     archs_collect_vect = NULL;                                                                              {\cf20 // Set arches collection vector to null}\par
00600   \}\par
00601   {\cf19 if} (nodes_collect_vect != NULL)\{                                                                          {\cf20 // If nodes collection vector needs to be cleared from heap}\par
00602     free(nodes_collect_vect);                                                                               {\cf20 // Free nodes collection vector allocated memo inside heap}\par
00603     nodes_collect_vect = NULL;                                                                              {\cf20 // Set nodes collection vector to null}\par
00604   \}\par
00605   {\cf19 if} (dijk_dataset_vect != NULL)\{                                                                           {\cf20 // If Dijkstra-dataset vector needs to be cleared from heap}\par
00606     free(dijk_dataset_vect);                                                                                {\cf20 // Free Dijkstra-dataset vector allocated memo inside heap}\par
00607     dijk_dataset_vect = NULL;                                                                               {\cf20 // Set Dijkstra-dataset vector to null}\par
00608   \}\par
00609   {\cf19 if} (min_path_conn_vect != NULL)\{                                                                          {\cf20 // If min path connections vector needs to be cleared from heap}\par
00610     free(min_path_conn_vect);                                                                               {\cf20 // Free min path connections vector allocated memo inside heap}\par
00611     min_path_conn_vect = NULL;                                                                              {\cf20 // Set min path connections vector to null}\par
00612   \}\par
00613   ars_collect_size = 0;                                                                                     {\cf20 // Set graph arches number back to zero}\par
00614   nds_collect_size = 0;                                                                                     {\cf20 // Set graph nodes number back to zero}\par
00615   min_pth_conn_vect_size = 0;                                                                               {\cf20 // Set min path connections vector size back to zero}\par
00616   realloc_flg = 0;                                                                                          {\cf20 // Realloc flag rst}\par
00617   fbk_nl(1);  fbk_gn_cy({\cf22 "Graph structure correctly erased!\\n"});                                             {\cf20 // Graph structure correctly created erased from heap fbk}\par
00618 \}\par
}
}
{\xe \v idx_by_name\:lib_graph.h}
{\xe \v lib_graph.h\:idx_by_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int idx_by_name ({\b Obj_type}  {\i object_type}, {\b C_str}  {\i object_name})}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 324 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00324                                                         \{                                                   {\cf20 // Function to get object (arch/node) vector index by name (-1 = No match found / -2 = Error)}\par
00325   {\cf20 /* Body */}\par
00326   {\cf18 int} match_found = -1;                                                                                     {\cf20 // Match found idx (-1 = No match found / -2 = Error)}\par
00327   {\cf19 switch} (object_type)\{                                                                                     {\cf20 // Object type switch-case}\par
00328     {\cf19 case} AR:                                                                                                {\cf20 // Object type = arch}\par
00329       {\cf19 for} ({\cf18 int} i = 0; i < ars_collect_size; ++i)                                                            {\cf20 // Search match by-name in arches collection vector}\par
00330         {\cf19 if} (strcmp(object_name, archs_collect_vect[i].name) == 0)                                           {\cf20 // Match detecting condition}\par
00331           match_found = i;                                                                                  {\cf20 // Retun match idx in vect}\par
00332       {\cf19 break};\par
00334     {\cf19 case} ND:                                                                                                {\cf20 // Object type = node}\par
00335       {\cf19 for} ({\cf18 int} j = 0; j < nds_collect_size; ++j)                                                            {\cf20 // Search match by-name in nodes collection vector}\par
00336         {\cf19 if} (strcmp(object_name, nodes_collect_vect[j].name) == 0)                                           {\cf20 // Match detecting condition}\par
00337           match_found = j;                                                                                  {\cf20 // Retun match idx in vect}\par
00338       {\cf19 break};\par
00340     {\cf19 default}:                                                                                                {\cf20 // Unknown object type}\par
00341       fbk_err({\cf22 "Error, bad parameter value! A function got an unexpected patameter value"});                  {\cf20 // Print error fbk}\par
00342       perror({\cf22 "Wrong \\"object_type\\" parameter value passsed to \\"idx_by_name\\" function!"});                 {\cf20 // Print perror fbk}\par
00343       --match_found;                                                                                        {\cf20 // Decrease match found val to indicate error}\par
00344       {\cf19 break};\par
00345   \}\par
00346   {\cf19 if} (match_found == -1)                                                                                    {\cf20 // No march found cond}\par
00347     fbk_err({\cf22 "Error, no match found! Specified name probably wrong or not present in collection"});           {\cf20 // Print err fbk}\par
00348   {\cf19 return} match_found;                                                                                       {\cf20 // Return val}\par
00349 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v _REAL_MAX\:lib_graph.h}
{\xe \v lib_graph.h\:_REAL_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Real} _REAL_MAX}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v arch_pos_typ_str\:lib_graph.h}
{\xe \v lib_graph.h\:arch_pos_typ_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b C_str} arch_pos_typ_str[] = \{"LIST HEAD POSITION", "LIST SPECIFIC POSITION", "LIST TAIL POSITION"\}}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 93 of file lib_graph.h.}\par
}
{\xe \v archs_collect_vect\:lib_graph.h}
{\xe \v lib_graph.h\:archs_collect_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Arch}* archs_collect_vect}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file lib_graph.c.}\par
}
{\xe \v ars_collect_size\:lib_graph.h}
{\xe \v lib_graph.h\:ars_collect_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ars_collect_size}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file lib_graph.c.}\par
}
{\xe \v min_path_conn_vect\:lib_graph.h}
{\xe \v lib_graph.h\:min_path_conn_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Connection}* min_path_conn_vect}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file lib_graph.c.}\par
}
{\xe \v min_pth_conn_vect_size\:lib_graph.h}
{\xe \v lib_graph.h\:min_pth_conn_vect_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int min_pth_conn_vect_size}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 98 of file lib_graph.h.}\par
}
{\xe \v nds_collect_size\:lib_graph.h}
{\xe \v lib_graph.h\:nds_collect_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int nds_collect_size}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 98 of file lib_graph.h.}\par
}
{\xe \v node_pos_in_arch_str\:lib_graph.h}
{\xe \v lib_graph.h\:node_pos_in_arch_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b C_str} node_pos_in_arch_str[] = \{"ARCH NODE1 POSITION", "ARCH NODE2 POSITION"\}}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 90 of file lib_graph.h.}\par
}
{\xe \v nodes_collect_vect\:lib_graph.h}
{\xe \v lib_graph.h\:nodes_collect_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Node}* nodes_collect_vect}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file lib_graph.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/graph/lib_graph.so File Reference\par \pard\plain 
{\tc\tcl2 \v lib/graph/lib_graph.so}
{\xe \v lib/graph/lib_graph.so}
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/timer/lib_timer.c File Reference\par \pard\plain 
{\tc\tcl2 \v lib/timer/lib_timer.c}
{\xe \v lib/timer/lib_timer.c}
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "lib_timer.h"}\par
{\f2 #include "../ui/lib_ui.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b val_in_rage} ({\b C_int} val_min, {\b C_int} val, {\b C_int} val_max)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b delay} (const long time_ms)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Date_time} {\b get_date_time} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Date_time} {\b assign_date_time} ({\b C_int} yyyy, {\b C_int} mn, {\b C_int} dd, {\b C_int} hh, {\b C_int} mm, {\b C_int} ss)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Cmp_res} {\b cmp_date_time} ({\b Date_time} *const date1, const {\b Date_cmp} cmp_typ, {\b Date_time} *const date2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Cmp_res} {\b chk_date_in_range} (const {\b Date_time} date)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_date_time} (const char *const prfx_str_lbu, const {\b Date_time} *const date)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v assign_date_time\:lib_timer.c}
{\xe \v lib_timer.c\:assign_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Date_time} assign_date_time ({\b C_int}  {\i yyyy}, {\b C_int}  {\i mn}, {\b C_int}  {\i dd}, {\b C_int}  {\i hh}, {\b C_int}  {\i mm}, {\b C_int}  {\i ss})}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00052                                                                                         \{                   {\cf20 // Assign date/time function}\par
00053   {\cf20 /* Body */}\par
00054   Date_time tmp_date_time;                                                                                  {\cf20 // Temporary date/time var to return}\par
00055   tmp_date_time.yyyy = yyyy;                                                                                {\cf20 // Save years var}\par
00056   tmp_date_time.mn = mn;                                                                                    {\cf20 // Save months var}\par
00057   tmp_date_time.dd = dd;                                                                                    {\cf20 // Save days var}\par
00058   tmp_date_time.hh = hh+1;                                                                                  {\cf20 // Save hours var (+1)}\par
00059   tmp_date_time.mm = mm+1;                                                                                  {\cf20 // Save minutes var (+1)}\par
00060   tmp_date_time.ss = ss+1;                                                                                  {\cf20 // Save seconds var (+1)}\par
00061   {\cf19 if} (chk_date_in_range(tmp_date_time) == NOT_OK)\{                                                          {\cf20 // Check date/time consistency (case NOT-OK)}\par
00062     tmp_date_time.yyyy = 0;                                                                                 {\cf20 // Set years var to ZERO}\par
00063     tmp_date_time.mn = 0;                                                                                   {\cf20 // Set months var to ZERO}\par
00064     tmp_date_time.dd = 0;                                                                                   {\cf20 // Set days var to ZERO}\par
00065     tmp_date_time.hh = 0;                                                                                   {\cf20 // Set hours var to ZERO}\par
00066     tmp_date_time.mm = 0;                                                                                   {\cf20 // Set minutes var to ZERO}\par
00067     tmp_date_time.ss = 0;                                                                                   {\cf20 // Set seconds var to ZERO}\par
00068   \}\par
00069   {\cf19 return} tmp_date_time;                                                                                     {\cf20 // Return date/time var}\par
00070 \}\par
}
}
{\xe \v chk_date_in_range\:lib_timer.c}
{\xe \v lib_timer.c\:chk_date_in_range}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Cmp_res} chk_date_in_range (const {\b Date_time}  {\i date})}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 112 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00112                                                \{                                                            {\cf20 // Check date/time in range function}\par
00113   {\cf20 /* Body */}\par
00114   {\cf19 if} (val_in_rage(MIN_YY, date.yyyy, MAX_YY) && val_in_rage(MIN_MN, date.mn, MAX_MN) &&\par
00115       val_in_rage(MIN_DD, date.dd, MAX_DD) && val_in_rage(MIN_HH, date.hh, MAX_HH) &&\par
00116       val_in_rage(MIN_MM, date.mm, MAX_MM) && val_in_rage(MIN_SS, date.ss, MAX_SS))                         {\cf20 // If date/time is in range}\par
00117     {\cf19 return} OK;                                                                                              {\cf20 // Return OK}\par
00118   {\cf19 else}                                                                                                      {\cf20 // Else if date/time isn't in range}\par
00119     {\cf19 return} NOT_OK;                                                                                          {\cf20 // Return NOT-OK}\par
00120 \}\par
}
}
{\xe \v cmp_date_time\:lib_timer.c}
{\xe \v lib_timer.c\:cmp_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Cmp_res} cmp_date_time ({\b Date_time} *const  {\i date1}, const {\b Date_cmp}  {\i cmp_typ}, {\b Date_time} *const  {\i date2})}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00073                                                                                              \{              {\cf20 // Compare date/time function}\par
00074   {\cf20 /* Body */}\par
00075   {\cf18 int} *date1_val_ptr = &date1->yyyy, *date2_val_ptr = &date2->yyyy;                                         {\cf20 // Date/time ptrs vals}\par
00076   {\cf19 for} (Byte idx = 1; *date1_val_ptr == *date2_val_ptr && idx < 6; ++idx)\{                                   {\cf20 // Compare and redefine date1 and date2 ptr vals FOR cylce (cycle 'till years/months/days/hours/minutes/seconds are different)}\par
00077     {\cf19 switch} (idx)\{                                                                                           {\cf20 // Redefinition index switch-case}\par
00078       {\cf19 case} 1:                                                                                               {\cf20 // If years are equivalents, check months}\par
00079         date1_val_ptr = &date1->mn;                                                                         {\cf20 // Redefine date1 ptr val to date1 months}\par
00080         date2_val_ptr = &date2->mn;                                                                         {\cf20 // Redefine date2 ptr val to date2 months}\par
00081         {\cf19 break};\par
00083       {\cf19 case} 2:                                                                                               {\cf20 // If months are equivalents, check days}\par
00084         date1_val_ptr = &date1->dd;                                                                         {\cf20 // Redefine date1 ptr val to date1 days}\par
00085         date2_val_ptr = &date2->dd;                                                                         {\cf20 // Redefine date2 ptr val to date2 days}\par
00086         {\cf19 break};\par
00088       {\cf19 case} 3:                                                                                               {\cf20 // If days are equivalents, check hours}\par
00089         date1_val_ptr = &date1->hh;                                                                         {\cf20 // Redefine date1 ptr val to date1 hours}\par
00090         date2_val_ptr = &date2->hh;                                                                         {\cf20 // Redefine date2 ptr val to date2 hours}\par
00091         {\cf19 break};\par
00093       {\cf19 case} 4:                                                                                               {\cf20 // If hours are equivalents, check minutes}\par
00094         date1_val_ptr = &date1->mm;                                                                         {\cf20 // Redefine date1 ptr val to date1 minutes}\par
00095         date2_val_ptr = &date2->mm;                                                                         {\cf20 // Redefine date2 ptr val to date2 minutes}\par
00096         {\cf19 break};\par
00098       {\cf19 case} 5:                                                                                               {\cf20 // If minutes are equivalents, check seconds}\par
00099         date1_val_ptr = &date1->ss;                                                                         {\cf20 // Redefine date1 ptr val to date1 seconds}\par
00100         date2_val_ptr = &date2->ss;                                                                         {\cf20 // Redefine date2 ptr val to date2 seconds}\par
00101         {\cf19 break};        \par
00102     \}\par
00103   \}\par
00104   {\cf19 if} ((cmp_typ == OLDER && *date1_val_ptr < *date2_val_ptr) ||\par
00105       (cmp_typ == NEWER && *date1_val_ptr > *date2_val_ptr))                                                {\cf20 // Comparison conditions, if comparison is OK}\par
00106     {\cf19 return} OK;                                                                                              {\cf20 // Return compare OK}\par
00107   {\cf19 else}                                                                                                      {\cf20 // Else if comparison is NOT-OK}\par
00108     {\cf19 return} NOT_OK;                                                                                          {\cf20 // Return compare NOT-OK}\par
00109 \}\par
}
}
{\xe \v delay\:lib_timer.c}
{\xe \v lib_timer.c\:delay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void delay (const long  {\i time_ms})}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00026                               \{                                                                             {\cf20 // Delay [ms] function}\par
00027   {\cf20 /* Body */}\par
00028   {\cf19 if} (time_ms > 0)\{                                                                                         {\cf20 // Check ms-dly val}\par
00029     fflush(stdout);                                                                                         {\cf20 // Force pending terminal fbk prints}\par
00030     clock_t start_time = clock();                                                                           {\cf20 // Start time = software execution time}\par
00031     {\cf19 while} ((clock() - start_time) < (time_ms * (CLOCKS_PER_SEC / 1000)));                                   {\cf20 // Check if elapsed time [ms] (time - start_time) is greater or equal to pause time, pause time calculated considering the number of clocks per second}\par
00032   \} {\cf19 else}                                                                                                    {\cf20 // If ms-dly val ain't positive}\par
00033     perror({\cf22 "Error! Delay time must be greater than ZERO!"});                                                 {\cf20 // Print perror fbk}\par
00034 \}\par
}
}
{\xe \v fbk_gn_lbu_date_time\:lib_timer.c}
{\xe \v lib_timer.c\:fbk_gn_lbu_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_date_time (const char *const  {\i prfx_str_lbu}, const {\b Date_time} *const  {\i date})}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 123 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00123                                                                                       \{                     {\cf20 // Green-lightblue-yellow date/time val feedback function}\par
00124   {\cf20 /* Body */}\par
00125   printf({\cf22 "%s>>>%s %s: %s%d%c%d%c%d%c%d%c%d%c%d%s"},\par
00126           GN, LBU, prfx_str_lbu, YE, date->yyyy, DATE_DELIM_CHR, date->mn, DATE_DELIM_CHR, date->dd,\par
00127           DATE_TIME_DELIM_CHR, date->hh-1, TIME_DELIM_CHR, date->mm-1, TIME_DELIM_CHR, date->ss-1, ER);     {\cf20 // Print green-lightblue-yellow date/time val feedback}\par
00128 \}\par
}
}
{\xe \v get_date_time\:lib_timer.c}
{\xe \v lib_timer.c\:get_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Date_time} get_date_time ()}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00037                          \{                                                                                  {\cf20 // Get date/time function}\par
00038   {\cf20 /* Body */}\par
00039   Date_time tmp_date_time;                                                                                  {\cf20 // Temporary date/time var to return}\par
00040   time_t now = time(NULL);                                                                                  {\cf20 // Now timer}\par
00041   {\cf17 struct }tm tm = *localtime(&now);                                                                          {\cf20 // Get now date/time}\par
00042   tmp_date_time.yyyy = 1900+tm.tm_year;                                                                     {\cf20 // Save years var}\par
00043   tmp_date_time.mn = 1+tm.tm_mon;                                                                           {\cf20 // Save months var}\par
00044   tmp_date_time.dd = tm.tm_mday;                                                                            {\cf20 // Save days var}\par
00045   tmp_date_time.hh = tm.tm_hour+1;                                                                          {\cf20 // Save hours var (+1)}\par
00046   tmp_date_time.mm = tm.tm_min+1;                                                                           {\cf20 // Save minutes var (+1)}\par
00047   tmp_date_time.ss = tm.tm_sec+1;                                                                           {\cf20 // Save seconds var (+1)}\par
00048   {\cf19 return} tmp_date_time;                                                                                     {\cf20 // Return date/time}\par
00049 \}\par
}
}
{\xe \v val_in_rage\:lib_timer.c}
{\xe \v lib_timer.c\:val_in_rage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int val_in_rage ({\b C_int}  {\i val_min}, {\b C_int}  {\i val}, {\b C_int}  {\i val_max}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00016                                                                \{                                            {\cf20 // Function to check val in range}\par
00017   {\cf20 /* Body */}\par
00018   {\cf19 if} (val >= val_min && val <= val_max)                                                                     {\cf20 // If val is in range}\par
00019     {\cf19 return} 1;                                                                                               {\cf20 // Return 1}\par
00020   {\cf19 else}                                                                                                      {\cf20 // Else if val isn't in range}\par
00021     {\cf19 return} 0;                                                                                               {\cf20 // Return 0}\par
00022 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/timer/lib_timer.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/timer/lib_timer.h}
{\xe \v lib/timer/lib_timer.h}
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <time.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b date_time}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DATE_TIME_STR_LEN}\~ 20\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DATE_DELIM_CHR}\~ '/'\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DATE_TIME_DELIM_CHR}\~ ' '\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TIME_DELIM_CHR}\~ ':'\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_YY}\~ 2025\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MIN_YY}\~ 2015\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_MN}\~ 12\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MIN_MN}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_DD}\~ 31\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MIN_DD}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_HH}\~ 24\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MIN_HH}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_MM}\~ 60\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MIN_MM}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_SS}\~ 60\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MIN_SS}\~ 1\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b date_time} {\b Date_time}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b date_cmp} {\b Date_cmp}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b cmp_res} {\b Cmp_res}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b date_cmp} \{ {\b OLDER}, 
{\b NEWER}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b cmp_res} \{ {\b OK}, 
{\b NOT_OK}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b delay} (const long time_ms)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Date_time} {\b get_date_time} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Date_time} {\b assign_date_time} (const int yyyy, const int mn, const int dd, const int hh, const int mm, const int ss)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Cmp_res} {\b cmp_date_time} ({\b Date_time} *const date1, const {\b Date_cmp} cmp_typ, {\b Date_time} *const date2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Cmp_res} {\b chk_date_in_range} (const {\b Date_time} date)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_date_time} (const char *const prfx_str_lbu, const {\b Date_time} *const date)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DATE_DELIM_CHR\:lib_timer.h}
{\xe \v lib_timer.h\:DATE_DELIM_CHR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DATE_DELIM_CHR\~ '/'}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file lib_timer.h.}\par
}
{\xe \v DATE_TIME_DELIM_CHR\:lib_timer.h}
{\xe \v lib_timer.h\:DATE_TIME_DELIM_CHR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DATE_TIME_DELIM_CHR\~ ' '}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file lib_timer.h.}\par
}
{\xe \v DATE_TIME_STR_LEN\:lib_timer.h}
{\xe \v lib_timer.h\:DATE_TIME_STR_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DATE_TIME_STR_LEN\~ 20}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file lib_timer.h.}\par
}
{\xe \v MAX_DD\:lib_timer.h}
{\xe \v lib_timer.h\:MAX_DD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_DD\~ 31}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 23 of file lib_timer.h.}\par
}
{\xe \v MAX_HH\:lib_timer.h}
{\xe \v lib_timer.h\:MAX_HH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_HH\~ 24}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 25 of file lib_timer.h.}\par
}
{\xe \v MAX_MM\:lib_timer.h}
{\xe \v lib_timer.h\:MAX_MM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_MM\~ 60}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 27 of file lib_timer.h.}\par
}
{\xe \v MAX_MN\:lib_timer.h}
{\xe \v lib_timer.h\:MAX_MN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_MN\~ 12}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 21 of file lib_timer.h.}\par
}
{\xe \v MAX_SS\:lib_timer.h}
{\xe \v lib_timer.h\:MAX_SS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_SS\~ 60}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 29 of file lib_timer.h.}\par
}
{\xe \v MAX_YY\:lib_timer.h}
{\xe \v lib_timer.h\:MAX_YY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_YY\~ 2025}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file lib_timer.h.}\par
}
{\xe \v MIN_DD\:lib_timer.h}
{\xe \v lib_timer.h\:MIN_DD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MIN_DD\~ 1}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 24 of file lib_timer.h.}\par
}
{\xe \v MIN_HH\:lib_timer.h}
{\xe \v lib_timer.h\:MIN_HH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MIN_HH\~ 1}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file lib_timer.h.}\par
}
{\xe \v MIN_MM\:lib_timer.h}
{\xe \v lib_timer.h\:MIN_MM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MIN_MM\~ 1}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file lib_timer.h.}\par
}
{\xe \v MIN_MN\:lib_timer.h}
{\xe \v lib_timer.h\:MIN_MN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MIN_MN\~ 1}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 22 of file lib_timer.h.}\par
}
{\xe \v MIN_SS\:lib_timer.h}
{\xe \v lib_timer.h\:MIN_SS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MIN_SS\~ 1}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 30 of file lib_timer.h.}\par
}
{\xe \v MIN_YY\:lib_timer.h}
{\xe \v lib_timer.h\:MIN_YY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MIN_YY\~ 2015}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file lib_timer.h.}\par
}
{\xe \v TIME_DELIM_CHR\:lib_timer.h}
{\xe \v lib_timer.h\:TIME_DELIM_CHR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TIME_DELIM_CHR\~ ':'}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file lib_timer.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v Cmp_res\:lib_timer.h}
{\xe \v lib_timer.h\:Cmp_res}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b cmp_res} {\b Cmp_res}}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Date_cmp\:lib_timer.h}
{\xe \v lib_timer.h\:Date_cmp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b date_cmp} {\b Date_cmp}}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Date_time\:lib_timer.h}
{\xe \v lib_timer.h\:Date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b date_time} {\b Date_time}}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v cmp_res\:lib_timer.h}
{\xe \v lib_timer.h\:cmp_res}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b cmp_res}}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v OK\:lib_timer.h}
{\xe \v lib_timer.h\:OK}
{\qr OK{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
\cell }{\cell }{\row }
{\xe \v NOT_OK\:lib_timer.h}
{\xe \v lib_timer.h\:NOT_OK}
{\qr NOT_OK{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
\cell }{\cell }{\row }
}
\par
{
Definition at line 45 of file lib_timer.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00045 \{OK, NOT_OK\} Cmp_res;                                                                   {\cf20 // Date/time compare result enum}\par
}
}
{\xe \v date_cmp\:lib_timer.h}
{\xe \v lib_timer.h\:date_cmp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b date_cmp}}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v OLDER\:lib_timer.h}
{\xe \v lib_timer.h\:OLDER}
{\qr OLDER{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
\cell }{\cell }{\row }
{\xe \v NEWER\:lib_timer.h}
{\xe \v lib_timer.h\:NEWER}
{\qr NEWER{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
\cell }{\cell }{\row }
}
\par
{
Definition at line 43 of file lib_timer.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00043 \{OLDER, NEWER\} Date_cmp;                                                              {\cf20 // Date/time compare enum}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v assign_date_time\:lib_timer.h}
{\xe \v lib_timer.h\:assign_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Date_time} assign_date_time (const int  {\i yyyy}, const int  {\i mn}, const int  {\i dd}, const int  {\i hh}, const int  {\i mm}, const int  {\i ss})}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v chk_date_in_range\:lib_timer.h}
{\xe \v lib_timer.h\:chk_date_in_range}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Cmp_res} chk_date_in_range (const {\b Date_time}  {\i date})}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 112 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00112                                                \{                                                            {\cf20 // Check date/time in range function}\par
00113   {\cf20 /* Body */}\par
00114   {\cf19 if} (val_in_rage(MIN_YY, date.yyyy, MAX_YY) && val_in_rage(MIN_MN, date.mn, MAX_MN) &&\par
00115       val_in_rage(MIN_DD, date.dd, MAX_DD) && val_in_rage(MIN_HH, date.hh, MAX_HH) &&\par
00116       val_in_rage(MIN_MM, date.mm, MAX_MM) && val_in_rage(MIN_SS, date.ss, MAX_SS))                         {\cf20 // If date/time is in range}\par
00117     {\cf19 return} OK;                                                                                              {\cf20 // Return OK}\par
00118   {\cf19 else}                                                                                                      {\cf20 // Else if date/time isn't in range}\par
00119     {\cf19 return} NOT_OK;                                                                                          {\cf20 // Return NOT-OK}\par
00120 \}\par
}
}
{\xe \v cmp_date_time\:lib_timer.h}
{\xe \v lib_timer.h\:cmp_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Cmp_res} cmp_date_time ({\b Date_time} *const  {\i date1}, const {\b Date_cmp}  {\i cmp_typ}, {\b Date_time} *const  {\i date2})}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00073                                                                                              \{              {\cf20 // Compare date/time function}\par
00074   {\cf20 /* Body */}\par
00075   {\cf18 int} *date1_val_ptr = &date1->yyyy, *date2_val_ptr = &date2->yyyy;                                         {\cf20 // Date/time ptrs vals}\par
00076   {\cf19 for} (Byte idx = 1; *date1_val_ptr == *date2_val_ptr && idx < 6; ++idx)\{                                   {\cf20 // Compare and redefine date1 and date2 ptr vals FOR cylce (cycle 'till years/months/days/hours/minutes/seconds are different)}\par
00077     {\cf19 switch} (idx)\{                                                                                           {\cf20 // Redefinition index switch-case}\par
00078       {\cf19 case} 1:                                                                                               {\cf20 // If years are equivalents, check months}\par
00079         date1_val_ptr = &date1->mn;                                                                         {\cf20 // Redefine date1 ptr val to date1 months}\par
00080         date2_val_ptr = &date2->mn;                                                                         {\cf20 // Redefine date2 ptr val to date2 months}\par
00081         {\cf19 break};\par
00083       {\cf19 case} 2:                                                                                               {\cf20 // If months are equivalents, check days}\par
00084         date1_val_ptr = &date1->dd;                                                                         {\cf20 // Redefine date1 ptr val to date1 days}\par
00085         date2_val_ptr = &date2->dd;                                                                         {\cf20 // Redefine date2 ptr val to date2 days}\par
00086         {\cf19 break};\par
00088       {\cf19 case} 3:                                                                                               {\cf20 // If days are equivalents, check hours}\par
00089         date1_val_ptr = &date1->hh;                                                                         {\cf20 // Redefine date1 ptr val to date1 hours}\par
00090         date2_val_ptr = &date2->hh;                                                                         {\cf20 // Redefine date2 ptr val to date2 hours}\par
00091         {\cf19 break};\par
00093       {\cf19 case} 4:                                                                                               {\cf20 // If hours are equivalents, check minutes}\par
00094         date1_val_ptr = &date1->mm;                                                                         {\cf20 // Redefine date1 ptr val to date1 minutes}\par
00095         date2_val_ptr = &date2->mm;                                                                         {\cf20 // Redefine date2 ptr val to date2 minutes}\par
00096         {\cf19 break};\par
00098       {\cf19 case} 5:                                                                                               {\cf20 // If minutes are equivalents, check seconds}\par
00099         date1_val_ptr = &date1->ss;                                                                         {\cf20 // Redefine date1 ptr val to date1 seconds}\par
00100         date2_val_ptr = &date2->ss;                                                                         {\cf20 // Redefine date2 ptr val to date2 seconds}\par
00101         {\cf19 break};        \par
00102     \}\par
00103   \}\par
00104   {\cf19 if} ((cmp_typ == OLDER && *date1_val_ptr < *date2_val_ptr) ||\par
00105       (cmp_typ == NEWER && *date1_val_ptr > *date2_val_ptr))                                                {\cf20 // Comparison conditions, if comparison is OK}\par
00106     {\cf19 return} OK;                                                                                              {\cf20 // Return compare OK}\par
00107   {\cf19 else}                                                                                                      {\cf20 // Else if comparison is NOT-OK}\par
00108     {\cf19 return} NOT_OK;                                                                                          {\cf20 // Return compare NOT-OK}\par
00109 \}\par
}
}
{\xe \v delay\:lib_timer.h}
{\xe \v lib_timer.h\:delay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void delay (const long  {\i time_ms})}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00026                               \{                                                                             {\cf20 // Delay [ms] function}\par
00027   {\cf20 /* Body */}\par
00028   {\cf19 if} (time_ms > 0)\{                                                                                         {\cf20 // Check ms-dly val}\par
00029     fflush(stdout);                                                                                         {\cf20 // Force pending terminal fbk prints}\par
00030     clock_t start_time = clock();                                                                           {\cf20 // Start time = software execution time}\par
00031     {\cf19 while} ((clock() - start_time) < (time_ms * (CLOCKS_PER_SEC / 1000)));                                   {\cf20 // Check if elapsed time [ms] (time - start_time) is greater or equal to pause time, pause time calculated considering the number of clocks per second}\par
00032   \} {\cf19 else}                                                                                                    {\cf20 // If ms-dly val ain't positive}\par
00033     perror({\cf22 "Error! Delay time must be greater than ZERO!"});                                                 {\cf20 // Print perror fbk}\par
00034 \}\par
}
}
{\xe \v fbk_gn_lbu_date_time\:lib_timer.h}
{\xe \v lib_timer.h\:fbk_gn_lbu_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_date_time (const char *const  {\i prfx_str_lbu}, const {\b Date_time} *const  {\i date})}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 123 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00123                                                                                       \{                     {\cf20 // Green-lightblue-yellow date/time val feedback function}\par
00124   {\cf20 /* Body */}\par
00125   printf({\cf22 "%s>>>%s %s: %s%d%c%d%c%d%c%d%c%d%c%d%s"},\par
00126           GN, LBU, prfx_str_lbu, YE, date->yyyy, DATE_DELIM_CHR, date->mn, DATE_DELIM_CHR, date->dd,\par
00127           DATE_TIME_DELIM_CHR, date->hh-1, TIME_DELIM_CHR, date->mm-1, TIME_DELIM_CHR, date->ss-1, ER);     {\cf20 // Print green-lightblue-yellow date/time val feedback}\par
00128 \}\par
}
}
{\xe \v get_date_time\:lib_timer.h}
{\xe \v lib_timer.h\:get_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Date_time} get_date_time ()}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00037                          \{                                                                                  {\cf20 // Get date/time function}\par
00038   {\cf20 /* Body */}\par
00039   Date_time tmp_date_time;                                                                                  {\cf20 // Temporary date/time var to return}\par
00040   time_t now = time(NULL);                                                                                  {\cf20 // Now timer}\par
00041   {\cf17 struct }tm tm = *localtime(&now);                                                                          {\cf20 // Get now date/time}\par
00042   tmp_date_time.yyyy = 1900+tm.tm_year;                                                                     {\cf20 // Save years var}\par
00043   tmp_date_time.mn = 1+tm.tm_mon;                                                                           {\cf20 // Save months var}\par
00044   tmp_date_time.dd = tm.tm_mday;                                                                            {\cf20 // Save days var}\par
00045   tmp_date_time.hh = tm.tm_hour+1;                                                                          {\cf20 // Save hours var (+1)}\par
00046   tmp_date_time.mm = tm.tm_min+1;                                                                           {\cf20 // Save minutes var (+1)}\par
00047   tmp_date_time.ss = tm.tm_sec+1;                                                                           {\cf20 // Save seconds var (+1)}\par
00048   {\cf19 return} tmp_date_time;                                                                                     {\cf20 // Return date/time}\par
00049 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/timer/lib_timer.so File Reference\par \pard\plain 
{\tc\tcl2 \v lib/timer/lib_timer.so}
{\xe \v lib/timer/lib_timer.so}
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/ui/lib_ui.c File Reference\par \pard\plain 
{\tc\tcl2 \v lib/ui/lib_ui.c}
{\xe \v lib/ui/lib_ui.c}
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "lib_ui.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b unused} {\b __attribute__} (({\b unused}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logo} ({\b Cu_shrt} start_sp, {\b C_str} txt, {\b C_str} txt_col, {\b C_char} bkg_chr, {\b C_str} bkg_col)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b press_enter} ({\b C_str} req_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_nl} ({\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_spaces} ({\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_tabs} ({\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_separator} ({\b C_char} chr, {\b C_str} col)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_cy} ({\b C_str} fbk_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_pu} ({\b C_str} fbk_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_int} ({\b C_str} prfx_str_lbu, {\b C_int} val_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_str} ({\b C_str} prfx_str_lbu, {\b C_str} str_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_real} ({\b C_str} prfx_str_lbu, {\b C_real} val_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_lreal} ({\b C_str} prfx_str_lbu, {\b Cl_real} val_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_ptr} ({\b C_str} prfx_str_lbu, {\b C_ptr} val_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_err} ({\b C_str} fbk_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Str} {\b read_term_in} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Str} {\b read_term_in_min_chrs} ({\b C_byte} min_chrs, {\b C_str} req_str, {\b C_str} err_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Confirm} {\b read_term_in_confirm} ({\b C_str} req_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Str} {\b read_term_in_min_chrs_exit_chr} ({\b C_byte} min_chrs, {\b C_str} req_str, {\b C_str} err_str, {\b C_char} exit_chr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b read_term_in_int} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b read_term_in_int_inrange} ({\b C_int} min_val, {\b C_int} max_val, {\b C_str} req_str, {\b C_str} err_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clr_term_in} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_print} ({\b C_str} str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_str} ({\b C_str} str, {\b C_str} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_int} ({\b C_str} str, {\b C_int} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_real} ({\b C_str} str, {\b C_real} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_lreal} ({\b C_str} str, {\b Cl_real} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_ptr} ({\b C_str} str, {\b C_ptr} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_err} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_fbk} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_keyboard_interrupt} ({\b C_int} signal)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b term_in_buff} [{\b IN_BUFF_SIZE}] = ""\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:lib_ui.c}
{\xe \v lib_ui.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b unused} __attribute__ (({\b unused}) )}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v close_err\:lib_ui.c}
{\xe \v lib_ui.c\:close_err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_err ()}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 313 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00313                 \{                                                                                           {\cf20 // Close software with error function}\par
00314   {\cf20 /* Body */}\par
00315   printf({\cf22 "\\n%s>>>%s Closin' due to error... %sSorry! %s:(%s\\n"}, OG, RD, CY, OG, ER);                        {\cf20 // Closin' due to error fbk}\par
00316   exit(EXIT_FAILURE);                                                                                       {\cf20 // Close software}\par
00317 \}\par
}
}
{\xe \v close_fbk\:lib_ui.c}
{\xe \v lib_ui.c\:close_fbk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_fbk ()}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 320 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00320                 \{                                                                                           {\cf20 // Function to close software with feedback}\par
00321   {\cf20 /* Body */}\par
00322   printf({\cf22 "\\n\\n%s>>>%s Closin'... %sBye! %s;)%s\\n"}, GN, PU, CY, RD, ER);                                     {\cf20 // Closin' fbk}\par
00323   exit(EXIT_SUCCESS);                                                                                       {\cf20 // Close software}\par
00324 \}\par
}
}
{\xe \v close_keyboard_interrupt\:lib_ui.c}
{\xe \v lib_ui.c\:close_keyboard_interrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_keyboard_interrupt ({\b C_int}  {\i signal})}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 327 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00327                                            \{                                                                {\cf20 // Function to close SW with fbk due to keyboard interrupt detected (ctrl+c)}\par
00328   {\cf20 /* Body */}\par
00329   printf({\cf22 "\\n\\n%s>>>%s Keyboard interrupt detected, closin'... %sBye! %s;)%s\\n"}, GN, PU, CY, RD, ER);        {\cf20 // Closin' fbk}\par
00330   exit(signal);                                                                                             {\cf20 // Exit SW with signal}\par
00331 \}\par
}
}
{\xe \v clr_term_in\:lib_ui.c}
{\xe \v lib_ui.c\:clr_term_in}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void clr_term_in ()}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 265 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00265                   \{                                                                                         {\cf20 // Clear terminal input buffer function}\par
00266   {\cf20 /* Body */}\par
00267   strcpy(term_in_buff, {\cf22 "\\0"});                                                                               {\cf20 // Clear input buffer char array}\par
00268 \}\par
}
}
{\xe \v dbg\:lib_ui.c}
{\xe \v lib_ui.c\:dbg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg ()}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 271 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00271           \{                                                                                                 {\cf20 // Fast debug function}\par
00272   {\cf20 /* Body */}\par
00273   printf({\cf22 "\\n\\n%s    >>>>>> %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, LGN, ER);                                   {\cf20 // Print debug line}\par
00274 \}\par
}
}
{\xe \v dbg_int\:lib_ui.c}
{\xe \v lib_ui.c\:dbg_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_int ({\b C_str}  {\i str}, {\b C_int}  {\i val})}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 289 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00289                                   \{                                                                         {\cf20 // Debug int val print function}\par
00290   {\cf20 /* Body */}\par
00291   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%d %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);      {\cf20 // Print debug line}\par
00292 \}\par
}
}
{\xe \v dbg_lreal\:lib_ui.c}
{\xe \v lib_ui.c\:dbg_lreal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_lreal ({\b C_str}  {\i str}, {\b Cl_real}  {\i val})}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 301 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00301                                       \{                                                                     {\cf20 // Debug long real val print function}\par
00302   {\cf20 /* Body */}\par
00303   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%Lg %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);     {\cf20 // Print debug line}\par
00304 \}\par
}
}
{\xe \v dbg_print\:lib_ui.c}
{\xe \v lib_ui.c\:dbg_print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_print ({\b C_str}  {\i str})}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 277 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00277                          \{                                                                                  {\cf20 // Debug print function}\par
00278   {\cf20 /* Body */}\par
00279   printf({\cf22 "\\n\\n%s    >>>>>>%s %s %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, LGN, ER);                     {\cf20 // Print debug line}\par
00280 \}\par
}
}
{\xe \v dbg_ptr\:lib_ui.c}
{\xe \v lib_ui.c\:dbg_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_ptr ({\b C_str}  {\i str}, {\b C_ptr}  {\i val})}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 307 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00307                                   \{                                                                         {\cf20 // Debug ptr val print function}\par
00308   {\cf20 /* Body */}\par
00309   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%p %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);      {\cf20 // Print debug line}\par
00310 \}\par
}
}
{\xe \v dbg_real\:lib_ui.c}
{\xe \v lib_ui.c\:dbg_real}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_real ({\b C_str}  {\i str}, {\b C_real}  {\i val})}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 295 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00295                                     \{                                                                       {\cf20 // Debug real val print function}\par
00296   {\cf20 /* Body */}\par
00297   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%g %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);      {\cf20 // Print debug line}\par
00298 \}\par
}
}
{\xe \v dbg_str\:lib_ui.c}
{\xe \v lib_ui.c\:dbg_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_str ({\b C_str}  {\i str}, {\b C_str}  {\i val})}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 283 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00283                                   \{                                                                         {\cf20 // Debug string val print function}\par
00284   {\cf20 /* Body */}\par
00285   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%s %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);      {\cf20 // Print debug line}\par
00286 \}\par
}
}
{\xe \v fbk_err\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_err ({\b C_str}  {\i fbk_str})}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 151 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00151                            \{                                                                                {\cf20 // Error feedback function}\par
00152   {\cf20 /* Body */}\par
00153   printf({\cf22 "\\n%s>>>%s %s!%s\\n"}, OG, RD, fbk_str, ER);                                                         {\cf20 // Print error fbk}\par
00154 \}\par
}
}
{\xe \v fbk_gn_cy\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_gn_cy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_cy ({\b C_str}  {\i fbk_str})}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 109 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00109                              \{                                                                              {\cf20 // Green-cyan feedback function}\par
00110   {\cf20 /* Body */}\par
00111   printf({\cf22 "%s>>>%s %s%s"}, GN, CY, fbk_str, ER);                                                              {\cf20 // Print green-cyan string fbk}\par
00112 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_int\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_gn_lbu_ye_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_int ({\b C_str}  {\i prfx_str_lbu}, {\b C_int}  {\i val_ye})}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 121 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00121                                                         \{                                                   {\cf20 // Green-lightblue-yellow int val feedback function}\par
00122   {\cf20 /* Body */}\par
00123   printf({\cf22 "%s>>>%s %s: %s%d%s"}, GN, LBU, prfx_str_lbu, YE, val_ye, ER);                                      {\cf20 // Print green-lightblue-yellow int val feedback}\par
00124 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_lreal\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_gn_lbu_ye_lreal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_lreal ({\b C_str}  {\i prfx_str_lbu}, {\b Cl_real}  {\i val_ye})}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00139                                                             \{                                               {\cf20 // Green-lightblue-yellow long real val feedback function}\par
00140   {\cf20 /* Body */}\par
00141   printf({\cf22 "%s>>>%s %s: %s%Lg%s"}, GN, LBU, prfx_str_lbu, YE, val_ye, ER);                                     {\cf20 // Print green-lightblue-yellow long real val feedback}\par
00142 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_ptr\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_gn_lbu_ye_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_ptr ({\b C_str}  {\i prfx_str_lbu}, {\b C_ptr}  {\i val_ye})}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 145 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00145                                                         \{                                                   {\cf20 // Green-lightblue-yellow ptr val feedback function}\par
00146   {\cf20 /* Body */}\par
00147   printf({\cf22 "%s>>>%s %s: %s%p%s"}, GN, LBU, prfx_str_lbu, YE, val_ye, ER);                                      {\cf20 // Print green-lightblue-yellow ptr val feedback}\par
00148 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_real\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_gn_lbu_ye_real}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_real ({\b C_str}  {\i prfx_str_lbu}, {\b C_real}  {\i val_ye})}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 133 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00133                                                           \{                                                 {\cf20 // Green-lightblue-yellow real val feedback function}\par
00134   {\cf20 /* Body */}\par
00135   printf({\cf22 "%s>>>%s %s: %s%g%s"}, GN, LBU, prfx_str_lbu, YE, val_ye, ER);                                      {\cf20 // Print green-lightblue-yellow real val feedback}\par
00136 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_str\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_gn_lbu_ye_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_str ({\b C_str}  {\i prfx_str_lbu}, {\b C_str}  {\i str_ye})}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 127 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00127                                                         \{                                                   {\cf20 // Green-lightblue-yellow str val feedback function}\par
00128   {\cf20 /* Body */}\par
00129   printf({\cf22 "%s>>>%s %s: %s%s%s"}, GN, LBU, prfx_str_lbu, YE, str_ye, ER);                                      {\cf20 // Print green-lightblue-yellow str val feedback}\par
00130 \}\par
}
}
{\xe \v fbk_gn_pu\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_gn_pu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_pu ({\b C_str}  {\i fbk_str})}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 115 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00115                              \{                                                                              {\cf20 // Green-purple feedback function}\par
00116   {\cf20 /* Body */}\par
00117   printf({\cf22 "%s>>>%s %s%s"}, GN, PU, fbk_str, ER);                                                              {\cf20 // Print green-purple string fbk}\par
00118 \}\par
}
}
{\xe \v fbk_nl\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_nl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_nl ({\b C_int}  {\i num})}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00079                       \{                                                                                     {\cf20 // New lines feedback function}\par
00080   {\cf20 /* Body */}\par
00081   {\cf19 for} ({\cf18 int} i = 0; i < num; ++i)                                                                             {\cf20 // Chars printin' FOR cycle}\par
00082     printf({\cf22 "\\n"});                                                                                           {\cf20 // Print new line fbk}\par
00083 \}\par
}
}
{\xe \v fbk_separator\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_separator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_separator ({\b C_char}  {\i chr}, {\b C_str}  {\i col})}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 100 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00100                                          \{                                                                  {\cf20 // Separator feedback function}\par
00101   {\cf20 /* Body */}\par
00102   {\cf17 struct }winsize w;                                                                                         {\cf20 // Window-size struct declaration}\par
00103   ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);                                                                     {\cf20 // Save the number of terminal's rows/cloumns in window-size struct}\par
00104   {\cf19 for} ({\cf18 int} i = 0; i < w.ws_col; ++i)                                                                        {\cf20 // Chars printin' FOR cycle}\par
00105     printf({\cf22 "%s%c%s"}, col, chr, ER);                                                                         {\cf20 // Print space fbk}\par
00106 \}\par
}
}
{\xe \v fbk_spaces\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_spaces}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_spaces ({\b C_int}  {\i num})}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 86 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00086                           \{                                                                                 {\cf20 // Spces feedback function}\par
00087   {\cf20 /* Body */}\par
00088   {\cf19 for} ({\cf18 int} i = 0; i < num; ++i)                                                                             {\cf20 // Chars printin' FOR cycle}\par
00089     printf({\cf22 " "});                                                                                            {\cf20 // Print space fbk}\par
00090 \}\par
}
}
{\xe \v fbk_tabs\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_tabs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_tabs ({\b C_int}  {\i num})}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 93 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00093                         \{                                                                                   {\cf20 // Tabs feedback function}\par
00094   {\cf20 /* Body */}\par
00095   {\cf19 for} ({\cf18 int} i = 0; i < num; ++i)                                                                             {\cf20 // Chars printin' FOR cycle}\par
00096     printf({\cf22 "\\t"});                                                                                           {\cf20 // Print tab fbk}\par
00097 \}\par
}
}
{\xe \v logo\:lib_ui.c}
{\xe \v lib_ui.c\:logo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void logo ({\b Cu_shrt}  {\i start_sp}, {\b C_str}  {\i txt}, {\b C_str}  {\i txt_col}, {\b C_char}  {\i bkg_chr}, {\b C_str}  {\i bkg_col})}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00020                                                                                     \{                       {\cf20 // Print responsive-logo function}\par
00021   {\cf20 /* Body */}\par
00022   {\cf17 struct }winsize w;                                                                                         {\cf20 // Window-size struct declaration}\par
00023   ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);                                                                     {\cf20 // Save the number of terminal's rows/cloumns in window-size struct}\par
00024   Cu_shrt vthck = (w.ws_row / 5);                                                                           {\cf20 // Logo bkg vertical thickness calc}\par
00025   Cu_shrt lthck = (w.ws_col / 6);                                                                           {\cf20 // Logo bkg lateral thickness calc}\par
00026   Cu_shrt lsp = (Cu_shrt)(w.ws_col - 2*lthck - 2*start_sp - (Cu_shrt)strlen(txt)) / 2;                      {\cf20 // Logo internal lateral spaces calc}\par
00027   Cu_shrt len = (Cu_shrt)(2*lthck+2*lsp+(Cu_shrt)strlen(txt));                                              {\cf20 // Logo length calc}\par
00028   {\cf20 // Print logo}\par
00029   printf({\cf22 "\\n%s"}, bkg_col);                                                                                  {\cf20 // New line fbk}\par
00030   {\cf19 for} (U_shrt i = 0; i < (4*vthck+1); ++i)\{                                                                 {\cf20 // Logo lines print FOR cycle}\par
00031     {\cf19 for} (U_shrt j = 0; j < start_sp; ++j)\{                                                                  {\cf20 // Initial spaces print FOR cycle}\par
00032       printf({\cf22 " "});                                                                                          {\cf20 // Print initial spaces}\par
00033     \}\par
00034     {\cf19 if} ((i < vthck || i > (3*vthck)) && (i != (4*vthck)/2))\{                                                {\cf20 // Full bkg logo lines print cond}\par
00035       {\cf19 for} (U_shrt h = 0; h < len; ++h)\{                                                                     {\cf20 // Full bkg logo lines print FOR cycle}\par
00036         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Bkg logo char print}\par
00037       \}\par
00038       fbk_nl(1);                                                                                            {\cf20 // New line feedback function call}\par
00039     \} {\cf19 else} {\cf19 if} ((i >= vthck && i <= (3*vthck)) && (i != (4*vthck)/2)) \{                                      {\cf20 // Partial-empty bkg logo lines print cond}\par
00040       {\cf19 for} (U_shrt l = 0; l < lthck; ++l)\{                                                                   {\cf20 // Partial-empty bkg logo lines, initial full part print FOR cycle}\par
00041         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Partial-empty bkg logo lines, initial full part print}\par
00042       \}\par
00043       {\cf19 for} (U_shrt m = 0; m < (len - 2*lthck); ++m)\{                                                         {\cf20 // Partial-empty bkg logo lines, central empty part print FOR cycle}\par
00044         printf({\cf22 " "});                                                                                        {\cf20 // Partial-empty bkg logo lines, central empty part print}\par
00045       \}\par
00046       {\cf19 for} (U_shrt n = 0; n < lthck; ++n)\{                                                                   {\cf20 // Partial-empty bkg logo lines, final full part print FOR cycle}\par
00047         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Partial-empty bkg logo lines, final full part print}\par
00048       \}\par
00049       fbk_nl(1);                                                                                            {\cf20 // New line feedback function call}\par
00050     \} {\cf19 else} {\cf19 if} (i == ((4*vthck)/2)) \{                                                                        {\cf20 // Text logo line initial full part print cond}\par
00051       {\cf19 for} (U_shrt o = 0; o < lthck; ++o)\{                                                                   {\cf20 // Text logo line initial full part print FOR cycle}\par
00052         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Text logo line initial full part print}\par
00053       \}\par
00054       {\cf19 for} (U_shrt p = 0; p < lsp; ++p)\{                                                                     {\cf20 // Text logo line central empty part print FOR cycle}\par
00055         printf({\cf22 " "});                                                                                        {\cf20 // Text logo line central empty part print}\par
00056       \}\par
00057       printf({\cf22 "%s%s%s"}, txt_col, txt, bkg_col);                                                              {\cf20 // Text logo line central text part print}\par
00058       {\cf19 for} (U_shrt q = 0; q < lsp; ++q)\{                                                                     {\cf20 // Text logo line central empty part print FOR cycle}\par
00059         printf({\cf22 " "});                                                                                        {\cf20 // Text logo line central empty part print}\par
00060       \}\par
00061       {\cf19 for} (U_shrt r = 0; r < lthck; ++r)\{                                                                   {\cf20 // Text logo line final full part print FOR cycle}\par
00062         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Text logo line final full part print}\par
00063       \}\par
00064       fbk_nl(1);                                                                                            {\cf20 // New line feedback function call}\par
00065     \}\par
00066   \}\par
00067   printf(ER);                                                                                               {\cf20 // New line fbk and erase logo bkg color}\par
00068 \}\par
}
}
{\xe \v press_enter\:lib_ui.c}
{\xe \v lib_ui.c\:press_enter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void press_enter ({\b C_str}  {\i req_str})}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00071                                \{                                                                            {\cf20 // Press enter function}\par
00072   {\cf20 /* Body */}\par
00073   printf({\cf22 "\\n\\n%s>>>%s %s! %sPress %sENTER%s to contine... %s;)%s"},\par
00074           GN, PU, req_str, CY, YE, CY, RD, ER);                                                             {\cf20 // Build map, press enter key to start fbk}\par
00075   read_term_in();                                                                                           {\cf20 // Wait enter key to start (read terminal input function call)}\par
00076 \}\par
}
}
{\xe \v read_term_in\:lib_ui.c}
{\xe \v lib_ui.c\:read_term_in}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Str} read_term_in ()}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 157 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00157                   \{                                                                                         {\cf20 // Read terminal input function}\par
00158   {\cf20 /* Body */}\par
00159   unused = scanf({\cf22 "%30[^\\n]"}, term_in_buff);                                                                 {\cf20 // Reads the string 'till '\\n' char, avoidin' scanf stop at space char and saving '\\n' chr (str var definition) --> avoid buffer overflow assigning max input str size to (31-1)=30 for '\\0' char}\par
00160   {\cf19 while} ((getchar()) != {\cf23 '\\n'});                                                                              {\cf20 // Instruction to clear input buffer when buffer overflow occurs, avoiding to save next char as new input}\par
00161   {\cf19 return} term_in_buff;                                                                                      {\cf20 // Return terminal input string}\par
00162 \}\par
}
}
{\xe \v read_term_in_confirm\:lib_ui.c}
{\xe \v lib_ui.c\:read_term_in_confirm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Confirm} read_term_in_confirm ({\b C_str}  {\i req_str})}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 186 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00186                                            \{                                                                {\cf20 // Read terminal input confirmation function}\par
00187   {\cf20 /* Body */}\par
00188   Str in_str;                                                                                               {\cf20 // Terminal input string tmp var}\par
00189   Confirm answ;                                                                                             {\cf20 // Confirmation answer}\par
00190   Byte exit_flg = 0;                                                                                        {\cf20 // Terminal input while-loop exit flag}\par
00191   {\cf20 // Read input from terminal}\par
00192   {\cf19 do}\{\par
00193     clr_term_in();                                                                                          {\cf20 // Clear terminal input buffer function call}\par
00194     printf({\cf22 "%s>>>%s %s?%s Options %s(yes/no/cancel)%s%s: %s"}, GN, PU, req_str, BU, OG, BU, PU, ER);         {\cf20 // Print request fbk}\par
00195     in_str = read_term_in();                                                                                {\cf20 // Read terminal input function call}\par
00196     {\cf19 if} (0 == strcmp(in_str, {\cf22 "yes"}) || 0 == strcmp(in_str, {\cf22 "YES"}) || 0 == strcmp(in_str, {\cf22 "Yes"}))\{            {\cf20 // YES answer}\par
00197       answ = YES;                                                                                           {\cf20 // Set answer = YES}\par
00198       ++exit_flg;                                                                                           {\cf20 // Set exit flag}\par
00199     \} {\cf19 else} {\cf19 if} (0 == strcmp(in_str, {\cf22 "no"}) || 0 == strcmp(in_str, {\cf22 "NO"}) ||\par
00200                0 == strcmp(in_str, {\cf22 "No"}) || 0 == strcmp(in_str, {\cf22 "nO"}))\{                                     {\cf20 // NO answer}\par
00201       answ = NO;                                                                                            {\cf20 // Set answer = NO}\par
00202       ++exit_flg;                                                                                           {\cf20 // Set exit flag}\par
00203     \} {\cf19 else} {\cf19 if}(0 == strcmp(in_str, {\cf22 "cancel"}) || 0 == strcmp(in_str, {\cf22 "CANCEL"}) ||\par
00204               0 == strcmp(in_str, {\cf22 "Cancel"}))\{                                                               {\cf20 // CANCEL answer}\par
00205       answ = CANCEL;                                                                                        {\cf20 // Set answer = CANCEL}\par
00206       ++exit_flg;                                                                                           {\cf20 // Set exit flag}\par
00207     \}\par
00208     {\cf20 // Chk xit flg}\par
00209     {\cf19 if} (!exit_flg)                                                                                          {\cf20 // Exit flag val chack}\par
00210       printf({\cf22 "%s>>>%s The answer must be %s(yes/no/cancel)%s!%s\\n"}, OG, RD, YE, RD, ER);                    {\cf20 // Print terminal input error fbk}\par
00211   \} {\cf19 while}(!exit_flg);                                                                                       {\cf20 // Check while-loop exit flag val}\par
00212   \par
00213   {\cf19 return} answ;                                                                                              {\cf20 // Return confirmation answer}\par
00214 \}\par
}
}
{\xe \v read_term_in_int\:lib_ui.c}
{\xe \v lib_ui.c\:read_term_in_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int read_term_in_int ()}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 238 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00238                       \{                                                                                     {\cf20 // Read terminal input INT function}\par
00239   {\cf20 /* Body */}\par
00240   {\cf19 return} atoi(read_term_in());                                                                              {\cf20 // Return integer conversion of input string}\par
00241 \}\par
}
}
{\xe \v read_term_in_int_inrange\:lib_ui.c}
{\xe \v lib_ui.c\:read_term_in_int_inrange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int read_term_in_int_inrange ({\b C_int}  {\i min_val}, {\b C_int}  {\i max_val}, {\b C_str}  {\i req_str}, {\b C_str}  {\i err_str})}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 244 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00244                                                                                         \{                   {\cf20 // Read terminal input INT (in-range) function}\par
00245   {\cf20 /* Body */}\par
00246   {\cf18 int} val = 0;                                                                                              {\cf20 // Terminal input value}\par
00247   Byte exit_flg = 0;                                                                                        {\cf20 // Terminal input while-loop exit flag}\par
00248   {\cf20 // Read terminal input}\par
00249   {\cf19 do}\{\par
00250     clr_term_in();                                                                                          {\cf20 // Clear terminal input buffer function call}\par
00251     printf({\cf22 "%s>>>%s %s %s(min %s%d%s, max %s%d%s and NOT %s0%s)%s: %s"},\par
00252             GN, PU, req_str, BU, OG, min_val, BU, OG, max_val, BU, OG, BU, PU, ER);                         {\cf20 // Enter the number of crosses to allocate fbk}\par
00253     val = read_term_in_int();                                                                               {\cf20 // Read terminal input INT function call}\par
00254     exit_flg = (val >= min_val && val <= max_val && val != 0);                                              {\cf20 // Terminal input while-loop exit flag val upd}\par
00255     {\cf20 // Chk xit flg}\par
00256     {\cf19 if} (!exit_flg)                                                                                          {\cf20 // Exit flag val chack}\par
00257       printf({\cf22 "%s>>>%s %s must be in %s[%d, %d]%s range!%s\\n"},\par
00258               OG, RD, err_str, YE, min_val, max_val, RD, ER);                                               {\cf20 // Print terminal input error fbk}\par
00259   \} {\cf19 while}(!exit_flg);                                                                                       {\cf20 // Check while-loop exit flag val}\par
00260     \par
00261   {\cf19 return} val;                                                                                               {\cf20 // Return terminal input val}\par
00262 \}\par
}
}
{\xe \v read_term_in_min_chrs\:lib_ui.c}
{\xe \v lib_ui.c\:read_term_in_min_chrs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Str} read_term_in_min_chrs ({\b C_byte}  {\i min_chrs}, {\b C_str}  {\i req_str}, {\b C_str}  {\i err_str})}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 165 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00165                                                                         \{                                   {\cf20 // Read terminal input (min chars) function}\par
00166   {\cf20 /* Body */}\par
00167   Str in_str;                                                                                               {\cf20 // Terminal input string tmp var}\par
00168   Byte exit_flg = 0;                                                                                        {\cf20 // Terminal input while-loop exit flag}\par
00169   {\cf20 // Read input from terminal}\par
00170   {\cf19 do}\{\par
00171     clr_term_in();                                                                                          {\cf20 // Clear terminal input buffer function call}\par
00172     printf({\cf22 "\\n%s>>>%s %s,%s at least %s%d%s char(s), max %s%d%s chars%s: %s"},\par
00173             GN, PU, req_str, BU, OG, min_chrs, BU, OG, IN_BUFF_SIZE-1, BU, PU, ER);                         {\cf20 // Print request fbk}\par
00174     in_str = read_term_in();                                                                                {\cf20 // Read terminal input function call}\par
00175     exit_flg = (strlen(in_str) >= min_chrs);                                                                {\cf20 // Terminal input while-loop exit flag val upd}\par
00176     {\cf20 // Chk xit flg}\par
00177     {\cf19 if} (!exit_flg)                                                                                          {\cf20 // Exit flag val chack}\par
00178       printf({\cf22 "%s>>>%s %s must be at least %s%d%s char(s) long!%s\\n"},\par
00179               OG, RD, err_str, YE, min_chrs, RD, ER);                                                       {\cf20 // Print terminal input error fbk}\par
00180   \} {\cf19 while}(!exit_flg);                                                                                       {\cf20 // Check while-loop exit flag val}\par
00181   \par
00182   {\cf19 return} in_str;                                                                                            {\cf20 // Return terminal input string}\par
00183 \}\par
}
}
{\xe \v read_term_in_min_chrs_exit_chr\:lib_ui.c}
{\xe \v lib_ui.c\:read_term_in_min_chrs_exit_chr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Str} read_term_in_min_chrs_exit_chr ({\b C_byte}  {\i min_chrs}, {\b C_str}  {\i req_str}, {\b C_str}  {\i err_str}, {\b C_char}  {\i exit_chr})}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 217 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00217                                                                                                   \{         {\cf20 // Read terminal input (min chars and exit char) function}\par
00218   {\cf20 /* Body */}\par
00219   Str in_str;                                                                                               {\cf20 // Terminal input string tmp var}\par
00220   Byte exit_flg = 0;                                                                                        {\cf20 // Terminal input while-loop exit flag}\par
00221   {\cf20 // Read terminal input}\par
00222   {\cf19 do}\{\par
00223     clr_term_in();                                                                                          {\cf20 // Clear terminal input buffer function call}\par
00224     printf({\cf22 "%s>>>%s %s %s(at least %s%d%s char(s) and max %s%d%s, type %s'%c'%s char to continue)%s: %s"},\par
00225             GN, PU, req_str, BU, OG, min_chrs, BU, OG, IN_BUFF_SIZE-1, BU, OG, exit_chr, BU, PU, ER);       {\cf20 // Print request fbk}\par
00226     in_str = read_term_in();                                                                                {\cf20 // Read terminal input function call}\par
00227     exit_flg = (strlen(in_str) >= min_chrs) || (*in_str == exit_chr);                                       {\cf20 // Terminal input while-loop exit flag val upd}\par
00228     {\cf20 // Chk xit flg}\par
00229     {\cf19 if} (!exit_flg)                                                                                          {\cf20 // Exit flag val chack}\par
00230       printf({\cf22 "%s>>>%s %s must be at least %s%d%s char(s) long!%s\\n"},\par
00231               OG, RD, err_str, YE, min_chrs, RD, ER);                                                       {\cf20 // Print terminal input error fbk}\par
00232   \} {\cf19 while}(!exit_flg);                                                                                       {\cf20 // Check while-loop exit flag val}\par
00233   \par
00234   {\cf19 return} in_str;                                                                                            {\cf20 // Return terminal input string}\par
00235 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v term_in_buff\:lib_ui.c}
{\xe \v lib_ui.c\:term_in_buff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char term_in_buff[{\b IN_BUFF_SIZE}] = ""}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file lib_ui.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/ui/lib_ui.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/ui/lib_ui.h}
{\xe \v lib/ui/lib_ui.h}
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <sys/ioctl.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <stdarg.h>}\par
{\f2 #include <signal.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IN_BUFF_SIZE}\~ 31\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RD}\~ "\\033[0;31m"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BU}\~ "\\033[0;34m"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LBU}\~ "\\033[1;34m"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PU}\~ "\\033[0;35m"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CY}\~ "\\033[0;36m"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b YE}\~ "\\033[1;33m"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OG}\~ "\\033[0;33m"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GN}\~ "\\033[0;32m"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LGN}\~ "\\033[1;32m"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LGY}\~ "\\033[0;37m"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ER}\~ "\\033[0m"\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b confirm} {\b Confirm}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned char {\b Byte}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned short {\b U_shrt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned int {\b U_int}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned long {\b U_long}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef double {\b Real}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef long double {\b L_real}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef char * {\b Str}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void * {\b Ptr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef const {\b Cstr} {\b C_str}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b confirm} \{ {\b YES}, 
{\b NO}, 
{\b CANCEL}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logo} ({\b Cu_shrt} start_sp, {\b C_str} txt, {\b C_str} txt_col, {\b C_char} bkg_chr, {\b C_str} bkg_col)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b press_enter} ({\b C_str} req_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_nl} ({\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_spaces} ({\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_tabs} ({\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_separator} ({\b C_char} chr, {\b C_str} col)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_cy} ({\b C_str} fbk_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_pu} ({\b C_str} fbk_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_int} ({\b C_str} prfx_str_lbu, {\b C_int} val_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_str} ({\b C_str} prfx_str_lbu, {\b C_str} str_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_real} ({\b C_str} prfx_str_lbu, {\b C_real} val_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_lreal} ({\b C_str} prfx_str_lbu, {\b Cl_real} val_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_ptr} ({\b C_str} prfx_str_lbu, {\b C_ptr} val_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_err} ({\b C_str} fbk_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Str} {\b read_term_in} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Str} {\b read_term_in_min_chrs} ({\b C_byte} min_chrs, {\b C_str} req_str, {\b C_str} err_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Confirm} {\b read_term_in_confirm} ({\b C_str} req_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Str} {\b read_term_in_min_chrs_exit_chr} ({\b C_byte} min_chrs, {\b C_str} req_str, {\b C_str} err_str, {\b C_char} exit_chr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b read_term_in_int} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b read_term_in_int_inrange} ({\b C_int} min_val, {\b C_int} max_val, {\b C_str} req_str, {\b C_str} err_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clr_term_in} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_print} ({\b C_str} str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_str} ({\b C_str} str, {\b C_str} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_int} ({\b C_str} str, {\b C_int} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_real} ({\b C_str} str, {\b C_real} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_lreal} ({\b C_str} str, {\b Cl_real} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_ptr} ({\b C_str} str, {\b C_ptr} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_err} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_fbk} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_keyboard_interrupt} ({\b C_int} signal)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const typedef char {\b C_char}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const typedef {\b Byte} {\b C_byte}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const typedef int {\b C_int}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const typedef {\b Real} {\b C_real}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const typedef long double {\b Cl_real}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const typedef {\b Str} {\b Cstr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const typedef {\b U_shrt} {\b Cu_shrt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const typedef void *const {\b C_ptr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b term_in_buff} [{\b IN_BUFF_SIZE}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b unused}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v BU\:lib_ui.h}
{\xe \v lib_ui.h\:BU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BU\~ "\\033[0;34m"}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file lib_ui.h.}\par
}
{\xe \v CY\:lib_ui.h}
{\xe \v lib_ui.h\:CY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CY\~ "\\033[0;36m"}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 29 of file lib_ui.h.}\par
}
{\xe \v ER\:lib_ui.h}
{\xe \v lib_ui.h\:ER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ER\~ "\\033[0m"}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file lib_ui.h.}\par
}
{\xe \v GN\:lib_ui.h}
{\xe \v lib_ui.h\:GN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GN\~ "\\033[0;32m"}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file lib_ui.h.}\par
}
{\xe \v IN_BUFF_SIZE\:lib_ui.h}
{\xe \v lib_ui.h\:IN_BUFF_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IN_BUFF_SIZE\~ 31}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 21 of file lib_ui.h.}\par
}
{\xe \v LBU\:lib_ui.h}
{\xe \v lib_ui.h\:LBU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LBU\~ "\\033[1;34m"}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 27 of file lib_ui.h.}\par
}
{\xe \v LGN\:lib_ui.h}
{\xe \v lib_ui.h\:LGN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LGN\~ "\\033[1;32m"}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file lib_ui.h.}\par
}
{\xe \v LGY\:lib_ui.h}
{\xe \v lib_ui.h\:LGY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LGY\~ "\\033[0;37m"}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file lib_ui.h.}\par
}
{\xe \v OG\:lib_ui.h}
{\xe \v lib_ui.h\:OG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OG\~ "\\033[0;33m"}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file lib_ui.h.}\par
}
{\xe \v PU\:lib_ui.h}
{\xe \v lib_ui.h\:PU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PU\~ "\\033[0;35m"}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file lib_ui.h.}\par
}
{\xe \v RD\:lib_ui.h}
{\xe \v lib_ui.h\:RD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RD\~ "\\033[0;31m"}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 25 of file lib_ui.h.}\par
}
{\xe \v YE\:lib_ui.h}
{\xe \v lib_ui.h\:YE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define YE\~ "\\033[1;33m"}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 30 of file lib_ui.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v Byte\:lib_ui.h}
{\xe \v lib_ui.h\:Byte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned char {\b Byte}}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file lib_ui.h.}\par
}
{\xe \v C_str\:lib_ui.h}
{\xe \v lib_ui.h\:C_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef const {\b Cstr} {\b C_str}}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file lib_ui.h.}\par
}
{\xe \v Confirm\:lib_ui.h}
{\xe \v lib_ui.h\:Confirm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b confirm} {\b Confirm}}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v L_real\:lib_ui.h}
{\xe \v lib_ui.h\:L_real}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef long double {\b L_real}}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file lib_ui.h.}\par
}
{\xe \v Ptr\:lib_ui.h}
{\xe \v lib_ui.h\:Ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void* {\b Ptr}}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file lib_ui.h.}\par
}
{\xe \v Real\:lib_ui.h}
{\xe \v lib_ui.h\:Real}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef double {\b Real}}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file lib_ui.h.}\par
}
{\xe \v Str\:lib_ui.h}
{\xe \v lib_ui.h\:Str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef char* {\b Str}}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file lib_ui.h.}\par
}
{\xe \v U_int\:lib_ui.h}
{\xe \v lib_ui.h\:U_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned int {\b U_int}}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file lib_ui.h.}\par
}
{\xe \v U_long\:lib_ui.h}
{\xe \v lib_ui.h\:U_long}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned long {\b U_long}}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file lib_ui.h.}\par
}
{\xe \v U_shrt\:lib_ui.h}
{\xe \v lib_ui.h\:U_shrt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned short {\b U_shrt}}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file lib_ui.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v confirm\:lib_ui.h}
{\xe \v lib_ui.h\:confirm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b confirm}}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v YES\:lib_ui.h}
{\xe \v lib_ui.h\:YES}
{\qr YES{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
\cell }{\cell }{\row }
{\xe \v NO\:lib_ui.h}
{\xe \v lib_ui.h\:NO}
{\qr NO{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
\cell }{\cell }{\row }
{\xe \v CANCEL\:lib_ui.h}
{\xe \v lib_ui.h\:CANCEL}
{\qr CANCEL{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
\cell }{\cell }{\row }
}
\par
{
Definition at line 39 of file lib_ui.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00039 \{YES, NO, CANCEL\} Confirm;                                                             {\cf20 // Confirmation enum typedef}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v close_err\:lib_ui.h}
{\xe \v lib_ui.h\:close_err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_err ()}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 313 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00313                 \{                                                                                           {\cf20 // Close software with error function}\par
00314   {\cf20 /* Body */}\par
00315   printf({\cf22 "\\n%s>>>%s Closin' due to error... %sSorry! %s:(%s\\n"}, OG, RD, CY, OG, ER);                        {\cf20 // Closin' due to error fbk}\par
00316   exit(EXIT_FAILURE);                                                                                       {\cf20 // Close software}\par
00317 \}\par
}
}
{\xe \v close_fbk\:lib_ui.h}
{\xe \v lib_ui.h\:close_fbk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_fbk ()}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 320 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00320                 \{                                                                                           {\cf20 // Function to close software with feedback}\par
00321   {\cf20 /* Body */}\par
00322   printf({\cf22 "\\n\\n%s>>>%s Closin'... %sBye! %s;)%s\\n"}, GN, PU, CY, RD, ER);                                     {\cf20 // Closin' fbk}\par
00323   exit(EXIT_SUCCESS);                                                                                       {\cf20 // Close software}\par
00324 \}\par
}
}
{\xe \v close_keyboard_interrupt\:lib_ui.h}
{\xe \v lib_ui.h\:close_keyboard_interrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_keyboard_interrupt ({\b C_int}  {\i signal})}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 327 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00327                                            \{                                                                {\cf20 // Function to close SW with fbk due to keyboard interrupt detected (ctrl+c)}\par
00328   {\cf20 /* Body */}\par
00329   printf({\cf22 "\\n\\n%s>>>%s Keyboard interrupt detected, closin'... %sBye! %s;)%s\\n"}, GN, PU, CY, RD, ER);        {\cf20 // Closin' fbk}\par
00330   exit(signal);                                                                                             {\cf20 // Exit SW with signal}\par
00331 \}\par
}
}
{\xe \v clr_term_in\:lib_ui.h}
{\xe \v lib_ui.h\:clr_term_in}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void clr_term_in ()}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 265 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00265                   \{                                                                                         {\cf20 // Clear terminal input buffer function}\par
00266   {\cf20 /* Body */}\par
00267   strcpy(term_in_buff, {\cf22 "\\0"});                                                                               {\cf20 // Clear input buffer char array}\par
00268 \}\par
}
}
{\xe \v dbg\:lib_ui.h}
{\xe \v lib_ui.h\:dbg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg ()}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 271 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00271           \{                                                                                                 {\cf20 // Fast debug function}\par
00272   {\cf20 /* Body */}\par
00273   printf({\cf22 "\\n\\n%s    >>>>>> %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, LGN, ER);                                   {\cf20 // Print debug line}\par
00274 \}\par
}
}
{\xe \v dbg_int\:lib_ui.h}
{\xe \v lib_ui.h\:dbg_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_int ({\b C_str}  {\i str}, {\b C_int}  {\i val})}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 289 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00289                                   \{                                                                         {\cf20 // Debug int val print function}\par
00290   {\cf20 /* Body */}\par
00291   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%d %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);      {\cf20 // Print debug line}\par
00292 \}\par
}
}
{\xe \v dbg_lreal\:lib_ui.h}
{\xe \v lib_ui.h\:dbg_lreal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_lreal ({\b C_str}  {\i str}, {\b Cl_real}  {\i val})}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 301 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00301                                       \{                                                                     {\cf20 // Debug long real val print function}\par
00302   {\cf20 /* Body */}\par
00303   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%Lg %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);     {\cf20 // Print debug line}\par
00304 \}\par
}
}
{\xe \v dbg_print\:lib_ui.h}
{\xe \v lib_ui.h\:dbg_print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_print ({\b C_str}  {\i str})}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 277 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00277                          \{                                                                                  {\cf20 // Debug print function}\par
00278   {\cf20 /* Body */}\par
00279   printf({\cf22 "\\n\\n%s    >>>>>>%s %s %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, LGN, ER);                     {\cf20 // Print debug line}\par
00280 \}\par
}
}
{\xe \v dbg_ptr\:lib_ui.h}
{\xe \v lib_ui.h\:dbg_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_ptr ({\b C_str}  {\i str}, {\b C_ptr}  {\i val})}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 307 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00307                                   \{                                                                         {\cf20 // Debug ptr val print function}\par
00308   {\cf20 /* Body */}\par
00309   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%p %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);      {\cf20 // Print debug line}\par
00310 \}\par
}
}
{\xe \v dbg_real\:lib_ui.h}
{\xe \v lib_ui.h\:dbg_real}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_real ({\b C_str}  {\i str}, {\b C_real}  {\i val})}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 295 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00295                                     \{                                                                       {\cf20 // Debug real val print function}\par
00296   {\cf20 /* Body */}\par
00297   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%g %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);      {\cf20 // Print debug line}\par
00298 \}\par
}
}
{\xe \v dbg_str\:lib_ui.h}
{\xe \v lib_ui.h\:dbg_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_str ({\b C_str}  {\i str}, {\b C_str}  {\i val})}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 283 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00283                                   \{                                                                         {\cf20 // Debug string val print function}\par
00284   {\cf20 /* Body */}\par
00285   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%s %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);      {\cf20 // Print debug line}\par
00286 \}\par
}
}
{\xe \v fbk_err\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_err ({\b C_str}  {\i fbk_str})}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 151 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00151                            \{                                                                                {\cf20 // Error feedback function}\par
00152   {\cf20 /* Body */}\par
00153   printf({\cf22 "\\n%s>>>%s %s!%s\\n"}, OG, RD, fbk_str, ER);                                                         {\cf20 // Print error fbk}\par
00154 \}\par
}
}
{\xe \v fbk_gn_cy\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_gn_cy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_cy ({\b C_str}  {\i fbk_str})}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 109 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00109                              \{                                                                              {\cf20 // Green-cyan feedback function}\par
00110   {\cf20 /* Body */}\par
00111   printf({\cf22 "%s>>>%s %s%s"}, GN, CY, fbk_str, ER);                                                              {\cf20 // Print green-cyan string fbk}\par
00112 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_int\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_gn_lbu_ye_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_int ({\b C_str}  {\i prfx_str_lbu}, {\b C_int}  {\i val_ye})}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 121 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00121                                                         \{                                                   {\cf20 // Green-lightblue-yellow int val feedback function}\par
00122   {\cf20 /* Body */}\par
00123   printf({\cf22 "%s>>>%s %s: %s%d%s"}, GN, LBU, prfx_str_lbu, YE, val_ye, ER);                                      {\cf20 // Print green-lightblue-yellow int val feedback}\par
00124 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_lreal\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_gn_lbu_ye_lreal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_lreal ({\b C_str}  {\i prfx_str_lbu}, {\b Cl_real}  {\i val_ye})}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00139                                                             \{                                               {\cf20 // Green-lightblue-yellow long real val feedback function}\par
00140   {\cf20 /* Body */}\par
00141   printf({\cf22 "%s>>>%s %s: %s%Lg%s"}, GN, LBU, prfx_str_lbu, YE, val_ye, ER);                                     {\cf20 // Print green-lightblue-yellow long real val feedback}\par
00142 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_ptr\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_gn_lbu_ye_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_ptr ({\b C_str}  {\i prfx_str_lbu}, {\b C_ptr}  {\i val_ye})}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 145 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00145                                                         \{                                                   {\cf20 // Green-lightblue-yellow ptr val feedback function}\par
00146   {\cf20 /* Body */}\par
00147   printf({\cf22 "%s>>>%s %s: %s%p%s"}, GN, LBU, prfx_str_lbu, YE, val_ye, ER);                                      {\cf20 // Print green-lightblue-yellow ptr val feedback}\par
00148 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_real\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_gn_lbu_ye_real}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_real ({\b C_str}  {\i prfx_str_lbu}, {\b C_real}  {\i val_ye})}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 133 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00133                                                           \{                                                 {\cf20 // Green-lightblue-yellow real val feedback function}\par
00134   {\cf20 /* Body */}\par
00135   printf({\cf22 "%s>>>%s %s: %s%g%s"}, GN, LBU, prfx_str_lbu, YE, val_ye, ER);                                      {\cf20 // Print green-lightblue-yellow real val feedback}\par
00136 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_str\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_gn_lbu_ye_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_str ({\b C_str}  {\i prfx_str_lbu}, {\b C_str}  {\i str_ye})}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 127 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00127                                                         \{                                                   {\cf20 // Green-lightblue-yellow str val feedback function}\par
00128   {\cf20 /* Body */}\par
00129   printf({\cf22 "%s>>>%s %s: %s%s%s"}, GN, LBU, prfx_str_lbu, YE, str_ye, ER);                                      {\cf20 // Print green-lightblue-yellow str val feedback}\par
00130 \}\par
}
}
{\xe \v fbk_gn_pu\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_gn_pu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_pu ({\b C_str}  {\i fbk_str})}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 115 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00115                              \{                                                                              {\cf20 // Green-purple feedback function}\par
00116   {\cf20 /* Body */}\par
00117   printf({\cf22 "%s>>>%s %s%s"}, GN, PU, fbk_str, ER);                                                              {\cf20 // Print green-purple string fbk}\par
00118 \}\par
}
}
{\xe \v fbk_nl\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_nl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_nl ({\b C_int}  {\i num})}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00079                       \{                                                                                     {\cf20 // New lines feedback function}\par
00080   {\cf20 /* Body */}\par
00081   {\cf19 for} ({\cf18 int} i = 0; i < num; ++i)                                                                             {\cf20 // Chars printin' FOR cycle}\par
00082     printf({\cf22 "\\n"});                                                                                           {\cf20 // Print new line fbk}\par
00083 \}\par
}
}
{\xe \v fbk_separator\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_separator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_separator ({\b C_char}  {\i chr}, {\b C_str}  {\i col})}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 100 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00100                                          \{                                                                  {\cf20 // Separator feedback function}\par
00101   {\cf20 /* Body */}\par
00102   {\cf17 struct }winsize w;                                                                                         {\cf20 // Window-size struct declaration}\par
00103   ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);                                                                     {\cf20 // Save the number of terminal's rows/cloumns in window-size struct}\par
00104   {\cf19 for} ({\cf18 int} i = 0; i < w.ws_col; ++i)                                                                        {\cf20 // Chars printin' FOR cycle}\par
00105     printf({\cf22 "%s%c%s"}, col, chr, ER);                                                                         {\cf20 // Print space fbk}\par
00106 \}\par
}
}
{\xe \v fbk_spaces\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_spaces}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_spaces ({\b C_int}  {\i num})}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 86 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00086                           \{                                                                                 {\cf20 // Spces feedback function}\par
00087   {\cf20 /* Body */}\par
00088   {\cf19 for} ({\cf18 int} i = 0; i < num; ++i)                                                                             {\cf20 // Chars printin' FOR cycle}\par
00089     printf({\cf22 " "});                                                                                            {\cf20 // Print space fbk}\par
00090 \}\par
}
}
{\xe \v fbk_tabs\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_tabs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_tabs ({\b C_int}  {\i num})}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 93 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00093                         \{                                                                                   {\cf20 // Tabs feedback function}\par
00094   {\cf20 /* Body */}\par
00095   {\cf19 for} ({\cf18 int} i = 0; i < num; ++i)                                                                             {\cf20 // Chars printin' FOR cycle}\par
00096     printf({\cf22 "\\t"});                                                                                           {\cf20 // Print tab fbk}\par
00097 \}\par
}
}
{\xe \v logo\:lib_ui.h}
{\xe \v lib_ui.h\:logo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void logo ({\b Cu_shrt}  {\i start_sp}, {\b C_str}  {\i txt}, {\b C_str}  {\i txt_col}, {\b C_char}  {\i bkg_chr}, {\b C_str}  {\i bkg_col})}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00020                                                                                     \{                       {\cf20 // Print responsive-logo function}\par
00021   {\cf20 /* Body */}\par
00022   {\cf17 struct }winsize w;                                                                                         {\cf20 // Window-size struct declaration}\par
00023   ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);                                                                     {\cf20 // Save the number of terminal's rows/cloumns in window-size struct}\par
00024   Cu_shrt vthck = (w.ws_row / 5);                                                                           {\cf20 // Logo bkg vertical thickness calc}\par
00025   Cu_shrt lthck = (w.ws_col / 6);                                                                           {\cf20 // Logo bkg lateral thickness calc}\par
00026   Cu_shrt lsp = (Cu_shrt)(w.ws_col - 2*lthck - 2*start_sp - (Cu_shrt)strlen(txt)) / 2;                      {\cf20 // Logo internal lateral spaces calc}\par
00027   Cu_shrt len = (Cu_shrt)(2*lthck+2*lsp+(Cu_shrt)strlen(txt));                                              {\cf20 // Logo length calc}\par
00028   {\cf20 // Print logo}\par
00029   printf({\cf22 "\\n%s"}, bkg_col);                                                                                  {\cf20 // New line fbk}\par
00030   {\cf19 for} (U_shrt i = 0; i < (4*vthck+1); ++i)\{                                                                 {\cf20 // Logo lines print FOR cycle}\par
00031     {\cf19 for} (U_shrt j = 0; j < start_sp; ++j)\{                                                                  {\cf20 // Initial spaces print FOR cycle}\par
00032       printf({\cf22 " "});                                                                                          {\cf20 // Print initial spaces}\par
00033     \}\par
00034     {\cf19 if} ((i < vthck || i > (3*vthck)) && (i != (4*vthck)/2))\{                                                {\cf20 // Full bkg logo lines print cond}\par
00035       {\cf19 for} (U_shrt h = 0; h < len; ++h)\{                                                                     {\cf20 // Full bkg logo lines print FOR cycle}\par
00036         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Bkg logo char print}\par
00037       \}\par
00038       fbk_nl(1);                                                                                            {\cf20 // New line feedback function call}\par
00039     \} {\cf19 else} {\cf19 if} ((i >= vthck && i <= (3*vthck)) && (i != (4*vthck)/2)) \{                                      {\cf20 // Partial-empty bkg logo lines print cond}\par
00040       {\cf19 for} (U_shrt l = 0; l < lthck; ++l)\{                                                                   {\cf20 // Partial-empty bkg logo lines, initial full part print FOR cycle}\par
00041         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Partial-empty bkg logo lines, initial full part print}\par
00042       \}\par
00043       {\cf19 for} (U_shrt m = 0; m < (len - 2*lthck); ++m)\{                                                         {\cf20 // Partial-empty bkg logo lines, central empty part print FOR cycle}\par
00044         printf({\cf22 " "});                                                                                        {\cf20 // Partial-empty bkg logo lines, central empty part print}\par
00045       \}\par
00046       {\cf19 for} (U_shrt n = 0; n < lthck; ++n)\{                                                                   {\cf20 // Partial-empty bkg logo lines, final full part print FOR cycle}\par
00047         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Partial-empty bkg logo lines, final full part print}\par
00048       \}\par
00049       fbk_nl(1);                                                                                            {\cf20 // New line feedback function call}\par
00050     \} {\cf19 else} {\cf19 if} (i == ((4*vthck)/2)) \{                                                                        {\cf20 // Text logo line initial full part print cond}\par
00051       {\cf19 for} (U_shrt o = 0; o < lthck; ++o)\{                                                                   {\cf20 // Text logo line initial full part print FOR cycle}\par
00052         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Text logo line initial full part print}\par
00053       \}\par
00054       {\cf19 for} (U_shrt p = 0; p < lsp; ++p)\{                                                                     {\cf20 // Text logo line central empty part print FOR cycle}\par
00055         printf({\cf22 " "});                                                                                        {\cf20 // Text logo line central empty part print}\par
00056       \}\par
00057       printf({\cf22 "%s%s%s"}, txt_col, txt, bkg_col);                                                              {\cf20 // Text logo line central text part print}\par
00058       {\cf19 for} (U_shrt q = 0; q < lsp; ++q)\{                                                                     {\cf20 // Text logo line central empty part print FOR cycle}\par
00059         printf({\cf22 " "});                                                                                        {\cf20 // Text logo line central empty part print}\par
00060       \}\par
00061       {\cf19 for} (U_shrt r = 0; r < lthck; ++r)\{                                                                   {\cf20 // Text logo line final full part print FOR cycle}\par
00062         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Text logo line final full part print}\par
00063       \}\par
00064       fbk_nl(1);                                                                                            {\cf20 // New line feedback function call}\par
00065     \}\par
00066   \}\par
00067   printf(ER);                                                                                               {\cf20 // New line fbk and erase logo bkg color}\par
00068 \}\par
}
}
{\xe \v press_enter\:lib_ui.h}
{\xe \v lib_ui.h\:press_enter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void press_enter ({\b C_str}  {\i req_str})}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00071                                \{                                                                            {\cf20 // Press enter function}\par
00072   {\cf20 /* Body */}\par
00073   printf({\cf22 "\\n\\n%s>>>%s %s! %sPress %sENTER%s to contine... %s;)%s"},\par
00074           GN, PU, req_str, CY, YE, CY, RD, ER);                                                             {\cf20 // Build map, press enter key to start fbk}\par
00075   read_term_in();                                                                                           {\cf20 // Wait enter key to start (read terminal input function call)}\par
00076 \}\par
}
}
{\xe \v read_term_in\:lib_ui.h}
{\xe \v lib_ui.h\:read_term_in}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Str} read_term_in ()}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 157 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00157                   \{                                                                                         {\cf20 // Read terminal input function}\par
00158   {\cf20 /* Body */}\par
00159   unused = scanf({\cf22 "%30[^\\n]"}, term_in_buff);                                                                 {\cf20 // Reads the string 'till '\\n' char, avoidin' scanf stop at space char and saving '\\n' chr (str var definition) --> avoid buffer overflow assigning max input str size to (31-1)=30 for '\\0' char}\par
00160   {\cf19 while} ((getchar()) != {\cf23 '\\n'});                                                                              {\cf20 // Instruction to clear input buffer when buffer overflow occurs, avoiding to save next char as new input}\par
00161   {\cf19 return} term_in_buff;                                                                                      {\cf20 // Return terminal input string}\par
00162 \}\par
}
}
{\xe \v read_term_in_confirm\:lib_ui.h}
{\xe \v lib_ui.h\:read_term_in_confirm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Confirm} read_term_in_confirm ({\b C_str}  {\i req_str})}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 186 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00186                                            \{                                                                {\cf20 // Read terminal input confirmation function}\par
00187   {\cf20 /* Body */}\par
00188   Str in_str;                                                                                               {\cf20 // Terminal input string tmp var}\par
00189   Confirm answ;                                                                                             {\cf20 // Confirmation answer}\par
00190   Byte exit_flg = 0;                                                                                        {\cf20 // Terminal input while-loop exit flag}\par
00191   {\cf20 // Read input from terminal}\par
00192   {\cf19 do}\{\par
00193     clr_term_in();                                                                                          {\cf20 // Clear terminal input buffer function call}\par
00194     printf({\cf22 "%s>>>%s %s?%s Options %s(yes/no/cancel)%s%s: %s"}, GN, PU, req_str, BU, OG, BU, PU, ER);         {\cf20 // Print request fbk}\par
00195     in_str = read_term_in();                                                                                {\cf20 // Read terminal input function call}\par
00196     {\cf19 if} (0 == strcmp(in_str, {\cf22 "yes"}) || 0 == strcmp(in_str, {\cf22 "YES"}) || 0 == strcmp(in_str, {\cf22 "Yes"}))\{            {\cf20 // YES answer}\par
00197       answ = YES;                                                                                           {\cf20 // Set answer = YES}\par
00198       ++exit_flg;                                                                                           {\cf20 // Set exit flag}\par
00199     \} {\cf19 else} {\cf19 if} (0 == strcmp(in_str, {\cf22 "no"}) || 0 == strcmp(in_str, {\cf22 "NO"}) ||\par
00200                0 == strcmp(in_str, {\cf22 "No"}) || 0 == strcmp(in_str, {\cf22 "nO"}))\{                                     {\cf20 // NO answer}\par
00201       answ = NO;                                                                                            {\cf20 // Set answer = NO}\par
00202       ++exit_flg;                                                                                           {\cf20 // Set exit flag}\par
00203     \} {\cf19 else} {\cf19 if}(0 == strcmp(in_str, {\cf22 "cancel"}) || 0 == strcmp(in_str, {\cf22 "CANCEL"}) ||\par
00204               0 == strcmp(in_str, {\cf22 "Cancel"}))\{                                                               {\cf20 // CANCEL answer}\par
00205       answ = CANCEL;                                                                                        {\cf20 // Set answer = CANCEL}\par
00206       ++exit_flg;                                                                                           {\cf20 // Set exit flag}\par
00207     \}\par
00208     {\cf20 // Chk xit flg}\par
00209     {\cf19 if} (!exit_flg)                                                                                          {\cf20 // Exit flag val chack}\par
00210       printf({\cf22 "%s>>>%s The answer must be %s(yes/no/cancel)%s!%s\\n"}, OG, RD, YE, RD, ER);                    {\cf20 // Print terminal input error fbk}\par
00211   \} {\cf19 while}(!exit_flg);                                                                                       {\cf20 // Check while-loop exit flag val}\par
00212   \par
00213   {\cf19 return} answ;                                                                                              {\cf20 // Return confirmation answer}\par
00214 \}\par
}
}
{\xe \v read_term_in_int\:lib_ui.h}
{\xe \v lib_ui.h\:read_term_in_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int read_term_in_int ()}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 238 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00238                       \{                                                                                     {\cf20 // Read terminal input INT function}\par
00239   {\cf20 /* Body */}\par
00240   {\cf19 return} atoi(read_term_in());                                                                              {\cf20 // Return integer conversion of input string}\par
00241 \}\par
}
}
{\xe \v read_term_in_int_inrange\:lib_ui.h}
{\xe \v lib_ui.h\:read_term_in_int_inrange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int read_term_in_int_inrange ({\b C_int}  {\i min_val}, {\b C_int}  {\i max_val}, {\b C_str}  {\i req_str}, {\b C_str}  {\i err_str})}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 244 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00244                                                                                         \{                   {\cf20 // Read terminal input INT (in-range) function}\par
00245   {\cf20 /* Body */}\par
00246   {\cf18 int} val = 0;                                                                                              {\cf20 // Terminal input value}\par
00247   Byte exit_flg = 0;                                                                                        {\cf20 // Terminal input while-loop exit flag}\par
00248   {\cf20 // Read terminal input}\par
00249   {\cf19 do}\{\par
00250     clr_term_in();                                                                                          {\cf20 // Clear terminal input buffer function call}\par
00251     printf({\cf22 "%s>>>%s %s %s(min %s%d%s, max %s%d%s and NOT %s0%s)%s: %s"},\par
00252             GN, PU, req_str, BU, OG, min_val, BU, OG, max_val, BU, OG, BU, PU, ER);                         {\cf20 // Enter the number of crosses to allocate fbk}\par
00253     val = read_term_in_int();                                                                               {\cf20 // Read terminal input INT function call}\par
00254     exit_flg = (val >= min_val && val <= max_val && val != 0);                                              {\cf20 // Terminal input while-loop exit flag val upd}\par
00255     {\cf20 // Chk xit flg}\par
00256     {\cf19 if} (!exit_flg)                                                                                          {\cf20 // Exit flag val chack}\par
00257       printf({\cf22 "%s>>>%s %s must be in %s[%d, %d]%s range!%s\\n"},\par
00258               OG, RD, err_str, YE, min_val, max_val, RD, ER);                                               {\cf20 // Print terminal input error fbk}\par
00259   \} {\cf19 while}(!exit_flg);                                                                                       {\cf20 // Check while-loop exit flag val}\par
00260     \par
00261   {\cf19 return} val;                                                                                               {\cf20 // Return terminal input val}\par
00262 \}\par
}
}
{\xe \v read_term_in_min_chrs\:lib_ui.h}
{\xe \v lib_ui.h\:read_term_in_min_chrs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Str} read_term_in_min_chrs ({\b C_byte}  {\i min_chrs}, {\b C_str}  {\i req_str}, {\b C_str}  {\i err_str})}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 165 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00165                                                                         \{                                   {\cf20 // Read terminal input (min chars) function}\par
00166   {\cf20 /* Body */}\par
00167   Str in_str;                                                                                               {\cf20 // Terminal input string tmp var}\par
00168   Byte exit_flg = 0;                                                                                        {\cf20 // Terminal input while-loop exit flag}\par
00169   {\cf20 // Read input from terminal}\par
00170   {\cf19 do}\{\par
00171     clr_term_in();                                                                                          {\cf20 // Clear terminal input buffer function call}\par
00172     printf({\cf22 "\\n%s>>>%s %s,%s at least %s%d%s char(s), max %s%d%s chars%s: %s"},\par
00173             GN, PU, req_str, BU, OG, min_chrs, BU, OG, IN_BUFF_SIZE-1, BU, PU, ER);                         {\cf20 // Print request fbk}\par
00174     in_str = read_term_in();                                                                                {\cf20 // Read terminal input function call}\par
00175     exit_flg = (strlen(in_str) >= min_chrs);                                                                {\cf20 // Terminal input while-loop exit flag val upd}\par
00176     {\cf20 // Chk xit flg}\par
00177     {\cf19 if} (!exit_flg)                                                                                          {\cf20 // Exit flag val chack}\par
00178       printf({\cf22 "%s>>>%s %s must be at least %s%d%s char(s) long!%s\\n"},\par
00179               OG, RD, err_str, YE, min_chrs, RD, ER);                                                       {\cf20 // Print terminal input error fbk}\par
00180   \} {\cf19 while}(!exit_flg);                                                                                       {\cf20 // Check while-loop exit flag val}\par
00181   \par
00182   {\cf19 return} in_str;                                                                                            {\cf20 // Return terminal input string}\par
00183 \}\par
}
}
{\xe \v read_term_in_min_chrs_exit_chr\:lib_ui.h}
{\xe \v lib_ui.h\:read_term_in_min_chrs_exit_chr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Str} read_term_in_min_chrs_exit_chr ({\b C_byte}  {\i min_chrs}, {\b C_str}  {\i req_str}, {\b C_str}  {\i err_str}, {\b C_char}  {\i exit_chr})}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 217 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00217                                                                                                   \{         {\cf20 // Read terminal input (min chars and exit char) function}\par
00218   {\cf20 /* Body */}\par
00219   Str in_str;                                                                                               {\cf20 // Terminal input string tmp var}\par
00220   Byte exit_flg = 0;                                                                                        {\cf20 // Terminal input while-loop exit flag}\par
00221   {\cf20 // Read terminal input}\par
00222   {\cf19 do}\{\par
00223     clr_term_in();                                                                                          {\cf20 // Clear terminal input buffer function call}\par
00224     printf({\cf22 "%s>>>%s %s %s(at least %s%d%s char(s) and max %s%d%s, type %s'%c'%s char to continue)%s: %s"},\par
00225             GN, PU, req_str, BU, OG, min_chrs, BU, OG, IN_BUFF_SIZE-1, BU, OG, exit_chr, BU, PU, ER);       {\cf20 // Print request fbk}\par
00226     in_str = read_term_in();                                                                                {\cf20 // Read terminal input function call}\par
00227     exit_flg = (strlen(in_str) >= min_chrs) || (*in_str == exit_chr);                                       {\cf20 // Terminal input while-loop exit flag val upd}\par
00228     {\cf20 // Chk xit flg}\par
00229     {\cf19 if} (!exit_flg)                                                                                          {\cf20 // Exit flag val chack}\par
00230       printf({\cf22 "%s>>>%s %s must be at least %s%d%s char(s) long!%s\\n"},\par
00231               OG, RD, err_str, YE, min_chrs, RD, ER);                                                       {\cf20 // Print terminal input error fbk}\par
00232   \} {\cf19 while}(!exit_flg);                                                                                       {\cf20 // Check while-loop exit flag val}\par
00233   \par
00234   {\cf19 return} in_str;                                                                                            {\cf20 // Return terminal input string}\par
00235 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v C_byte\:lib_ui.h}
{\xe \v lib_ui.h\:C_byte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const typedef {\b Byte} C_byte}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file lib_ui.h.}\par
}
{\xe \v C_char\:lib_ui.h}
{\xe \v lib_ui.h\:C_char}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const typedef char C_char}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 51 of file lib_ui.h.}\par
}
{\xe \v C_int\:lib_ui.h}
{\xe \v lib_ui.h\:C_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const typedef int C_int}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 53 of file lib_ui.h.}\par
}
{\xe \v C_ptr\:lib_ui.h}
{\xe \v lib_ui.h\:C_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const typedef void* const C_ptr}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file lib_ui.h.}\par
}
{\xe \v C_real\:lib_ui.h}
{\xe \v lib_ui.h\:C_real}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const typedef {\b Real} C_real}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 54 of file lib_ui.h.}\par
}
{\xe \v Cl_real\:lib_ui.h}
{\xe \v lib_ui.h\:Cl_real}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const typedef long double Cl_real}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file lib_ui.h.}\par
}
{\xe \v Cstr\:lib_ui.h}
{\xe \v lib_ui.h\:Cstr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const typedef {\b Str} Cstr}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file lib_ui.h.}\par
}
{\xe \v Cu_shrt\:lib_ui.h}
{\xe \v lib_ui.h\:Cu_shrt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const typedef {\b U_shrt} Cu_shrt}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 58 of file lib_ui.h.}\par
}
{\xe \v term_in_buff\:lib_ui.h}
{\xe \v lib_ui.h\:term_in_buff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char term_in_buff[{\b IN_BUFF_SIZE}]}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file lib_ui.c.}\par
}
{\xe \v unused\:lib_ui.h}
{\xe \v lib_ui.h\:unused}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int unused}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/ui/lib_ui.so File Reference\par \pard\plain 
{\tc\tcl2 \v lib/ui/lib_ui.so}
{\xe \v lib/ui/lib_ui.so}
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
main/graph_test.c File Reference\par \pard\plain 
{\tc\tcl2 \v main/graph_test.c}
{\xe \v main/graph_test.c}
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
csdcds }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../lib/graph/lib_graph.h"}\par
{\f2 #include "../lib/files/lib_files.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b street}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Street struct typedef for graph-library test (use crosses and streets as example of archs and nodes). }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VERBOSE}\~ {\b Y}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Advanced verbose mode (Y/N). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SOURCE_NODE_NAME}\~ "Cross4"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Source node name for graph-library prepared testing mode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DESTINATION_NODE_NAME}\~ "Cross9"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Destination node name for graph-library prepared testing mode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEST_NODE_NAME_SPECIAL_CASE1}\~ "Cross4"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Destination node name for graph-library prepared testing mode special case1 (source = destination). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEST_NODE_NAME_SPECIAL_CASE2}\~ "Cross10"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Destination node name for graph-library prepared testing mode special case2 (destination node unreachble). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GPLOT_TEST_GRAPH_LAYOUT_CMD}\~ "gnuplot -e \\"load 'gnuplot/graph_plot.cmd'; pause -1\\""\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot graph plotting system command. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GPLOT_SHORTEST_PATH_CMD}\~ "gnuplot -e \\"load 'gnuplot/shortest_plot.cmd'; pause -1\\""\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot graph and shortest path plotting system command. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ARCHS_DAT_FILE}\~ "gnuplot/archs.dat"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot archs data file. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COSTS_DAT_FILE}\~ "gnuplot/costs.dat"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot arch-costs data file. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NODES_DAT_FILE}\~ "gnuplot/nodes.dat"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot nodes data file. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHORTEST_ARCHS_DAT_FILE}\~ "gnuplot/shortest_archs.dat"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot shortest-path archs data file. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHORTEST_COSTS_DAT_FILE}\~ "gnuplot/shortest_costs.dat"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot shortest-path arch-costs data file. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHORTEST_NODES_DAT_FILE}\~ "gnuplot/shortest_nodes.dat"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot shortest-path nodes data file (source and destination nodes excluded). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SRC_DEST_NODES_DAT_FILE}\~ "gnuplot/src_dest_nodes.dat"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot shortest-path source and destination nodes data file. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b test_choice} {\b Test_choice}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Test-choice enum typedef to define graph-library testing mode: prepared test, personalized test or exit and close test software. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b street} {\b Street}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Street struct typedef for graph-library test (use crosses and streets as example of archs and nodes). }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b test_choice} \{ {\b PREPARED} =1, 
{\b PERSONALIZED}, 
{\b EXIT}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Test-choice enum typedef to define graph-library testing mode: prepared test, personalized test or exit and close test software. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b terminate_keyboard} (int signal)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b create_archs} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b create_nodes} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b create_connections} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b test_option_choice} ({\b Test_choice} *const choice)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b build_shortest_path_graphics_data} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b display_test_graph} ({\b C_str} cmd)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b apply_dijkstra} ({\b C_str} src_nd_name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b reconstruct_min_path} ({\b C_str} dest_nd_name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b define_src_node_name} ({\b Str} *src_nd_nm)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b define_dest_node_name} ({\b Str} *dest_nd_nm)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Street} {\b strts_vect} []\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Global-variable description:}  Street-structs vector (to dynamically initalize archs). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b C_str} {\b crss_names_vect} []\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Global-variable description:}  Cross-names vector (to dynamically initalize nodes). }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
csdcds \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
saxxasxsa \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ARCHS_DAT_FILE\:graph_test.c}
{\xe \v graph_test.c\:ARCHS_DAT_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ARCHS_DAT_FILE\~ "gnuplot/archs.dat"}}
\par
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot archs data file. }}\par
{
Definition at line 95 of file graph_test.c.}\par
}
{\xe \v COSTS_DAT_FILE\:graph_test.c}
{\xe \v graph_test.c\:COSTS_DAT_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COSTS_DAT_FILE\~ "gnuplot/costs.dat"}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot arch-costs data file. }}\par
{
Definition at line 97 of file graph_test.c.}\par
}
{\xe \v DEST_NODE_NAME_SPECIAL_CASE1\:graph_test.c}
{\xe \v graph_test.c\:DEST_NODE_NAME_SPECIAL_CASE1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEST_NODE_NAME_SPECIAL_CASE1\~ "Cross4"}}
\par
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Destination node name for graph-library prepared testing mode special case1 (source = destination). }}\par
{
Definition at line 87 of file graph_test.c.}\par
}
{\xe \v DEST_NODE_NAME_SPECIAL_CASE2\:graph_test.c}
{\xe \v graph_test.c\:DEST_NODE_NAME_SPECIAL_CASE2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEST_NODE_NAME_SPECIAL_CASE2\~ "Cross10"}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Destination node name for graph-library prepared testing mode special case2 (destination node unreachble). }}\par
{
Definition at line 89 of file graph_test.c.}\par
}
{\xe \v DESTINATION_NODE_NAME\:graph_test.c}
{\xe \v graph_test.c\:DESTINATION_NODE_NAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DESTINATION_NODE_NAME\~ "Cross9"}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Destination node name for graph-library prepared testing mode. }}\par
{
Definition at line 85 of file graph_test.c.}\par
}
{\xe \v GPLOT_SHORTEST_PATH_CMD\:graph_test.c}
{\xe \v graph_test.c\:GPLOT_SHORTEST_PATH_CMD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GPLOT_SHORTEST_PATH_CMD\~ "gnuplot -e \\"load 'gnuplot/shortest_plot.cmd'; pause -1\\""}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot graph and shortest path plotting system command. }}\par
{
Definition at line 93 of file graph_test.c.}\par
}
{\xe \v GPLOT_TEST_GRAPH_LAYOUT_CMD\:graph_test.c}
{\xe \v graph_test.c\:GPLOT_TEST_GRAPH_LAYOUT_CMD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GPLOT_TEST_GRAPH_LAYOUT_CMD\~ "gnuplot -e \\"load 'gnuplot/graph_plot.cmd'; pause -1\\""}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot graph plotting system command. }}\par
{
Definition at line 91 of file graph_test.c.}\par
}
{\xe \v NODES_DAT_FILE\:graph_test.c}
{\xe \v graph_test.c\:NODES_DAT_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NODES_DAT_FILE\~ "gnuplot/nodes.dat"}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot nodes data file. }}\par
{
Definition at line 99 of file graph_test.c.}\par
}
{\xe \v SHORTEST_ARCHS_DAT_FILE\:graph_test.c}
{\xe \v graph_test.c\:SHORTEST_ARCHS_DAT_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHORTEST_ARCHS_DAT_FILE\~ "gnuplot/shortest_archs.dat"}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot shortest-path archs data file. }}\par
{
Definition at line 101 of file graph_test.c.}\par
}
{\xe \v SHORTEST_COSTS_DAT_FILE\:graph_test.c}
{\xe \v graph_test.c\:SHORTEST_COSTS_DAT_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHORTEST_COSTS_DAT_FILE\~ "gnuplot/shortest_costs.dat"}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot shortest-path arch-costs data file. }}\par
{
Definition at line 103 of file graph_test.c.}\par
}
{\xe \v SHORTEST_NODES_DAT_FILE\:graph_test.c}
{\xe \v graph_test.c\:SHORTEST_NODES_DAT_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHORTEST_NODES_DAT_FILE\~ "gnuplot/shortest_nodes.dat"}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot shortest-path nodes data file (source and destination nodes excluded). }}\par
{
Definition at line 105 of file graph_test.c.}\par
}
{\xe \v SOURCE_NODE_NAME\:graph_test.c}
{\xe \v graph_test.c\:SOURCE_NODE_NAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SOURCE_NODE_NAME\~ "Cross4"}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Source node name for graph-library prepared testing mode. }}\par
{
Definition at line 83 of file graph_test.c.}\par
}
{\xe \v SRC_DEST_NODES_DAT_FILE\:graph_test.c}
{\xe \v graph_test.c\:SRC_DEST_NODES_DAT_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SRC_DEST_NODES_DAT_FILE\~ "gnuplot/src_dest_nodes.dat"}}
\par
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot shortest-path source and destination nodes data file. }}\par
{
Definition at line 107 of file graph_test.c.}\par
}
{\xe \v VERBOSE\:graph_test.c}
{\xe \v graph_test.c\:VERBOSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VERBOSE\~ {\b Y}}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Advanced verbose mode (Y/N). }}\par
{
Definition at line 81 of file graph_test.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v Street\:graph_test.c}
{\xe \v graph_test.c\:Street}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b street} {\b Street}}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Street struct typedef for graph-library test (use crosses and streets as example of archs and nodes). }}\par
}
{\xe \v Test_choice\:graph_test.c}
{\xe \v graph_test.c\:Test_choice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b test_choice} {\b Test_choice}}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Test-choice enum typedef to define graph-library testing mode: prepared test, personalized test or exit and close test software. }}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v test_choice\:graph_test.c}
{\xe \v graph_test.c\:test_choice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b test_choice}}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Test-choice enum typedef to define graph-library testing mode: prepared test, personalized test or exit and close test software. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v PREPARED\:graph_test.c}
{\xe \v graph_test.c\:PREPARED}
{\qr PREPARED{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prepared-test testing option: pre-defined source and destination nodes in graph to find min-cost path (defined with macros {\b SOURCE_NODE_NAME} and {\b DESTINATION_NODE_NAME}). \par
}\cell }{\row }
{\xe \v PERSONALIZED\:graph_test.c}
{\xe \v graph_test.c\:PERSONALIZED}
{\qr PERSONALIZED{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Personalized-test testing option: choose source and destination nodes in graph to find min-cost path. \par
}\cell }{\row }
{\xe \v EXIT\:graph_test.c}
{\xe \v graph_test.c\:EXIT}
{\qr EXIT{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exit option: deallocate graph structure and close software. \par
}\cell }{\row }
}
{
Definition at line 120 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00120 \{PREPARED=1, PERSONALIZED, EXIT\} Test_choice;                                      {\cf20 // Test-choice enum typedef}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v apply_dijkstra\:graph_test.c}
{\xe \v graph_test.c\:apply_dijkstra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void apply_dijkstra ({\b C_str}  {\i src_nd_name}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Static routine to apply Dijkstra's algorithm with verbose-mode enabled, from specified source node (selected by-name and checking if contained in nodes collection). Find min-cost paths from specified source node, towards each other node inside allocated graph. Find out if a specific possible destination node is unreachble, or if it corresponds to the source node.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i src_nd_name} \cell }{Source node name, from which to apply Dijkstra's algorithm.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 421 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00421                                              \{                                                              {\cf20 // Routine to apply Dijkstra's algorithm}\par
00422   {\cf20 /* Body */}\par
00423   dijkstra_alg(src_nd_name, VERBOSE);                                                                       {\cf20 // Apply Dijkstra alg using defined source node (find all min path-costs and prev nodes in shortest paths, Dijkstra-dataset vect allocated/reallocated inside heap) - Y/N for verbose mode}\par
00424 \}\par
}
}
{\xe \v build_shortest_path_graphics_data\:graph_test.c}
{\xe \v graph_test.c\:build_shortest_path_graphics_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void build_shortest_path_graphics_data (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Static routine to build shortest-path graphical data, working on gnuplt .dat data files (listed below) and defined with macros.{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Test-graph gnuplot data files (gnuplot data source)} :{
\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Archs data file} : {\b archs.dat} data file which contains the coordinates to draw arches in graph, with target name as comment in the previous line (defined in {\b ARCHS_DAT_FILE}).\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Costs data file} : {\b costs.dat} data file which contains the coordinates to draw arch-costs in graph, with target name as comment in the previous line (defined in {\b COSTS_DAT_FILE}).\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Nodes data file} : {\b nodes.dat} data file which contains the coordinates to draw nodes in graph, with target name as comment in the previous line (defined in {\b NODES_DAT_FILE}).\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Test-graph shortest path gnuplot data files (gnuplot data destination of selected elements to graphically recreate the min-cost path)} :{
\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Shortest-path archs data file} : {\b shortest_archs.dat} data file which contains the coordinates to draw arches in shortest-path graph, with target name as comment in the previous line (defined in {\b SHORTEST_ARCHS_DAT_FILE}).\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Shortest-path costs data file} : {\b shortest_costs.dat} data file which contains the coordinates to draw arch-costs in shortest-path graph, with target name as comment in the previous line (defined in {\b SHORTEST_ARCHS_DAT_FILE}).\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Shortest-path nodes data file (source-destination nodes excluded)} : {\b shortest_nodes.dat} data file which contains the coordinates to draw nodes in shortest-path graph (source-destination nodes excluded), with target name as comment in the previous line (defined in {\b SHORTEST_NODES_DAT_FILE}).\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Shortest-path source and destination nodes data file} : {\b src_dest_nodes.dat} data file which contains the coordinates to draw source and destination nodes in shortest-path graph, with target name as comment in the previous line (defined in {\b SRC_DEST_NODES_DAT_FILE}).\par}
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 288 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00288                                                \{                                                            {\cf20 // Routine to build the shortest-path graphics data for gnuplot}\par
00289   {\cf20 /* Body */}\par
00290   fbk_nl(1);  fbk_gn_pu({\cf22 "Building shortest-path graphics data (working on .dat files) for gnuplot..."});     {\cf20 // Print workin' on gnuplot graphics data files fbk}\par
00291   {\cf20 // Open .dat files}\par
00292   Fl archs_dat_file = open_file(ARCHS_DAT_FILE, {\cf22 "r"});                                                       {\cf20 // Open test-graph gnuplot arch-coords .dat file in read mode}\par
00293   Fl costs_dat_file = open_file(COSTS_DAT_FILE, {\cf22 "r"});                                                       {\cf20 // Open test-graph gnuplot arches cost-coords .dat file in read mode}\par
00294   Fl nodes_dat_file = open_file(NODES_DAT_FILE, {\cf22 "r"});                                                       {\cf20 // Open test-graph gnuplot node-coords .dat file in read mode}\par
00295   Fl shortest_archs_dat_file = open_file(SHORTEST_ARCHS_DAT_FILE, {\cf22 "w"});                                     {\cf20 // Open test-graph shortest path gnuplot arch-coords .dat file in write mode, clearin' file at open}\par
00296   Fl shortest_costs_dat_file = open_file(SHORTEST_COSTS_DAT_FILE, {\cf22 "w"});                                     {\cf20 // Open test-graph shortest path gnuplot arches cost-coords .dat file in write mode, clearin' file at open}\par
00297   Fl shortest_nodes_dat_file = open_file(SHORTEST_NODES_DAT_FILE, {\cf22 "w"});                                     {\cf20 // Open test-graph shortest path gnuplot node-coords .dat file in write mode, clearin' file at open}\par
00298   Fl src_dest_nodes_dat_file = open_file(SRC_DEST_NODES_DAT_FILE, {\cf22 "w"});                                     {\cf20 // Open test-graph gnuplot source and destination node-coords .dat file in write mode, clearin' file at open}\par
00299   {\cf20 // Check .dat files correctly opened}\par
00300   {\cf19 if} (archs_dat_file != NULL && costs_dat_file != NULL && nodes_dat_file != NULL &&\par
00301       shortest_archs_dat_file != NULL && shortest_costs_dat_file != NULL &&\par
00302       shortest_nodes_dat_file != NULL && src_dest_nodes_dat_file != NULL)\{                                  {\cf20 // If gnuplot .dat files has been correctly opened}\par
00303     {\cf20 // Vars init to modify gnuplot .dat files}\par
00304     {\cf18 int} tgt_line_num = 0;                                                                                   {\cf20 // Define target-line number var to find path archs/nodes coordinates in test-graph .dat files}\par
00305     Str tgt_line_str = NULL;                                                                                {\cf20 // Define target-line string var to copy path archs/nodes coordinates from test-graph .dat files to shortest-path and src-dest nodes .dat files}\par
00306     {\cf20 // Archs}\par
00307     {\cf19 for} ({\cf18 int} i = 1; i < min_pth_conn_vect_size; ++i)\{                                                       {\cf20 // Shortest-path archs scrollin' FOR cycle}\par
00308       rewind(archs_dat_file);                                                                               {\cf20 // Start/restart scannin' file from line 0}\par
00309       tgt_line_num = get_substr_line_from_file(archs_dat_file, min_path_conn_vect[i].ar->name);             {\cf20 // Define target line number by shortest-path arch name}\par
00310       {\cf19 if} (tgt_line_num >= 0)\{                                                                               {\cf20 // If arch name has been found in shortest-path archs}\par
00311         {\cf19 for} ({\cf18 int} j = 0; j < 3; ++j, ++tgt_line_num)\{                                                        {\cf20 // Extract target-line and the two following lines FOR cycle}\par
00312           rewind(archs_dat_file);                                                                           {\cf20 // Restart scannin' file from line 0}\par
00313           tgt_line_str = get_line_str_from_file(archs_dat_file, tgt_line_num);                              {\cf20 // Get extracted line content (str)}\par
00314           {\cf19 if} (tgt_line_str != NULL)\{                                                                        {\cf20 // If target string ain't NULL (no errors and string correctly acquired)}\par
00315             write_str_on_file(shortest_archs_dat_file, tgt_line_str);                                       {\cf20 // Write extracted string inside dedicated shortest-path gnuplot .dat file}\par
00316           \} {\cf19 else}                                                                                            {\cf20 // Else in case of target string null}\par
00317             fbk_err({\cf22 "Found error durig archs data copy in shortest path file! Check archs .dat file"});      {\cf20 // Print error fbk}\par
00318         \}\par
00319         write_nl_on_file(shortest_archs_dat_file);                                                          {\cf20 // Write new line inside dedicated shortest-path gnuplot .dat file}\par
00320       \} {\cf19 else}                                                                                                {\cf20 // Else in case of no-match found}\par
00321         fbk_err({\cf22 "Encountred error durig archs data copy in shortest path file! Check archs .dat file"});     {\cf20 // Print error fbk}\par
00322     \}\par
00323     {\cf20 // Arch-costs}\par
00324     {\cf19 for} ({\cf18 int} i = 1; i < min_pth_conn_vect_size; ++i)\{                                                       {\cf20 // Shortest-path arch-costs scrollin' FOR cycle}\par
00325       rewind(costs_dat_file);                                                                               {\cf20 // Start/restart scannin' file from line 0}\par
00326       tgt_line_num = get_substr_line_from_file(costs_dat_file, min_path_conn_vect[i].ar->name);             {\cf20 // Define target line number by shortest-path arch name}\par
00327       {\cf19 if} (tgt_line_num >= 0)\{                                                                               {\cf20 // If arch name has been found in shortest-path archs}\par
00328         {\cf19 for} ({\cf18 int} j = 0; j < 2; ++j, ++tgt_line_num)\{                                                        {\cf20 // Extract target-line and the following line FOR cycle}\par
00329           rewind(costs_dat_file);                                                                           {\cf20 // Restart scannin' file from line 0}\par
00330           tgt_line_str = get_line_str_from_file(costs_dat_file, tgt_line_num);                              {\cf20 // Get extracted line content (str)}\par
00331           {\cf19 if} (tgt_line_str != NULL)\{                                                                        {\cf20 // If target string ain't NULL (no errors and string correctly acquired)}\par
00332             write_str_on_file(shortest_costs_dat_file, tgt_line_str);                                       {\cf20 // Write extracted string inside dedicated shortest-path gnuplot .dat file}\par
00333           \} {\cf19 else}                                                                                            {\cf20 // Else in case of target string null}\par
00334             fbk_err({\cf22 "Found error durig costs data copy in shortest path file! Check costs .dat file"});      {\cf20 // Print error fbk}\par
00335         \}\par
00336         write_nl_on_file(shortest_costs_dat_file);                                                          {\cf20 // Write new line inside dedicated shortest-path gnuplot .dat file}\par
00337       \} {\cf19 else}                                                                                                {\cf20 // Else in case of no-match found}\par
00338         fbk_err({\cf22 "Encountred error durig costs data copy in shortest path file! Check costs .dat file"});     {\cf20 // Print error fbk}\par
00339     \}\par
00340     {\cf20 // Nodes (source and destination excluded)}\par
00341     {\cf19 for} ({\cf18 int} i = 1; i < min_pth_conn_vect_size-1; ++i)\{                                                     {\cf20 // Shortest-path intermediate-nodes scrollin' FOR cycle}\par
00342       rewind(nodes_dat_file);                                                                               {\cf20 // Start/restart scannin' file from line 0}\par
00343       tgt_line_num = get_substr_line_from_file(nodes_dat_file, min_path_conn_vect[i].nd->name);             {\cf20 // Define target line number by shortest-path node name}\par
00344       {\cf19 if} (tgt_line_num >= 0)\{                                                                               {\cf20 // If node name has been found in shortest-path nodes}\par
00345         {\cf19 for} ({\cf18 int} j = 0; j < 2; ++j, ++tgt_line_num)\{                                                        {\cf20 // Extract target-line and the following line FOR cycle}\par
00346           rewind(nodes_dat_file);                                                                           {\cf20 // Restart scannin' file from line 0}\par
00347           tgt_line_str = get_line_str_from_file(nodes_dat_file, tgt_line_num);                              {\cf20 // Get extracted line content (str)}\par
00348           {\cf19 if} (tgt_line_str != NULL)\{                                                                        {\cf20 // If target string ain't NULL (no errors and string correctly acquired)}\par
00349             write_str_on_file(shortest_nodes_dat_file, tgt_line_str);                                       {\cf20 // Write extracted string inside dedicated shortest-path gnuplot .dat file}\par
00350           \} {\cf19 else}                                                                                            {\cf20 // Else in case of target string null}\par
00351             fbk_err({\cf22 "Found error durig nodes data copy in shortest path file! Check nodes .dat file"});      {\cf20 // Print error fbk}\par
00352         \}\par
00353         write_nl_on_file(shortest_nodes_dat_file);                                                          {\cf20 // Write new line inside dedicated shortest-path gnuplot .dat file}\par
00354       \} {\cf19 else}                                                                                                {\cf20 // Else in case of no-match found}\par
00355         fbk_err({\cf22 "Encountred error durig nodes data copy in shortest path file! Check nodes .dat file"});     {\cf20 // Print error fbk}\par
00356     \}\par
00357     {\cf20 // Source and destination nodes}\par
00358     {\cf19 for} ({\cf18 int} i = 0; i < min_pth_conn_vect_size; i += (min_pth_conn_vect_size-1))\{                           {\cf20 // Shortest-path source and destination nodes scrollin' FOR cycle}\par
00359       rewind(nodes_dat_file);                                                                               {\cf20 // Restart scannin' file from line 0}\par
00360       tgt_line_num = get_substr_line_from_file(nodes_dat_file, min_path_conn_vect[i].nd->name);             {\cf20 // Define target line number by shortest-path node name}\par
00361       {\cf19 if} (tgt_line_num >= 0)\{                                                                               {\cf20 // If node name has been found in shortest-path nodes}\par
00362         {\cf19 for} ({\cf18 int} j = 0; j < 2; ++j, ++tgt_line_num)\{                                                        {\cf20 // Extract target-line and the following line FOR cycle}\par
00363           rewind(nodes_dat_file);                                                                           {\cf20 // Restart scannin' file from line 0}\par
00364           tgt_line_str = get_line_str_from_file(nodes_dat_file, tgt_line_num);                              {\cf20 // Get extracted line content (str)}\par
00365           {\cf19 if} (tgt_line_str != NULL)\{                                                                        {\cf20 // If target string ain't NULL (no errors and string correctly acquired)}\par
00366             write_str_on_file(src_dest_nodes_dat_file, tgt_line_str);                                       {\cf20 // Write extracted string inside dedicated shortest-path gnuplot .dat file}\par
00367           \} {\cf19 else}                                                                                            {\cf20 // Else in case of target string null}\par
00368             fbk_err({\cf22 "Found error durig src-dest data copy in shortest path file! Check nodes .dat file"});   {\cf20 // Print error fbk}\par
00369         \}\par
00370         write_nl_on_file(src_dest_nodes_dat_file);                                                          {\cf20 // Write new line inside dedicated shortest-path gnuplot .dat file}\par
00371       \} {\cf19 else}                                                                                                {\cf20 // Else in case of no-match found}\par
00372         fbk_err({\cf22 "Encountred error durig src-dest data copy in shortest path file! Check nodes .dat file"});  {\cf20 // Print error fbk}\par
00373     \}\par
00374     {\cf20 // Close .dat files}\par
00375     close_file(archs_dat_file);                                                                             {\cf20 // Close test-graph gnuplot arch-coords .dat file}\par
00376     close_file(costs_dat_file);                                                                             {\cf20 // Close test-graph gnuplot arches cost-coords .dat file}\par
00377     close_file(nodes_dat_file);                                                                             {\cf20 // Close test-graph gnuplot node-coords .dat file}\par
00378     close_file(shortest_archs_dat_file);                                                                    {\cf20 // Close test-graph shortest path gnuplot arch-coords .dat file}\par
00379     close_file(shortest_costs_dat_file);                                                                    {\cf20 // Close test-graph shortest path gnuplot arches cost-coords .dat file}\par
00380     close_file(shortest_nodes_dat_file);                                                                    {\cf20 // Close test-graph shortest path gnuplot node-coords .dat file}\par
00381     close_file(src_dest_nodes_dat_file);                                                                    {\cf20 // Close test-graph gnuplot source and destination node-coords .dat file}\par
00382     fbk_nl(1);  fbk_gn_cy({\cf22 "Shortest-path graphics data managenent for gnuplot completed!\\n"});               {\cf20 // Print Shortest-path graphics data managenent completed fbk}\par
00383   \} {\cf19 else}                                                                                                    {\cf20 // Else if gnuplot .dat files ain't been correctly opened}\par
00384     fbk_err({\cf22 "Ops! Something went wrong during shortest-path graphics data managenent for gnuplot"});         {\cf20 // Print err fbk}\par
00385 \}\par
}
}
{\xe \v create_archs\:graph_test.c}
{\xe \v graph_test.c\:create_archs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void create_archs (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Static routine to create test-graph arches, working on graph-library public variables.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 163 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00163                           \{                                                                                 {\cf20 // Routine to create archs}\par
00164   {\cf20 /* Body */}\par
00165   {\cf19 for} ({\cf18 int} i = 0; i < (int)({\cf17 sizeof}(strts_vect)/{\cf17 sizeof}({\cf17 const} Street)); ++i)                                  {\cf20 // Streets allocation FOR cycle}\par
00166     add_new_arch((C_str)strts_vect[i].name, strts_vect[i].length);                                          {\cf20 // Create new street (arch allocated inside heap)}\par
00167 \}\par
}
}
{\xe \v create_connections\:graph_test.c}
{\xe \v graph_test.c\:create_connections}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void create_connections (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Static routine to create test-graph arch-nodes connections, working on graph-library public variables.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 187 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00187                                 \{                                                                           {\cf20 // Routine to create connections btwn archs & nodes}\par
00188   {\cf20 /* Body */}\par
00189   connect_node_arch((C_str)strts_vect[0].name, crss_names_vect[0], ARCH_ND1, LIST_TAIL);                    {\cf20 // Connect "Street1" to "Cross1"}\par
00190   connect_node_arch((C_str)strts_vect[0].name, crss_names_vect[1], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street1" to "Cross2"}\par
00191   connect_node_arch((C_str)strts_vect[1].name, crss_names_vect[0], ARCH_ND1, LIST_TAIL);                    {\cf20 // Connect "Street2" to "Cross1"}\par
00192   connect_node_arch((C_str)strts_vect[1].name, crss_names_vect[2], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street2" to "Cross3"}\par
00193   connect_node_arch((C_str)strts_vect[2].name, crss_names_vect[0], ARCH_ND1, LIST_HEAD);                    {\cf20 // Connect "Street3" to "Cross1", add at list head position instead of list tail pos}\par
00194   connect_node_arch((C_str)strts_vect[2].name, crss_names_vect[3], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street3" to "Cross4"}\par
00195   connect_node_arch((C_str)strts_vect[3].name, crss_names_vect[0], ARCH_ND1, LIST_POS, 2);                  {\cf20 // Connect "Street4" to "Cross1", opt param --> add arch at specific pos in archs list, non-zero index}\par
00196   connect_node_arch((C_str)strts_vect[3].name, crss_names_vect[4], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street4" to "Cross5"}\par
00197   connect_node_arch((C_str)strts_vect[4].name, crss_names_vect[4], ARCH_ND1, LIST_TAIL);                    {\cf20 // Connect "Street5" to "Cross5"}\par
00198   connect_node_arch((C_str)strts_vect[4].name, crss_names_vect[5], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street5" to "Cross6"}\par
00199   connect_node_arch((C_str)strts_vect[5].name, crss_names_vect[5], ARCH_ND1, LIST_TAIL);                    {\cf20 // Connect "Street6" to "Cross6"}\par
00200   connect_node_arch((C_str)strts_vect[5].name, crss_names_vect[6], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street6" to "Cross7"}\par
00201   connect_node_arch((C_str)strts_vect[6].name, crss_names_vect[5], ARCH_ND1, LIST_TAIL);                    {\cf20 // Connect "Street7" to "Cross6"}\par
00202   connect_node_arch((C_str)strts_vect[6].name, crss_names_vect[7], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street7" to "Cross8"}\par
00203   connect_node_arch((C_str)strts_vect[7].name, crss_names_vect[7], ARCH_ND1, LIST_TAIL);                    {\cf20 // Connect "Street8" to "Cross8"}\par
00204   connect_node_arch((C_str)strts_vect[7].name, crss_names_vect[8], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street8" to "Cross9"}\par
00205   connect_node_arch((C_str)strts_vect[8].name, crss_names_vect[0], ARCH_ND1, LIST_TAIL);                    {\cf20 // Connect "Street9" to "Cross1"}\par
00206   connect_node_arch((C_str)strts_vect[8].name, crss_names_vect[6], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street9" to "Cross7"}\par
00207   connect_node_arch((C_str)strts_vect[9].name, crss_names_vect[0], ARCH_ND1, LIST_TAIL);                    {\cf20 // Connect "Street10" to "Cross1"}\par
00208   connect_node_arch((C_str)strts_vect[9].name, crss_names_vect[5], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street10" to "Cross6"}\par
00209   connect_node_arch((C_str)strts_vect[10].name, crss_names_vect[3], ARCH_ND1, LIST_TAIL);                   {\cf20 // Connect "Street11" to "Cross4"}\par
00210   connect_node_arch((C_str)strts_vect[10].name, crss_names_vect[4], ARCH_ND2, LIST_TAIL);                   {\cf20 // Connect "Street11" to "Cross5"}\par
00211   connect_node_arch((C_str)strts_vect[11].name, crss_names_vect[4], ARCH_ND1, LIST_TAIL);                   {\cf20 // Connect "Street12" to "Cross5"}\par
00212   connect_node_arch((C_str)strts_vect[11].name, crss_names_vect[7], ARCH_ND2, LIST_TAIL);                   {\cf20 // Connect "Street12" to "Cross8"}\par
00213   connect_node_arch((C_str)strts_vect[12].name, crss_names_vect[4], ARCH_ND1, LIST_TAIL);                   {\cf20 // Connect "Street13" to "Cross5"}\par
00214   connect_node_arch((C_str)strts_vect[12].name, crss_names_vect[8], ARCH_ND2, LIST_TAIL);                   {\cf20 // Connect "Street13" to "Cross9"}\par
00215 \}\par
}
}
{\xe \v create_nodes\:graph_test.c}
{\xe \v graph_test.c\:create_nodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void create_nodes (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Static routine to create test-graph nodes, working on graph-library public variables.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 175 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00175                           \{                                                                                 {\cf20 // Routine to create nodes}\par
00176   {\cf20 /* Body */}\par
00177   {\cf19 for} ({\cf18 int} j = 0; j < (int)({\cf17 sizeof}(crss_names_vect)/{\cf17 sizeof}(C_str)); ++j)                                    {\cf20 // Crosses allocation FOR cycle}\par
00178     add_new_node(crss_names_vect[j]);                                                                       {\cf20 // Create new cross (node allocated inside heap)}\par
00179 \}\par
}
}
{\xe \v define_dest_node_name\:graph_test.c}
{\xe \v graph_test.c\:define_dest_node_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void define_dest_node_name ({\b Str} *  {\i dest_nd_nm}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Static routine to define destination node name from user terminal-input, to be abe to reconstruct min-cost pah from source node defined when calling Dijkstra's algorithm. After that, function checks if specified node is contained in nodes collection.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i dest_nd_nm} \cell }{Destination node name terminal-input, to reconstruct min-cost path.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 468 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00468                                                   \{                                                         {\cf20 // Routine to define presonalized destination-node name}\par
00469   {\cf20 /* Body */}\par
00470   {\cf19 for} ({\cf18 int} i = 0; i < nds_collect_size; ++i)\{                                                               {\cf20 // Nodes collection vect scrollin' FOR cycle}\par
00471     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Node name"}, nodes_collect_vect[i].name);                                 {\cf20 // Print node name fbk}\par
00472   \}\par
00473   {\cf19 do} \{                                                                                                      {\cf20 // Cycle to define personalized destination-node name}\par
00474     *dest_nd_nm = read_term_in_min_chrs(1, {\cf22 "Choose a destination node (by name)"}, {\cf22 "Destination node name"}); {\cf20 // Read user input str}\par
00475   \} {\cf19 while}(idx_by_name(ND, *dest_nd_nm) < 0);                                                                {\cf20 // Check whether node-name specified by the user exists in nodes collection vect, otherwise repeat question}\par
00476 \}\par
}
}
{\xe \v define_src_node_name\:graph_test.c}
{\xe \v graph_test.c\:define_src_node_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void define_src_node_name ({\b Str} *  {\i src_nd_nm}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Static routine to define source node name for Dijkstra's algorithm function, from user terminal-input. After that, function checks if specified node is contained in nodes collection.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i src_nd_nm} \cell }{Source node name terminal-input, for Dijkstra's algorithm.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 449 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00449                                                 \{                                                           {\cf20 // Routine to define presonalized source-node name}\par
00450   {\cf20 /* Body */}\par
00451   {\cf19 for} ({\cf18 int} i = 0; i < nds_collect_size; ++i)\{                                                               {\cf20 // Nodes collection vect scrollin' FOR cycle}\par
00452     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Node name"}, nodes_collect_vect[i].name);                                 {\cf20 // Print node name fbk}\par
00453   \}\par
00454   {\cf19 do} \{                                                                                                      {\cf20 // Cycle to define personalized source-node name}\par
00455     *src_nd_nm = read_term_in_min_chrs(1, {\cf22 "Choose a source node (by name)"}, {\cf22 "Source node name"});            {\cf20 // Read user input str}\par
00456   \} {\cf19 while}(idx_by_name(ND, *src_nd_nm) < 0);                                                                 {\cf20 // Check whether node-name specified by the user exists in nodes collection vect, otherwise repeat question}\par
00457 \}\par
}
}
{\xe \v display_test_graph\:graph_test.c}
{\xe \v graph_test.c\:display_test_graph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void display_test_graph ({\b C_str}  {\i cmd}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Static routine to send gnuplot system command string, with the aim of printing graphical data contained inside .dat files. In case command is the one to print graph and highlight the shortest-path, call a specific function ({\b build_shortest_path_graphics_data()}) to manipulate gnuplot data and graphically recreate the min cost path. Gnuplot system commands listed below:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Plot graph} : calls gnuplot and load plotting command in .cmd file ({\b graph_plot.cmd}, defined with a macro: {\b GPLOT_TEST_GRAPH_LAYOUT_CMD}), in order to plot: arches, arch-costs and nodes in graph.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Plot graph with shortest-path} : calls gnuplot and load plotting command in .cmd file ({\b shortest_plot.cmd}, defined with a macro: {\b GPLOT_SHORTEST_PATH_CMD}), in order to plot: arches, arch-costs and nodes in graph highlighting the shortest path.\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i cmd} \cell }{Display test-graph gnuplot system command string.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 399 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00399                                          \{                                                                  {\cf20 // Routine to display test-graph through gnuplot}\par
00400   {\cf20 /* Body */}\par
00401   fbk_gn_pu({\cf22 "Close gnuplot to continue graph-library test..."}); fbk_nl(1);                                  {\cf20 // Print close gnuplot to continue fbk}\par
00402   {\cf19 if} (strcmp(cmd, GPLOT_SHORTEST_PATH_CMD) == 0)                                                            {\cf20 // If display command request min path}\par
00403     build_shortest_path_graphics_data();                                                                    {\cf20 // Routine call to build the shortest-path graphics data for gnuplot}\par
00404   fflush(stdout);                                                                                           {\cf20 // Force fbk print b4 openin' gnuplot}\par
00405   {\cf18 int} ret_val = system(cmd);                                                                                {\cf20 // Display test-graph layout with gnuplot}\par
00406   {\cf19 if} (ret_val == 0)\{                                                                                        {\cf20 // Chack command return val, if ok}\par
00407     fbk_nl(1);  fbk_gn_cy({\cf22 "Test-graph layout correctly displayed with gnuplot!\\n"});                         {\cf20 // Test-graph layout correctly displayed with gnuplot fbk}\par
00408   \} {\cf19 else}                                                                                                    {\cf20 // Else if command return val ain't ok}\par
00409     fbk_err({\cf22 "Ops! Encountred error during gnuplot command execution, make sure to have gnuplot installed"}); {\cf20 // Error fbk}\par
00410 \}\par
}
}
{\xe \v main\:graph_test.c}
{\xe \v graph_test.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Main software routine to dynamically allocate a test-graph, asking for graph-library test mode, (eventually) displaying results and graphichs through gnuplot and finally clearing allocated memory inside heap.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 486 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00486           \{                                                                                                 {\cf20 // Main SW cycle}\par
00487   {\cf20 /* Main vars */}\par
00488   Test_choice choice = 0;                                                                                   {\cf20 // Test choice var}\par
00489 \par
00490   {\cf20 /* Code */}\par
00491   signal(SIGINT, terminate_keyboard);                                                                       {\cf20 // Manage program exit from keyboard ctrl+c shortcut}\par
00492   logo(6, {\cf22 "GRAPHS MANAGEMENT LIBRARY TEST SOFTWARE"}, LBU, {\cf23 '#'}, OG);                                         {\cf20 // Print responsive-logo function call (start_spaces, text, txt_color, background_char, bkgchr_color)}\par
00493   press_enter({\cf22 "Hi"});                                                                                        {\cf20 // Press enter to start SW fbk}\par
00494 \par
00496   {\cf20 //                                          LIBRARY TEST SOFTWATRE                                        // --> TEST BEGIN}\par
00498 {\cf20 }  {\cf20 // (1.1) Create some archs                                                                                // --------------------------------------------------------- (1.1)}\par
00499   fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                                   {\cf20 // Print separator fbk}\par
00500   fbk_nl(1);  fbk_gn_pu({\cf22 "(1.1) Creatin' some archs..."});                                                    {\cf20 // Print creatin' archs fbk}\par
00501   fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                        {\cf20 // Print separator fbk}\par
00502   create_archs();                                                                                           {\cf20 // Routine call to create archs}\par
00503   {\cf20 // (1.2) Create some nodes                                                                                // --------------------------------------------------------- (1.2)}\par
00504   fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                                   {\cf20 // Print separator fbk}\par
00505   fbk_nl(1);  fbk_gn_pu({\cf22 "(1.2) Creatin' some nodes..."});                                                    {\cf20 // Print creatin' nodes fbk}\par
00506   fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                        {\cf20 // Print separator fbk}\par
00507   create_nodes();                                                                                           {\cf20 // Routine call to create nodes}\par
00508   {\cf20 // (2.1) Connect archs & nodes (excluding node "Cross10")                                                 // --------------------------------------------------------- (2.1)}\par
00509   fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                                   {\cf20 // Print separator fbk}\par
00510   fbk_nl(1);  fbk_gn_pu({\cf22 "(2.1) Connectin' archs & nodes..."});                                               {\cf20 // Print connectin' archs and nodes fbk}\par
00511   fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                        {\cf20 // Print separator fbk}\par
00512   create_connections();                                                                                     {\cf20 // Routine call to create connections btwn archs & nodes}\par
00513   {\cf20 // (2.2) Test mode choice                                                                                 // --------------------------------------------------------- (2.2)}\par
00514   fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                                   {\cf20 // Print separator fbk}\par
00515   fbk_nl(1);  fbk_gn_pu({\cf22 "(2.2) Testin' mode choice..."});                                                    {\cf20 // Print testin' mode choice fbk}\par
00516   fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                        {\cf20 // Print separator fbk}\par
00517   test_option_choice(&choice);                                                                              {\cf20 // Routine call to choose testing option}\par
00518   {\cf19 if} (choice == PREPARED || choice == PERSONALIZED)\{                                                        {\cf20 // If exit mode ain't been selected}\par
00519     {\cf20 // (2.3) Display test-graph layout with gnuplot                                                         // --------------------------------------------------------- (2.3)}\par
00520     fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                                 {\cf20 // Print separator fbk}\par
00521     fbk_nl(1);  fbk_gn_pu({\cf22 "(2.3) Displayin' test-graph layout with gnuplot..."});                            {\cf20 // Print displayin' test-graph layout with gnuplot fbk}\par
00522     fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                      {\cf20 // Print separator fbk}\par
00523     display_test_graph(GPLOT_TEST_GRAPH_LAYOUT_CMD);                                                        {\cf20 // Routine call to display test-graph through gnuplot}\par
00524   \}                                                                                                         {\cf20 //}\par
00525   {\cf20 // (3.1) Apply Dijkstra's algorithm and find min parh                                                     //}\par
00526   {\cf19 switch} (choice)\{                                                                                          {\cf20 // Testin' option switch-case}\par
00527     {\cf19 case} PREPARED:                                                                                          {\cf20 // Option [1] -> Prepared test (requires gnuplot)}\par
00528       {\cf20 // (3.1.1) Apply Dijkstra's algorithm (from Cross4)                                                   // --------------------------------------------------------- (3.1.1)}\par
00529       fbk_nl(2);  fbk_separator(SEP_CHR, OG); fbk_nl(1);                                                    {\cf20 // Print separator fbk}\par
00530       fbk_gn_pu({\cf22 "(3.1.1) Applyin' Dijkstra's algorithm to find min paths from \\"Cross4\\" source node..."});  {\cf20 // Print applyin' Dijkstra's algorithm to find min paths fbk}\par
00531       fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                    {\cf20 // Print separator fbk}\par
00532       apply_dijkstra(SOURCE_NODE_NAME);                                                                     {\cf20 // Routine call to apply Dijkstra's algorithm}\par
00533       {\cf20 // (3.2.1) Reconstruct test min path (from Cross4 to Cross9)                                          // --------------------------------------------------------- (3.2.1)}\par
00534       fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                               {\cf20 // Print separator fbk}\par
00535       fbk_nl(1);  fbk_gn_pu({\cf22 "(3.2.1) Reconstructin' test min path (Cross4-Cross9) with delays..."});         {\cf20 // Print reconstructin' test min path fbk}\par
00536       fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                    {\cf20 // Print separator fbk}\par
00537       reconstruct_min_path(DESTINATION_NODE_NAME);                                                          {\cf20 // Routine call to reconstruct min path}\par
00538       {\cf20 // (3.3.1) Display test-graph layout and shortest path with gnuplot (from Cr4 to Cr9)                 // --------------------------------------------------------- (3.3.1)}\par
00539       {\cf19 if} (min_pth_conn_vect_size > 1)\{                                                                      {\cf20 // If min path contains at least src and dest nodes}\par
00540         fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                             {\cf20 // Print separator fbk}\par
00541         fbk_nl(1);  fbk_gn_pu({\cf22 "(3.3.1) Displayin' test-graph and shortest path with gnuplot (Cr4-Cr9)..."}); {\cf20 // Print displayin' test-graph layout and shortest path with gnuplot fbk}\par
00542         fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                  {\cf20 // Print separator fbk}\par
00543         display_test_graph(GPLOT_SHORTEST_PATH_CMD);                                                        {\cf20 // Routine call to display test-graph through gnuplot}\par
00544       \}                                                                                                     {\cf20 //}\par
00545       {\cf20 // (3.4.1) Reconstruct some special-cases paths (Cr4-Cr4 and Cr4-Cr10)                                // --------------------------------------------------------- (3.4.1)}\par
00546       fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                               {\cf20 // Print separator fbk}\par
00547       fbk_nl(1);  fbk_gn_pu({\cf22 "(3.4.1) Reconstructin' some special-cases paths (Cr4-Cr4 and Cr4-Cr10)..."});   {\cf20 // Print reconstructin' some special-cases paths fbk}\par
00548       fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                    {\cf20 // Print separator fbk}\par
00549       reconstruct_min_path(DEST_NODE_NAME_SPECIAL_CASE1);                                                   {\cf20 // Routine call to reconstruct min path}\par
00550       reconstruct_min_path(DEST_NODE_NAME_SPECIAL_CASE2);                                                   {\cf20 // Routine call to reconstruct min path}\par
00551       {\cf19 break};                                                                                                {\cf20 //}\par
00553 {\cf20 }    {\cf19 case} PERSONALIZED:                                                                                      {\cf20 // Option [2] -> Personalized test (requires gnuplot)}\par
00554       {\cf20 // (3.1.2) Apply Dijkstra's algorithm                                                                 // --------------------------------------------------------- (3.1.2)}\par
00555       fbk_nl(2);  fbk_separator(SEP_CHR, OG); fbk_nl(1);                                                    {\cf20 // Print separator fbk}\par
00556       fbk_gn_pu({\cf22 "(3.1.2) Applyin' Dijkstra's algorithm to find min paths from specified source node..."});   {\cf20 // Print applyin' Dijkstra's algorithm to find min paths fbk}\par
00557       fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                    {\cf20 // Print separator fbk}\par
00558       {\cf18 char}* src_nd_nm = NULL;                                                                               {\cf20 // Personalized source-node name str init}\par
00559       define_src_node_name(&src_nd_nm);                                                                     {\cf20 // Routine call to define presonalized source-node name}\par
00560       apply_dijkstra(src_nd_nm);                                                                            {\cf20 // Routine call to apply Dijkstra's algorithm}\par
00561       {\cf20 // (3.2.2) Reconstruct test min path                                                                  // --------------------------------------------------------- (3.2.2)}\par
00562       fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                               {\cf20 // Print separator fbk}\par
00563       fbk_nl(1);  fbk_gn_pu({\cf22 "(3.2.2) Reconstructin' requested min path with delays..."});                    {\cf20 // Print reconstructin' requested min path fbk}\par
00564       fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                    {\cf20 // Print separator fbk}\par
00565       {\cf18 char}* dest_nd_nm = NULL;                                                                              {\cf20 // Personalized destination-node name str init}\par
00566       define_dest_node_name(&dest_nd_nm);                                                                   {\cf20 // Routine call to define presonalized destination-node name}\par
00567       reconstruct_min_path(dest_nd_nm);                                                                     {\cf20 // Routine call to reconstruct min path}\par
00568       {\cf20 // (3.3.2) Display test-graph layout and shortest path with gnuplot                                   // --------------------------------------------------------- (3.3.2)}\par
00569       {\cf19 if} (min_pth_conn_vect_size > 1)\{                                                                      {\cf20 // If min path contains at least src and dest nodes}\par
00570         fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                             {\cf20 // Print separator fbk}\par
00571         fbk_nl(1);  fbk_gn_pu({\cf22 "(3.3.2) Displayin' test-graph and shortest path with gnuplot..."});           {\cf20 // Print displayin' test-graph layout and shortest path with gnuplot fbk}\par
00572         fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                  {\cf20 // Print separator fbk}\par
00573         display_test_graph(GPLOT_SHORTEST_PATH_CMD);                                                        {\cf20 // Routine call to display test-graph through gnuplot}\par
00574       \}                                                                                                     {\cf20 //}\par
00575       {\cf19 break};                                                                                                {\cf20 //}\par
00577 {\cf20 }    {\cf19 default}:                                                                                                {\cf20 // Unknown option (avoid compile errors)}\par
00578       {\cf19 break};                                                                                                {\cf20 //}\par
00579   \}                                                                                                         {\cf20 //}\par
00580   {\cf20 // (4.1) Deallocate the whole graph structure                                                             // --------------------------------------------------------- (4.1)}\par
00581   fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                                   {\cf20 // Print separator fbk}\par
00582   fbk_nl(1);  fbk_gn_pu({\cf22 "(4.1) Deallocatin' the whole graph structure..."});                                 {\cf20 // Print clearin' the whole graph structre fbk}\par
00583   fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                        {\cf20 // Print separator fbk}\par
00584   free_graph();                                                                                             {\cf20 // Clear graph structure from heap and reset some flags to be able to use again lib functions}\par
00586 {\cf20 }  {\cf20 //                                          LIBRARY TEST SOFTWATRE                                        // --> TEST END}\par
00588 {\cf20 }\par
00589   close_fbk();                                                                                              {\cf20 // Close SW with fbk}\par
00590   {\cf19 return} EXIT_SUCCESS;                                                                                      {\cf20 // Check errors --> if=0 (NO ERRORS) / if=1 (ERRORS)}\par
00591 \}\par
}
}
{\xe \v reconstruct_min_path\:graph_test.c}
{\xe \v graph_test.c\:reconstruct_min_path}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void reconstruct_min_path ({\b C_str}  {\i dest_nd_name}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Static routine to reconstruct min-cost path with verbose-mode enabled, towards specified destination node (from source node defined when calling Dijkstra's algoritm; destination node selected by-name, checking if node is contained in nodes collection). Find out if a specific possible destination node is unreachble, or if it corresponds to the source node.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i dest_nd_name} \cell }{Destination node name towards which min-cost path must be reconstructed (backwards).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 435 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00435                                                     \{                                                       {\cf20 // Routine to reconstruct min path}\par
00436   {\cf20 /* Body */}\par
00437   buid_shortest_path(dest_nd_name, VERBOSE);                                                                {\cf20 // Reconstruct min path to defined destination node startin' from pre-defined source node, (min path connections vect allocated/reallocated inside heap) - Y/N for verbose mode}\par
00438 \}\par
}
}
{\xe \v terminate_keyboard\:graph_test.c}
{\xe \v graph_test.c\:terminate_keyboard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void terminate_keyboard (int  {\i signal}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Static routine to manage close keyboard interrupt signal printing feedback to terminal.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i signal} \cell }{Keyboard interrupt signal\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 152 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00152                                           \{                                                                 {\cf20 // Manage program exit from keyboard ctrl+c shortcut}\par
00153   {\cf20 /* Body */}\par
00154   close_keyboard_interrupt(signal);                                                                         {\cf20 // Close SW with fbk due to keyboard interrupt detected (ctrl+c)}\par
00155 \}\par
}
}
{\xe \v test_option_choice\:graph_test.c}
{\xe \v graph_test.c\:test_option_choice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void test_option_choice ({\b Test_choice} *const  {\i choice}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Static routine to give give to the user the possibility to choose a testing option, using pre-defined graph dynamically generated with graph-library functions:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Prepared test} : find shortest path from 'Cross4' to 'Cross9' nodes (defined with macros {\b SOURCE_NODE_NAME} and {\b DESTINATION_NODE_NAME}), applying Dijkstra's algorithm. In addition, show two special cases: shortest path from 'Cross4' to 'Cross4' (source = destination) and from 'Cross4' to 'Cross10' (unreachble node). In conclusion clear dynamic memory allocated inside heap. This option requires gnuplot to display graphical data.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Personalized test} : find shortest path from user-defined source and destination nodes, applying Dijkstra's algorithm. In conclusion clear dynamic memory allocated inside heap. This option requires gnuplot to display graphical data.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Close test software} : clear dynamic memory allocated inside heap and close test software.\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i choice} \cell }{Option chosen by the user (enum).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 229 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00229                                                          \{                                                  {\cf20 // Routine to choose testing option}\par
00230   {\cf20 /* Body */}\par
00231   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "[1]"}, {\cf22 "Prepared test (requires gnuplot)"});                                 {\cf20 // Print opt 1 fbk}\par
00232   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "[2]"}, {\cf22 "Personalized test (requires gnuplot)"});                             {\cf20 // Print opt 2 fbk}\par
00233   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "[3]"}, {\cf22 "Exit"}); fbk_nl(1);                                                  {\cf20 // Print opt 3 fbk}\par
00234   *choice = (Byte)read_term_in_int_inrange(1, 3, {\cf22 "Choose a testing option"}, {\cf22 "Error! Option"});               {\cf20 // Print opt choice fbk}\par
00235   {\cf19 switch} (*choice)\{                                                                                         {\cf20 // Testin' option switch-case}\par
00236     {\cf19 case} PREPARED:                                                                                          {\cf20 // Option [1] -> Prepared test (requires gnuplot)}\par
00237       fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Choosen option"}, {\cf22 "[1] -> Prepared test (requires gnuplot)"});           {\cf20 // Print choosen opt fbk}\par
00238       {\cf19 break};\par
00240     {\cf19 case} PERSONALIZED:                                                                                      {\cf20 // Option [2] -> Personalized test (requires gnuplot)}\par
00241       fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Choosen option"}, {\cf22 "[2] -> Personalized test (requires gnuplot)"});       {\cf20 // Print choosen opt fbk}\par
00242       {\cf19 break};\par
00244     {\cf19 case} EXIT:                                                                                              {\cf20 // Option [3] -> Exit}\par
00245       fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Choosen option"}, {\cf22 "[3] -> Exit"}); fbk_nl(1);                            {\cf20 // Print choosen opt fbk}\par
00246       Confirm answ = read_term_in_confirm({\cf22 "Are you sure you want to close test software"});                  {\cf20 // Ask confirm}\par
00247       {\cf19 switch} (answ)\{                                                                                        {\cf20 // Confirm answ switch-case}\par
00248         {\cf19 case} YES:                                                                                           {\cf20 // YES answer}\par
00249           {\cf19 break};\par
00251         {\cf19 case} NO:                                                                                            {\cf20 // NO answer}\par
00252           test_option_choice(choice);                                                                       {\cf20 // Go back}\par
00253           {\cf19 break};\par
00255         {\cf19 case} CANCEL:                                                                                        {\cf20 // CANCEL answer}\par
00256           test_option_choice(choice);                                                                       {\cf20 // Go back}\par
00257           {\cf19 break};\par
00259         {\cf19 default}:                                                                                            {\cf20 // Unknown answer}\par
00260           fbk_err({\cf22 "Error, bad confirmation answer"});                                                        {\cf20 // Print error fbk}\par
00261           perror({\cf22 "Bad confirmation answer, 'read_term_in_confirm()' requires 'Confirm' data-type!"});        {\cf20 // Print perror fbk}\par
00262           close_err();                                                                                      {\cf20 // Close with error fbk}\par
00263       \}\par
00264       {\cf19 break};\par
00266     {\cf19 default}:                                                                                                {\cf20 // Unknown option}\par
00267       fbk_err({\cf22 "Error, bad testing option value"});                                                           {\cf20 // Print error fbk}\par
00268       perror({\cf22 "Testing option value out of range, check 'read_term_in_int_inrange()' parameter-values!"});    {\cf20 // Print perror fbk}\par
00269       close_err();                                                                                          {\cf20 // Close with error fbk}\par
00270   \}\par
00271 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v crss_names_vect\:graph_test.c}
{\xe \v graph_test.c\:crss_names_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b C_str} crss_names_vect[]}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{{\cf22 "Cross1"}, {\cf22 "Cross2"}, {\cf22 "Cross3"}, {\cf22 "Cross4"}, {\cf22 "Cross5"}, {\cf22 "Cross6"}, {\cf22 "Cross7"},\par
   {\cf22 "Cross8"}, {\cf22 "Cross9"}, {\cf22 "Cross10"}\}\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Global-variable description:}  Cross-names vector (to dynamically initalize nodes). }}\par
{
Definition at line 140 of file graph_test.c.}\par
}
{\xe \v strts_vect\:graph_test.c}
{\xe \v graph_test.c\:strts_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Street} strts_vect[]}}
\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\{{\cf22 "Street1"},1.1\}, \{{\cf22 "Street2"},2.2\}, \{{\cf22 "Street3"},3.3\}, \{{\cf22 "Street4"},4.4\}, \par
   \{{\cf22 "Street5"},5.5\}, \{{\cf22 "Street6"},6.6\}, \{{\cf22 "Street7"},7.7\}, \{{\cf22 "Street8"},8.8\},\par
   \{{\cf22 "Street9"},6.3\}, \{{\cf22 "Street10"},0.2\}, \{{\cf22 "Street11"},9.3\}, \{{\cf22 "Street12"},7.1\},\par
   \{{\cf22 "Street13"},12.8\}\}\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Global-variable description:}  Street-structs vector (to dynamically initalize archs). }}\par
{
Definition at line 135 of file graph_test.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
main/graph_test.o File Reference\par \pard\plain 
{\tc\tcl2 \v main/graph_test.o}
{\xe \v main/graph_test.o}
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
makefile File Reference\par \pard\plain 
{\tc\tcl2 \v makefile}
{\xe \v makefile}
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}