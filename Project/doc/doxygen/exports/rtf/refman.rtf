{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment Dijkstra's algorithm project  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
3.0 \par
}}Dijkstra's algorithm project}
{\comment Generated by doxygen.}
{\creatim \yr2021\mo7\dy15\hr17\min43\sec30}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt Dijkstra's algorithm project}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 3.0\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Thu Jul 15 2021 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Main Page\par \pard\plain 
{\tc \v Main Page}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 {\b Project about graphs and Dijkstra's algorithm:} } \par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 {\b Project content:} } \par}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 {\b Libraries:} } \par}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Graph} : library for graphs management and minimum cost path with Dijkstra's algorithm.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UI} : GUI (terminal I/O) library to print logo and coloured terminal feedbacks.\par}
\par{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 {\b Main} } \par}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Graph_test} : main test software to create a small graph and test Dijkstra's algorithm to find minimum cost path.\par}
\par{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 {\b Makefile} } \par}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Compile commands} :{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b make} : command to compile and link the whole project to executable (shortcut command).\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b make all} : same command as above, extended command.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b make run} : command to launch\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b make all_run} : command to compile/link the whole project to executable and run it.\par}
}
\par{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 {\b Project folders:} } \par}
\~.\par
 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b README.md}\par
 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 doc\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 abstract\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 abstract.aux\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 abstract.fdb_latexmk\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 abstract.fls\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 abstract.log\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b abstract.pdf} \par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 abstract.synctex.gz\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 abstract.tex\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 abstract.tex\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 doxygen\par
 \'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 doxygen_config\par
 \'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 exports\par
 \'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b html} \par
 \'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 rtf\par
 \'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 src\par
 \'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 logo.png\par
 \'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 sw\par
 \~\~\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 gnuplot\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b archs.dat}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b costs.dat}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 exports\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 imgs\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 pdf\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b graph_plot.cmd}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b nodes.dat}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b shortest_archs.dat}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b shortest_costs.dat}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b shortest_nodes.dat}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b shortest_plot.cmd}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 {\b src_dest_nodes.dat}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 lib\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 files\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b lib_files.c}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b lib_files.h}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 {\b lib_files.so}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 graph\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b lib_graph.c}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b lib_graph.h}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 {\b lib_graph.so}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 timer\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b lib_timer.c}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b lib_timer.h}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 {\b lib_timer.so}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 ui\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b lib_ui.c}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b lib_ui.h}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 {\b lib_ui.so}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 main\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b graph_test.c}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 {\b graph_test.o}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b graph_test} \par
 \~\~\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 {\b makefile} \par
18 directories, 35 files \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
General notes{\tc \v General notes}\par \pard\plain 
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dijkstra's algorithm library test-software.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Cristian Merli \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
15/07/2021 \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
3.0 - Completed 15/05/2021\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Important notes:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Graphical effects are managed by gnuplot (based on data manipulated by test software main program), so it is highly recommended to have it installed.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
It is possibile to compile, run and execute further actions tacking advantege of makefile, for more informations see doxygen 'Main page' or {\b README.md} file. \par}
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
- Pay attention, arch/node names must only be max 30 chars long. To modify max names lenght, change relative macros inside '{\b lib_graph.h}' header file.{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
. \par}
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Bug:\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid No known bugs.\par
}
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Code title:
\par}
{\tc\tcl2 \v Code title:}
Polynomial interpolation with Newton algorithm and divided-differences.\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Code details:
\par}
{\tc\tcl3 \v Code details:}
Polynomial interpolation C code --> Newton algorithm with divided-differences to interpolate 'till 170 points, polynomial evaluation in given points and derivate calculation. \par}
\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Test-page{\tc \v Test-page}\par \pard\plain 
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'97. \par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Code title:
\par}
{\tc\tcl2 \v Code title:}
\'97.\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Code details:
\par}
{\tc\tcl3 \v Code details:}
Polynomial interpolation C code --> Newton algorithm with divided-differences to interpolate 'till 170 points, polynomial evaluation in given points and derivate calculation. \par}
\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Bug List{\tc \v Bug List}\par \pard\plain 
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Page {\b General notes}  \par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
No known bugs.\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Index\par \pard\plain 
{\tc \v Data Structure Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Data Structures\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the data structures with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b arch} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b connection} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAME \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b date_time} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b dijkstra_dataset} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b list_elem} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b node} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b street} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b graph_test} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b makefile} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b archs.dat} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b costs.dat} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b graph_plot.cmd} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b nodes.dat} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b shortest_archs.dat} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b shortest_costs.dat} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b shortest_nodes.dat} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b shortest_plot.cmd} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b src_dest_nodes.dat} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/files/{\b lib_files.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/files/{\b lib_files.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/files/{\b lib_files.so} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/graph/{\b lib_graph.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/graph/{\b lib_graph.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/graph/{\b lib_graph.so} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/timer/{\b lib_timer.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/timer/{\b lib_timer.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/timer/{\b lib_timer.so} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/ui/{\b lib_ui.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/ui/{\b lib_ui.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/ui/{\b lib_ui.so} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b main/{\b graph_test.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\par}
\par})} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b main/{\b graph_test.o} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Documentation{\tc \v Data Structure Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
arch Struct Reference\par \pard\plain 
{\tc\tcl2 \v arch}
{\xe \v arch}
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
\par
{
{\f2 #include <lib_graph.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b name} [{\b AR_STR_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Graph_node} {\b nd1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Real} {\b cost}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Graph_node} {\b nd2}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 40 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v cost\:arch}
{\xe \v arch\:cost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Real} arch::cost}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file lib_graph.h.}\par
}
{\xe \v name\:arch}
{\xe \v arch\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char arch::name[{\b AR_STR_LEN}]}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file lib_graph.h.}\par
}
{\xe \v nd1\:arch}
{\xe \v arch\:nd1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Graph_node} arch::nd1}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file lib_graph.h.}\par
}
{\xe \v nd2\:arch}
{\xe \v arch\:nd2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Graph_node} arch::nd2}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/graph/{\b lib_graph.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
connection Struct Reference\par \pard\plain 
{\tc\tcl2 \v connection}
{\xe \v connection}
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
\par
{
{\f2 #include <lib_graph.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Graph_node} {\b nd}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Graph_arch} {\b ar}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 55 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v ar\:connection}
{\xe \v connection\:ar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Graph_arch} connection::ar}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file lib_graph.h.}\par
}
{\xe \v nd\:connection}
{\xe \v connection\:nd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Graph_node} connection::nd}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/graph/{\b lib_graph.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
date_time Struct Reference\par \pard\plain 
{\tc\tcl2 \v date_time}
{\xe \v date_time}
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
\par
{
{\f2 #include <lib_timer.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b yyyy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mn}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b dd}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b hh}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mm}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ss}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 34 of file lib_timer.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v dd\:date_time}
{\xe \v date_time\:dd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int date_time::dd}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file lib_timer.h.}\par
}
{\xe \v hh\:date_time}
{\xe \v date_time\:hh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int date_time::hh}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file lib_timer.h.}\par
}
{\xe \v mm\:date_time}
{\xe \v date_time\:mm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int date_time::mm}}
\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file lib_timer.h.}\par
}
{\xe \v mn\:date_time}
{\xe \v date_time\:mn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int date_time::mn}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file lib_timer.h.}\par
}
{\xe \v ss\:date_time}
{\xe \v date_time\:ss}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int date_time::ss}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file lib_timer.h.}\par
}
{\xe \v yyyy\:date_time}
{\xe \v date_time\:yyyy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int date_time::yyyy}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file lib_timer.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/timer/{\b lib_timer.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
dijkstra_dataset Struct Reference\par \pard\plain 
{\tc\tcl2 \v dijkstra_dataset}
{\xe \v dijkstra_dataset}
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
\par
{
{\f2 #include <lib_graph.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Graph_node} {\b prev_nd}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Real} {\b min_path_cost}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Byte} {\b an_flg}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 49 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v an_flg\:dijkstra_dataset}
{\xe \v dijkstra_dataset\:an_flg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Byte} dijkstra_dataset::an_flg}}
\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file lib_graph.h.}\par
}
{\xe \v min_path_cost\:dijkstra_dataset}
{\xe \v dijkstra_dataset\:min_path_cost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Real} dijkstra_dataset::min_path_cost}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 51 of file lib_graph.h.}\par
}
{\xe \v prev_nd\:dijkstra_dataset}
{\xe \v dijkstra_dataset\:prev_nd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Graph_node} dijkstra_dataset::prev_nd}}
\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/graph/{\b lib_graph.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
list_elem Struct Reference\par \pard\plain 
{\tc\tcl2 \v list_elem}
{\xe \v list_elem}
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
\par
{
{\f2 #include <lib_graph.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b arch} * {\b ar}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b list_elem} * {\b nxt}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 25 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v ar\:list_elem}
{\xe \v list_elem\:ar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b arch}* list_elem::ar}}
\par
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file lib_graph.h.}\par
}
{\xe \v nxt\:list_elem}
{\xe \v list_elem\:nxt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b list_elem}* list_elem::nxt}}
\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 27 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/graph/{\b lib_graph.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
node Struct Reference\par \pard\plain 
{\tc\tcl2 \v node}
{\xe \v node}
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
\par
{
{\f2 #include <lib_graph.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b name} [{\b ND_STR_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b List} {\b archs_lst}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dijkstra_dataset} * {\b dd}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 32 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v archs_lst\:node}
{\xe \v node\:archs_lst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b List} node::archs_lst}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file lib_graph.h.}\par
}
{\xe \v dd\:node}
{\xe \v node\:dd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b dijkstra_dataset}* node::dd}}
\par
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file lib_graph.h.}\par
}
{\xe \v name\:node}
{\xe \v node\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char node::name[{\b ND_STR_LEN}]}}
\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/graph/{\b lib_graph.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
street Struct Reference\par \pard\plain 
{\tc\tcl2 \v street}
{\xe \v street}
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b C_char} {\b name} [{\b AR_STR_LEN}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b C_real} {\b length}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 97 of file graph_test.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v length\:street}
{\xe \v street\:length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b C_real} street::length}}
\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 99 of file graph_test.c.}\par
}
{\xe \v name\:street}
{\xe \v street\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b C_char} street::name[{\b AR_STR_LEN}]}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 98 of file graph_test.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
main/{\b graph_test.c}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/cristian/Comune/Coding/Project/README.md File Reference\par \pard\plain 
{\tc\tcl2 \v /home/cristian/Comune/Coding/Project/README.md}
{\xe \v /home/cristian/Comune/Coding/Project/README.md}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/archs.dat File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/archs.dat}
{\xe \v gnuplot/archs.dat}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/costs.dat File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/costs.dat}
{\xe \v gnuplot/costs.dat}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/graph_plot.cmd File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/graph_plot.cmd}
{\xe \v gnuplot/graph_plot.cmd}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/nodes.dat File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/nodes.dat}
{\xe \v gnuplot/nodes.dat}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/shortest_archs.dat File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/shortest_archs.dat}
{\xe \v gnuplot/shortest_archs.dat}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/shortest_costs.dat File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/shortest_costs.dat}
{\xe \v gnuplot/shortest_costs.dat}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/shortest_nodes.dat File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/shortest_nodes.dat}
{\xe \v gnuplot/shortest_nodes.dat}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/shortest_plot.cmd File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/shortest_plot.cmd}
{\xe \v gnuplot/shortest_plot.cmd}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/src_dest_nodes.dat File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/src_dest_nodes.dat}
{\xe \v gnuplot/src_dest_nodes.dat}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
graph_test File Reference\par \pard\plain 
{\tc\tcl2 \v graph_test}
{\xe \v graph_test}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/files/lib_files.c File Reference\par \pard\plain 
{\tc\tcl2 \v lib/files/lib_files.c}
{\xe \v lib/files/lib_files.c}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "lib_files.h"}\par
{\f2 #include "../ui/lib_ui.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Fl} {\b open_file} (const char *const filename, const char *const mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_int_on_file} ({\b Fl} file, {\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_str_on_file} ({\b Fl} file, const char *const str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_sep_on_file} ({\b Fl} file, {\b C_char} sep)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_nl_on_file} ({\b Fl} file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_tab_on_file} ({\b Fl} file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b read_from_file} ({\b Fl} file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b get_substr_line_from_file} ({\b Fl} file, const char *const tgt_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b get_line_str_from_file} ({\b Fl} file, {\b C_int} tgt_str_line_num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_file} ({\b Fl} file)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b file_in_buff} [{\b FILE_IN_BUFF_SIZE}] = ""\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v close_file\:lib_files.c}
{\xe \v lib_files.c\:close_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_file ({\b Fl}  {\i file})}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 157 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00157                         \{                                                                                   {\cf20 // Function to close file}\par
00158   {\cf20 /* Body */}\par
00159   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00160     C_int res = fclose(file);                                                                               {\cf20 // Close file}\par
00161     {\cf19 if} (res == EOF)\{                                                                                        {\cf20 // Check file close operation result}\par
00162       fbk_err({\cf22 "Ops! Encountred error during file close operation"});                                         {\cf20 // Print error fbk}\par
00163       perror({\cf22 "File close operation failed!"});                                                               {\cf20 // Print perror fbk}\par
00164     \}\par
00165   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00166     fbk_err({\cf22 "Ops! Null-file found during file-close operation"});                                            {\cf20 // Print error fbk}\par
00167     perror({\cf22 "File close operation failed!"});                                                                 {\cf20 // Print perror fbk}\par
00168   \}\par
00169 \}\par
}
}
{\xe \v get_line_str_from_file\:lib_files.c}
{\xe \v lib_files.c\:get_line_str_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* get_line_str_from_file ({\b Fl}  {\i file}, {\b C_int}  {\i tgt_str_line_num})}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 140 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00140                                                              \{                                              {\cf20 // Function to get line-string from file (by target-string line number, returns NULL for no-match found or error)}\par
00141   {\cf20 /* Body */}\par
00142   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00143     {\cf18 int} line_num = 0;                                                                                       {\cf20 // Line number counter}\par
00144     {\cf19 while} ( fgets(file_in_buff, FILE_IN_BUFF_SIZE, file) != NULL )\{                                         {\cf20 // In case of file found, scan lines 'till null line (last one)}\par
00145       ++line_num;                                                                                           {\cf20 // Line number val upd}\par
00146       {\cf19 if} (line_num == tgt_str_line_num)                                                                     {\cf20 // Scroll 'till target-string line number}\par
00147         {\cf19 return} file_in_buff;                                                                                {\cf20 // Return current line content as str}\par
00148     \}\par
00149   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00150     fbk_err({\cf22 "Ops! Null-file found during line-string returning operation (by line number)"});                {\cf20 // Print error fbk}\par
00151     perror({\cf22 "File line-string returning operation (by line number) failed!"});                                {\cf20 // Print perror fbk}\par
00152   \}\par
00153   {\cf19 return} NULL;                                                                                              {\cf20 // Return NULL for no-match found or error}\par
00154 \}\par
}
}
{\xe \v get_substr_line_from_file\:lib_files.c}
{\xe \v lib_files.c\:get_substr_line_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int get_substr_line_from_file ({\b Fl}  {\i file}, const char *const  {\i tgt_str})}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 123 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00123                                                                  \{                                          {\cf20 // Function to get sub-string line number from file (by target-string, returns -1 for no-match found or error)}\par
00124   {\cf20 /* Body */}\par
00125   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00126     {\cf18 int} line_num = 0;                                                                                       {\cf20 // Line number counter}\par
00127     {\cf19 while} ( fgets(file_in_buff, FILE_IN_BUFF_SIZE, file) != NULL )\{                                         {\cf20 // In case of file found, scan lines 'till null line (last one)}\par
00128       ++line_num;                                                                                           {\cf20 // Line number val upd}\par
00129       {\cf19 if} (strstr(file_in_buff, tgt_str) != NULL)                                                            {\cf20 // Check if substring is in current line}\par
00130         {\cf19 return} line_num;                                                                                    {\cf20 // Return current line-number}\par
00131     \}\par
00132   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00133     fbk_err({\cf22 "Ops! Null-file found during target-substring line number id operation"});                       {\cf20 // Print error fbk}\par
00134     perror({\cf22 "File target-substring line number id operation failed!"});                                       {\cf20 // Print perror fbk}\par
00135   \}\par
00136   {\cf19 return} -1;                                                                                                {\cf20 // Return -1 for no-match found or error}\par
00137 \}\par
}
}
{\xe \v open_file\:lib_files.c}
{\xe \v lib_files.c\:open_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Fl} open_file (const char *const  {\i filename}, const char *const  {\i mode})}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00020                                                                 \{                                           {\cf20 // Function to open file}\par
00021   {\cf20 /* Body */}\par
00022   FILE *file;                                                                                               {\cf20 // Define file obj pointer}\par
00023   file = fopen(filename, mode);                                                                             {\cf20 // Open defined file in specified mode (see the end of code)}\par
00024   {\cf19 if} (file == NULL)\{                                                                                        {\cf20 // Check open file operation result}\par
00025     fbk_err({\cf22 "Ops! Encountred error during file open operation"});                                            {\cf20 // Print error fbk}\par
00026     perror({\cf22 "File open operation failed!"});                                                                  {\cf20 // Print perror fbk}\par
00027   \}\par
00028   {\cf19 return} file;                                                                                              {\cf20 // Return file pointer}\par
00029 \}\par
}
}
{\xe \v read_from_file\:lib_files.c}
{\xe \v lib_files.c\:read_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void read_from_file ({\b Fl}  {\i file})}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 107 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00107                             \{                                                                               {\cf20 // Function to read from file}\par
00108   {\cf20 /* Body */}\par
00109   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00110     fbk_nl(1);                                                                                              {\cf20 // New line fbk}\par
00111     {\cf18 int} line_num = 0;                                                                                       {\cf20 // Line number counter}\par
00112     {\cf19 while} ( fgets(file_in_buff, FILE_IN_BUFF_SIZE, file) != NULL )\{                                         {\cf20 // In case of file found, scan lines 'till null line (last one)}\par
00113       ++line_num;                                                                                           {\cf20 // Line number val upd}\par
00114       printf({\cf22 "%s%d)\\t%s%s"}, BU, line_num, OG, file_in_buff);                                                {\cf20 // Print line number and val fbk}\par
00115     \}\par
00116   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00117     fbk_err({\cf22 "Ops! Null-file found during file-read operation"});                                             {\cf20 // Print error fbk}\par
00118     perror({\cf22 "File read operation failed!"});                                                                  {\cf20 // Print perror fbk}\par
00119   \}\par
00120 \}\par
}
}
{\xe \v write_int_on_file\:lib_files.c}
{\xe \v lib_files.c\:write_int_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_int_on_file ({\b Fl}  {\i file}, {\b C_int}  {\i num})}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00032                                           \{                                                                 {\cf20 // Function to write int on file}\par
00033   {\cf20 /* Body */}\par
00034   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00035     C_int res = fprintf(file, {\cf22 "%d"}, num);                                                                   {\cf20 // Insert number in file}\par
00036     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00037       fbk_err({\cf22 "Ops! Encountred error during int value file write operation"});                               {\cf20 // Print error fbk}\par
00038       perror({\cf22 "File write operation of int value, failed!"});                                                 {\cf20 // Print perror fbk}\par
00039     \}\par
00040   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00041     fbk_err({\cf22 "Ops! Null-file found during int value file write-operation"});                                  {\cf20 // Print error fbk}\par
00042     perror({\cf22 "File write operation of int value, failed!"});                                                   {\cf20 // Print perror fbk}\par
00043   \}\par
00044 \}\par
}
}
{\xe \v write_nl_on_file\:lib_files.c}
{\xe \v lib_files.c\:write_nl_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_nl_on_file ({\b Fl}  {\i file})}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00077                               \{                                                                             {\cf20 // Function to write new line on file}\par
00078   {\cf20 /* Body */}\par
00079   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00080     C_int res = fprintf(file, {\cf22 "\\n"});                                                                        {\cf20 // Insert new line in file}\par
00081     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00082       fbk_err({\cf22 "Ops! Encountred error during new line file write operation"});                                {\cf20 // Print error fbk}\par
00083       perror({\cf22 "File write operation of new line failed!"});                                                   {\cf20 // Print perror fbk}\par
00084     \}\par
00085   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00086     fbk_err({\cf22 "Ops! Null-file found during new line file-write operation"});                                   {\cf20 // Print error fbk}\par
00087     perror({\cf22 "File write operation of new line failed!"});                                                     {\cf20 // Print perror fbk}\par
00088   \}\par
00089 \}\par
}
}
{\xe \v write_sep_on_file\:lib_files.c}
{\xe \v lib_files.c\:write_sep_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_sep_on_file ({\b Fl}  {\i file}, {\b C_char}  {\i sep})}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 62 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00062                                            \{                                                                {\cf20 // Function to write separator on file}\par
00063   {\cf20 /* Body */}\par
00064   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00065     C_int res = fprintf(file, {\cf22 "%c"}, sep);                                                                   {\cf20 // Insert separator in file}\par
00066     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00067       fbk_err({\cf22 "Ops! Encountred error during separator char file write operation"});                          {\cf20 // Print error fbk}\par
00068       perror({\cf22 "File write operation of separator char failed!"});                                             {\cf20 // Print perror fbk}\par
00069     \}\par
00070   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00071     fbk_err({\cf22 "Ops! Null-file found during separator char file-write operation"});                             {\cf20 // Print error fbk}\par
00072     perror({\cf22 "File write operation of separator char failed!"});                                               {\cf20 // Print perror fbk}\par
00073   \}\par
00074 \}\par
}
}
{\xe \v write_str_on_file\:lib_files.c}
{\xe \v lib_files.c\:write_str_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_str_on_file ({\b Fl}  {\i file}, const char *const  {\i str})}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00047                                                       \{                                                     {\cf20 // Function to write string on file}\par
00048   {\cf20 /* Body */}\par
00049   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00050     C_int res = fprintf(file, {\cf22 "%s"}, str);                                                                   {\cf20 // Insert string in file}\par
00051     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00052       fbk_err({\cf22 "Ops! Encountred error during string file write operation"});                                  {\cf20 // Print error fbk}\par
00053       perror({\cf22 "File write operation of string failed!"});                                                     {\cf20 // Print perror fbk}\par
00054     \}\par
00055   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00056     fbk_err({\cf22 "Ops! Null-file found during string file write-operation"});                                     {\cf20 // Print error fbk}\par
00057     perror({\cf22 "File write operation of string failed!"});                                                       {\cf20 // Print perror fbk}\par
00058   \}\par
00059 \}\par
}
}
{\xe \v write_tab_on_file\:lib_files.c}
{\xe \v lib_files.c\:write_tab_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_tab_on_file ({\b Fl}  {\i file})}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 92 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00092                                \{                                                                            {\cf20 // Function to write tab on file}\par
00093   {\cf20 /* Body */}\par
00094   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00095     C_int res = fprintf(file, {\cf22 "\\t"});                                                                        {\cf20 // Insert tab in file}\par
00096     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00097       fbk_err({\cf22 "Ops! Encountred error during tab file write operation"});                                     {\cf20 // Print error fbk}\par
00098       perror({\cf22 "File write operation of tab failed!"});                                                        {\cf20 // Print perror fbk}\par
00099     \}\par
00100   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00101     fbk_err({\cf22 "Ops! Null-file found during tab file-write operation"});                                        {\cf20 // Print error fbk}\par
00102     perror({\cf22 "File write operation of tab failed!"});                                                          {\cf20 // Print perror fbk}\par
00103   \}\par
00104 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v file_in_buff\:lib_files.c}
{\xe \v lib_files.c\:file_in_buff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char file_in_buff[{\b FILE_IN_BUFF_SIZE}] = ""}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file lib_files.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/files/lib_files.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/files/lib_files.h}
{\xe \v lib/files/lib_files.h}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FILE_IN_BUFF_SIZE}\~ 1024\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef FILE * {\b Fl}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Fl} {\b open_file} (const char *const filename, const char *const mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_int_on_file} ({\b Fl} file, const int num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_str_on_file} ({\b Fl} file, const char *const str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_sep_on_file} ({\b Fl} file, const char sep)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_nl_on_file} ({\b Fl} file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_tab_on_file} ({\b Fl} file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b read_from_file} ({\b Fl} file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b get_substr_line_from_file} ({\b Fl} file, const char *const tgt_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b get_line_str_from_file} ({\b Fl} file, const int tgt_str_line_num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_file} ({\b Fl} file)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b file_in_buff} [{\b FILE_IN_BUFF_SIZE}]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v FILE_IN_BUFF_SIZE\:lib_files.h}
{\xe \v lib_files.h\:FILE_IN_BUFF_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FILE_IN_BUFF_SIZE\~ 1024}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file lib_files.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v Fl\:lib_files.h}
{\xe \v lib_files.h\:Fl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef FILE* {\b Fl}}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file lib_files.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v close_file\:lib_files.h}
{\xe \v lib_files.h\:close_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_file ({\b Fl}  {\i file})}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 157 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00157                         \{                                                                                   {\cf20 // Function to close file}\par
00158   {\cf20 /* Body */}\par
00159   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00160     C_int res = fclose(file);                                                                               {\cf20 // Close file}\par
00161     {\cf19 if} (res == EOF)\{                                                                                        {\cf20 // Check file close operation result}\par
00162       fbk_err({\cf22 "Ops! Encountred error during file close operation"});                                         {\cf20 // Print error fbk}\par
00163       perror({\cf22 "File close operation failed!"});                                                               {\cf20 // Print perror fbk}\par
00164     \}\par
00165   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00166     fbk_err({\cf22 "Ops! Null-file found during file-close operation"});                                            {\cf20 // Print error fbk}\par
00167     perror({\cf22 "File close operation failed!"});                                                                 {\cf20 // Print perror fbk}\par
00168   \}\par
00169 \}\par
}
}
{\xe \v get_line_str_from_file\:lib_files.h}
{\xe \v lib_files.h\:get_line_str_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* get_line_str_from_file ({\b Fl}  {\i file}, const int  {\i tgt_str_line_num})}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get_substr_line_from_file\:lib_files.h}
{\xe \v lib_files.h\:get_substr_line_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int get_substr_line_from_file ({\b Fl}  {\i file}, const char *const  {\i tgt_str})}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 123 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00123                                                                  \{                                          {\cf20 // Function to get sub-string line number from file (by target-string, returns -1 for no-match found or error)}\par
00124   {\cf20 /* Body */}\par
00125   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00126     {\cf18 int} line_num = 0;                                                                                       {\cf20 // Line number counter}\par
00127     {\cf19 while} ( fgets(file_in_buff, FILE_IN_BUFF_SIZE, file) != NULL )\{                                         {\cf20 // In case of file found, scan lines 'till null line (last one)}\par
00128       ++line_num;                                                                                           {\cf20 // Line number val upd}\par
00129       {\cf19 if} (strstr(file_in_buff, tgt_str) != NULL)                                                            {\cf20 // Check if substring is in current line}\par
00130         {\cf19 return} line_num;                                                                                    {\cf20 // Return current line-number}\par
00131     \}\par
00132   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00133     fbk_err({\cf22 "Ops! Null-file found during target-substring line number id operation"});                       {\cf20 // Print error fbk}\par
00134     perror({\cf22 "File target-substring line number id operation failed!"});                                       {\cf20 // Print perror fbk}\par
00135   \}\par
00136   {\cf19 return} -1;                                                                                                {\cf20 // Return -1 for no-match found or error}\par
00137 \}\par
}
}
{\xe \v open_file\:lib_files.h}
{\xe \v lib_files.h\:open_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Fl} open_file (const char *const  {\i filename}, const char *const  {\i mode})}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00020                                                                 \{                                           {\cf20 // Function to open file}\par
00021   {\cf20 /* Body */}\par
00022   FILE *file;                                                                                               {\cf20 // Define file obj pointer}\par
00023   file = fopen(filename, mode);                                                                             {\cf20 // Open defined file in specified mode (see the end of code)}\par
00024   {\cf19 if} (file == NULL)\{                                                                                        {\cf20 // Check open file operation result}\par
00025     fbk_err({\cf22 "Ops! Encountred error during file open operation"});                                            {\cf20 // Print error fbk}\par
00026     perror({\cf22 "File open operation failed!"});                                                                  {\cf20 // Print perror fbk}\par
00027   \}\par
00028   {\cf19 return} file;                                                                                              {\cf20 // Return file pointer}\par
00029 \}\par
}
}
{\xe \v read_from_file\:lib_files.h}
{\xe \v lib_files.h\:read_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void read_from_file ({\b Fl}  {\i file})}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 107 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00107                             \{                                                                               {\cf20 // Function to read from file}\par
00108   {\cf20 /* Body */}\par
00109   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00110     fbk_nl(1);                                                                                              {\cf20 // New line fbk}\par
00111     {\cf18 int} line_num = 0;                                                                                       {\cf20 // Line number counter}\par
00112     {\cf19 while} ( fgets(file_in_buff, FILE_IN_BUFF_SIZE, file) != NULL )\{                                         {\cf20 // In case of file found, scan lines 'till null line (last one)}\par
00113       ++line_num;                                                                                           {\cf20 // Line number val upd}\par
00114       printf({\cf22 "%s%d)\\t%s%s"}, BU, line_num, OG, file_in_buff);                                                {\cf20 // Print line number and val fbk}\par
00115     \}\par
00116   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00117     fbk_err({\cf22 "Ops! Null-file found during file-read operation"});                                             {\cf20 // Print error fbk}\par
00118     perror({\cf22 "File read operation failed!"});                                                                  {\cf20 // Print perror fbk}\par
00119   \}\par
00120 \}\par
}
}
{\xe \v write_int_on_file\:lib_files.h}
{\xe \v lib_files.h\:write_int_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_int_on_file ({\b Fl}  {\i file}, const int  {\i num})}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v write_nl_on_file\:lib_files.h}
{\xe \v lib_files.h\:write_nl_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_nl_on_file ({\b Fl}  {\i file})}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00077                               \{                                                                             {\cf20 // Function to write new line on file}\par
00078   {\cf20 /* Body */}\par
00079   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00080     C_int res = fprintf(file, {\cf22 "\\n"});                                                                        {\cf20 // Insert new line in file}\par
00081     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00082       fbk_err({\cf22 "Ops! Encountred error during new line file write operation"});                                {\cf20 // Print error fbk}\par
00083       perror({\cf22 "File write operation of new line failed!"});                                                   {\cf20 // Print perror fbk}\par
00084     \}\par
00085   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00086     fbk_err({\cf22 "Ops! Null-file found during new line file-write operation"});                                   {\cf20 // Print error fbk}\par
00087     perror({\cf22 "File write operation of new line failed!"});                                                     {\cf20 // Print perror fbk}\par
00088   \}\par
00089 \}\par
}
}
{\xe \v write_sep_on_file\:lib_files.h}
{\xe \v lib_files.h\:write_sep_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_sep_on_file ({\b Fl}  {\i file}, const char  {\i sep})}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v write_str_on_file\:lib_files.h}
{\xe \v lib_files.h\:write_str_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_str_on_file ({\b Fl}  {\i file}, const char *const  {\i str})}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00047                                                       \{                                                     {\cf20 // Function to write string on file}\par
00048   {\cf20 /* Body */}\par
00049   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00050     C_int res = fprintf(file, {\cf22 "%s"}, str);                                                                   {\cf20 // Insert string in file}\par
00051     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00052       fbk_err({\cf22 "Ops! Encountred error during string file write operation"});                                  {\cf20 // Print error fbk}\par
00053       perror({\cf22 "File write operation of string failed!"});                                                     {\cf20 // Print perror fbk}\par
00054     \}\par
00055   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00056     fbk_err({\cf22 "Ops! Null-file found during string file write-operation"});                                     {\cf20 // Print error fbk}\par
00057     perror({\cf22 "File write operation of string failed!"});                                                       {\cf20 // Print perror fbk}\par
00058   \}\par
00059 \}\par
}
}
{\xe \v write_tab_on_file\:lib_files.h}
{\xe \v lib_files.h\:write_tab_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_tab_on_file ({\b Fl}  {\i file})}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 92 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00092                                \{                                                                            {\cf20 // Function to write tab on file}\par
00093   {\cf20 /* Body */}\par
00094   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00095     C_int res = fprintf(file, {\cf22 "\\t"});                                                                        {\cf20 // Insert tab in file}\par
00096     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00097       fbk_err({\cf22 "Ops! Encountred error during tab file write operation"});                                     {\cf20 // Print error fbk}\par
00098       perror({\cf22 "File write operation of tab failed!"});                                                        {\cf20 // Print perror fbk}\par
00099     \}\par
00100   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00101     fbk_err({\cf22 "Ops! Null-file found during tab file-write operation"});                                        {\cf20 // Print error fbk}\par
00102     perror({\cf22 "File write operation of tab failed!"});                                                          {\cf20 // Print perror fbk}\par
00103   \}\par
00104 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v file_in_buff\:lib_files.h}
{\xe \v lib_files.h\:file_in_buff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char file_in_buff[{\b FILE_IN_BUFF_SIZE}]}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file lib_files.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/files/lib_files.so File Reference\par \pard\plain 
{\tc\tcl2 \v lib/files/lib_files.so}
{\xe \v lib/files/lib_files.so}
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/graph/lib_graph.c File Reference\par \pard\plain 
{\tc\tcl2 \v lib/graph/lib_graph.c}
{\xe \v lib/graph/lib_graph.c}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "lib_graph.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b iaddr} ({\b C_int} i, {\b C_int} j, {\b C_int} lda)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b List_elem} * {\b allocate_new_list_elems} ({\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b add_elem_at_list_head} ({\b List} *list, {\b List_elem} *const el_to_add)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b add_elem_at_list_pos} ({\b List} *list, {\b List_elem} *const el_to_add, {\b C_int} pos)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b add_elem_at_list_tail} ({\b List} *list, {\b List_elem} *const el_to_add)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b free_list_elems} ({\b List} *list_head, {\b Verbose_mode} v_mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b allocate_new_archs} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b allocate_new_nodes} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b reallocate_new_archs} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b reallocate_new_nodes} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b allocate_new_dijk_dataset_vect} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b reallocate_dijk_dataset_vect} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b Connection} * {\b allocate_new_nd_conn_vect} ({\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b reallocate_nd_conn_vect} ({\b Connection} **nd_conn_vect, {\b C_int} size)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b Connection} * {\b not_an_node_conn} ({\b Node} *nd, int *const vect_size)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b print_min_paths} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b print_shortest_path} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b idx_by_name} ({\b Obj_type} object_type, {\b C_str} object_name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add_new_arch} ({\b C_str} name, {\b C_real} cost)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add_new_node} ({\b C_str} name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b connect_node_arch} ({\b C_str} ar_name, {\b C_str} nd_name, {\b Node_pos_in_arch} nd_pos, {\b Arch_pos_typ} ar_pos,...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dijkstra_alg} ({\b C_str} src_nd_name, {\b Verbose_mode} v_mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b buid_shortest_path} ({\b C_str} dest_nd_name, {\b Verbose_mode} v_mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b free_graph} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Real} {\b _REAL_MAX_} = __DBL_MAX__\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ars_collect_size} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b nds_collect_size} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b min_pth_conn_vect_size} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Arch} * {\b archs_collect_vect} = NULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Node} * {\b nodes_collect_vect} = NULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Connection} * {\b min_path_conn_vect} = NULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b src_node_idx} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b dest_node_idx} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Dijkstra_dataset} * {\b dijk_dataset_vect} = NULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Byte} {\b realloc_flg} = 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v add_elem_at_list_head\:lib_graph.c}
{\xe \v lib_graph.c\:add_elem_at_list_head}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void add_elem_at_list_head ({\b List} *  {\i list}, {\b List_elem} *const  {\i el_to_add}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00056                                                                          \{                                  {\cf20 // Function to add a new element in list (head position)}\par
00057   {\cf20 /* Body */}\par
00058   {\cf19 if} (el_to_add != NULL)\{                                                                                   {\cf20 // Check element to add not null}\par
00059     List tmp_el_head = *list;                                                                               {\cf20 // Copy the old list head addr in tmp var}\par
00060     el_to_add->nxt = NULL;                                                                                  {\cf20 // Set new element as list tail (in case it's the only element in list - head&tail, otherwise connect it to the old head element)}\par
00061     *list = el_to_add;                                                                                      {\cf20 // Set list head addr equal to new elment addr}\par
00062     el_to_add->nxt = tmp_el_head;                                                                           {\cf20 // Reconnect the new element to the list}\par
00063   \} {\cf19 else} \{                                                                                                  {\cf20 // If specified position is less (or equal) than one}\par
00064     fbk_nl(1);  fbk_err({\cf22 "Error, element to add in list must be not null"});                                  {\cf20 // Print error fbk}\par
00065   \}\par
00066 \}\par
}
}
{\xe \v add_elem_at_list_pos\:lib_graph.c}
{\xe \v lib_graph.c\:add_elem_at_list_pos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void add_elem_at_list_pos ({\b List} *  {\i list}, {\b List_elem} *const  {\i el_to_add}, {\b C_int}  {\i pos}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 69 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00069                                                                                    \{                        {\cf20 // Function to add a new element at a specific position of the list (non-zero index)}\par
00070   {\cf20 /* Body */}\par
00071   {\cf19 if} (pos >= 1 && el_to_add != NULL)\{                                                                       {\cf20 // Check specified postion greater (or equal) than one and element to add not null}\par
00072     {\cf19 if} (pos == 1 || *list == NULL)                                                                          {\cf20 // If specified position is equal to one or list is null (empty list)}\par
00073       add_elem_at_list_head(list, el_to_add);                                                               {\cf20 // Add element in list (head position)}\par
00074     {\cf19 else} \{                                                                                                  {\cf20 // Else if specified position is greater than one or list ain't null (list not empty)}\par
00075       List tmp_list = *list;                                                                                {\cf20 // Copy old list in tmp var}\par
00076       {\cf19 for} ({\cf18 int} idx = 1; idx < pos-1 && tmp_list->nxt != NULL; tmp_list = tmp_list->nxt, ++idx);             {\cf20 // Scroll list 'till specified position reached, or tail if position > elements in list}\par
00077       el_to_add->nxt = tmp_list->nxt;                                                                       {\cf20 // Once target position is reached, set new element connection equal to target position element connection}\par
00078       tmp_list->nxt = el_to_add;                                                                            {\cf20 // Set target position element connection equal to new element}\par
00079     \}\par
00080   \} {\cf19 else} \{                                                                                                  {\cf20 // If specified position is less (or equal) than one}\par
00081     fbk_nl(1);                                                                                              {\cf20 // New line fbk}\par
00082     fbk_err({\cf22 "Error, position in list must be greater than one (non-zero index), and element not null"});     {\cf20 // Print error fbk}\par
00083   \}\par
00084 \}\par
}
}
{\xe \v add_elem_at_list_tail\:lib_graph.c}
{\xe \v lib_graph.c\:add_elem_at_list_tail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void add_elem_at_list_tail ({\b List} *  {\i list}, {\b List_elem} *const  {\i el_to_add}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 87 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00087                                                                          \{                                  {\cf20 // Function to add a new element in list (tail position)}\par
00088   {\cf20 /* Body */}\par
00089   {\cf19 if} (el_to_add != NULL)\{                                                                                   {\cf20 // Check element to add not null}\par
00090     {\cf19 if} (*list != NULL)\{                                                                                     {\cf20 // If objects list has been already initialized}\par
00091       List tmp_list = *list;                                                                                {\cf20 // Copy old list in tmp var}\par
00092       {\cf19 for} (; tmp_list->nxt != NULL; tmp_list = tmp_list->nxt);                                              {\cf20 // Scroll the whole list 'till list tail, to find last element}\par
00093       el_to_add->nxt = NULL;                                                                                {\cf20 // Set new element as list tail}\par
00094       tmp_list->nxt = el_to_add;                                                                            {\cf20 // Cotnnect last element to the new element to add}\par
00095     \} {\cf19 else}                                                                                                  {\cf20 // Else if objects list ain't been already initialized}\par
00096       add_elem_at_list_head(list, el_to_add);                                                               {\cf20 // Add element in list (head position)}\par
00097   \} {\cf19 else} \{                                                                                                  {\cf20 // If specified position is less (or equal) than one}\par
00098     fbk_nl(1);  fbk_err({\cf22 "Error, element to add in list must be not null"});                                  {\cf20 // Print error fbk}\par
00099   \}\par
00100 \}\par
}
}
{\xe \v add_new_arch\:lib_graph.c}
{\xe \v lib_graph.c\:add_new_arch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void add_new_arch ({\b C_str}  {\i name}, {\b C_real}  {\i cost})}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 336 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00336                                           \{                                                                 {\cf20 // Function to add new graph arch (arch allocated inside heap)}\par
00337   {\cf20 /* Body */}\par
00338   fbk_nl(1);  fbk_gn_pu({\cf22 "Adding new graph arch..."});                                                        {\cf20 // Adding new graph arch fbk}\par
00339   {\cf19 if} (cost > 0.0)\{                                                                                          {\cf20 // If cost is positive}\par
00340     {\cf19 if} (archs_collect_vect == NULL)                                                                         {\cf20 // Check arches collection vector, if null}\par
00341       allocate_new_archs();                                                                                 {\cf20 // Allocate a new graph arch inside arches collection vector (vect calloc)}\par
00342     {\cf19 else}                                                                                                    {\cf20 // Else if not null}\par
00343       reallocate_new_archs();                                                                               {\cf20 // Allocate a new graph arch inside arches collection vector (vect realloc)}\par
00344     {\cf19 if} (strlen(name) > 0 && strlen(name) < AR_STR_LEN)\{                                                     {\cf20 // Check arch name length consistency, if ok}\par
00345       strcpy(archs_collect_vect[ars_collect_size-1].name, name);  fbk_nl(1);                                {\cf20 // Copy name inside arch name var}\par
00346     \} {\cf19 else} \{                                                                                                {\cf20 // Else if arch name length consistency ain't ok}\par
00347       fbk_err({\cf22 "Error, invalid arch name size! Overriding arch name with arch number in collection"});        {\cf20 // Print error fbk}\par
00348       {\cf18 char} name_ovrd[AR_STR_LEN];                                                                           {\cf20 // Define new name to override input name}\par
00349       sprintf(name_ovrd, {\cf22 "%d"}, ars_collect_size);                                                           {\cf20 // Define override-name as arch number in arches collection vect}\par
00350       strcpy(archs_collect_vect[ars_collect_size-1].name, name_ovrd);                                       {\cf20 // Copy override-name inside arch name var}\par
00351     \}\par
00352     archs_collect_vect[ars_collect_size-1].cost = cost;                                                     {\cf20 // Define arch cost}\par
00353     archs_collect_vect[ars_collect_size-1].nd1 = NULL;                                                      {\cf20 // Set node1 connection to NULL}\par
00354     archs_collect_vect[ars_collect_size-1].nd2 = NULL;                                                      {\cf20 // Set node2 connection to NULL}\par
00355     fbk_gn_lbu_ye_str({\cf22 "New arch name"}, archs_collect_vect[ars_collect_size-1].name);                        {\cf20 // New graph arch name fbk}\par
00356     fbk_nl(1);  fbk_gn_lbu_ye_real({\cf22 "New arch cost"}, archs_collect_vect[ars_collect_size-1].cost);           {\cf20 // New graph arch cost fbk}\par
00357     fbk_nl(1);  fbk_gn_cy({\cf22 "New graph arch correctly added!\\n"});                                             {\cf20 // New graph arch correctly added fbk}\par
00358   \} {\cf19 else} \{                                                                                                  {\cf20 // Else if cost ain't positive}\par
00359     fbk_err({\cf22 "Ops! Encountred error during graph data management"});                                          {\cf20 // Error fbk}\par
00360     perror({\cf22 "Found error during arch object creation, its cost must be strictly positive!"});                 {\cf20 // Print perror fbk}\par
00361     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00362     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00363   \}\par
00364 \}\par
}
}
{\xe \v add_new_node\:lib_graph.c}
{\xe \v lib_graph.c\:add_new_node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void add_new_node ({\b C_str}  {\i name})}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 367 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00367                              \{                                                                              {\cf20 // Function to add new graph node (node allocated inside heap)}\par
00368   {\cf20 /* Body */}\par
00369   fbk_nl(1);  fbk_gn_pu({\cf22 "Adding new graph node..."});                                                        {\cf20 // Adding new graph node fbk}\par
00370   {\cf19 if} (nodes_collect_vect == NULL)                                                                           {\cf20 // Check nodes collection vector, if null}\par
00371     allocate_new_nodes();                                                                                   {\cf20 // Allocate a new graph node inside nodes collection vector (vect calloc)}\par
00372   {\cf19 else}                                                                                                      {\cf20 // Else if not null}\par
00373     reallocate_new_nodes();                                                                                 {\cf20 // Allocate a new graph node inside nodes collection vector (vect realloc)}\par
00374   {\cf19 if} (strlen(name) > 0 && strlen(name) < ND_STR_LEN)\{                                                       {\cf20 // Check node name length consistency, if ok}\par
00375     strcpy(nodes_collect_vect[nds_collect_size-1].name, name);  fbk_nl(1);                                  {\cf20 // Copy name inside node name var}\par
00376   \} {\cf19 else} \{                                                                                                  {\cf20 // Else if node name length consistency ain't ok}\par
00377     fbk_err({\cf22 "Error, invalid node name size! Overriding arch name with node number in collection"});          {\cf20 // Print error fbk}\par
00378     {\cf18 char} name_ovrd[ND_STR_LEN];                                                                             {\cf20 // Define new name to override input name}\par
00379     sprintf(name_ovrd, {\cf22 "%d"}, nds_collect_size);                                                             {\cf20 // Define override-name as node number in arches collection vect}\par
00380     strcpy(nodes_collect_vect[nds_collect_size-1].name, name_ovrd);                                         {\cf20 // Copy override-name inside node name var}\par
00381   \}\par
00382   nodes_collect_vect[nds_collect_size-1].archs_lst = NULL;                                                  {\cf20 // Set node arches list to NULL}\par
00383   nodes_collect_vect[nds_collect_size-1].dd = NULL;                                                         {\cf20 // Set node Dijkstra-dataset to NULL}\par
00384   fbk_gn_lbu_ye_str({\cf22 "New node name"}, nodes_collect_vect[nds_collect_size-1].name);                          {\cf20 // New graph arch name fbk}\par
00385   fbk_nl(1);  fbk_gn_cy({\cf22 "New graph node correctly added!\\n"});                                               {\cf20 // New graph node correctly added fbk}\par
00386 \}\par
}
}
{\xe \v allocate_new_archs\:lib_graph.c}
{\xe \v lib_graph.c\:allocate_new_archs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void allocate_new_archs (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 120 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00120                                 \{                                                                           {\cf20 // Function to allocate new graph arches (single/vect)}\par
00121   {\cf20 /* Body */}\par
00122   ars_collect_size = 0;                                                                                     {\cf20 // Make sure to have arches collection vect size set to zero}\par
00123   archs_collect_vect = calloc(1, {\cf17 sizeof}(Arch));                                                             {\cf20 // Tmp graph arch ptr creation to point at first allocated memo cell inside heap}\par
00124   {\cf19 if} (archs_collect_vect == NULL)\{                                                                          {\cf20 // Check calloc funct output to detect dynamic memory allocation errors}\par
00125     fbk_err({\cf22 "Ops! Encountred error during graph data management"});                                          {\cf20 // Error fbk}\par
00126     perror({\cf22 "Found error during graph arches dynamic memory allocation with calloc!"});                       {\cf20 // Print perror fbk}\par
00127     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00128     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00129   \} {\cf19 else}                                                                                                    {\cf20 // In case of dyn memo allocation OK}\par
00130     ++ars_collect_size;                                                                                     {\cf20 // Upd arches collection vect size}\par
00131 \}\par
}
}
{\xe \v allocate_new_dijk_dataset_vect\:lib_graph.c}
{\xe \v lib_graph.c\:allocate_new_dijk_dataset_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void allocate_new_dijk_dataset_vect (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 174 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00174                                             \{                                                               {\cf20 // Function to allocate new Dijkstra-dataset vector}\par
00175   {\cf20 /* Body */}\par
00176   dijk_dataset_vect = calloc(({\cf18 size_t})nds_collect_size, {\cf17 sizeof}(Dijkstra_dataset));                           {\cf20 // Dijkstra-dataset vect ptr creation to point at first allocated memo cell inside heap}\par
00177   {\cf19 if} (dijk_dataset_vect == NULL || nds_collect_size == 0)\{                                                  {\cf20 // Check calloc funct output to detect dynamic memory allocation errors}\par
00178     fbk_err({\cf22 "Ops! Encountred error during graph data management"});                                          {\cf20 // Error fbk}\par
00179     perror({\cf22 "Found error during Dijkstra-dataset vector dynamic memory allocation with calloc!"});            {\cf20 // Print perror fbk}\par
00180     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00181     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00182   \}\par
00183 \}\par
}
}
{\xe \v allocate_new_list_elems\:lib_graph.c}
{\xe \v lib_graph.c\:allocate_new_list_elems}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b List_elem}* allocate_new_list_elems ({\b C_int}  {\i num}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00043                                                     \{                                                       {\cf20 // Function to allocate new list elements (single/vect)}\par
00044   {\cf20 /* Body */}\par
00045   List_elem* tmp_list_elems = calloc(({\cf18 size_t})num, {\cf17 sizeof}(List_elem));                                       {\cf20 // Tmp list element ptr creation to point at first allocated memo cell inside heap}\par
00046   {\cf19 if} (tmp_list_elems == NULL || num == 0)\{                                                                  {\cf20 // Check calloc funct output to detect dynamic memory allocation errors}\par
00047     fbk_err({\cf22 "Ops! Encountred error during lists data management"});                                          {\cf20 // Error fbk}\par
00048     perror({\cf22 "Found error during list elements dynamic memory allocation with calloc!"});                      {\cf20 // Print perror fbk}\par
00049     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00050     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00051   \}\par
00052   {\cf19 return} tmp_list_elems;                                                                                    {\cf20 // Return tmp list elements, firtst allocated memo cell inside heap (pointer)}\par
00053 \}\par
}
}
{\xe \v allocate_new_nd_conn_vect\:lib_graph.c}
{\xe \v lib_graph.c\:allocate_new_nd_conn_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b Connection}* allocate_new_nd_conn_vect ({\b C_int}  {\i num}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 198 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00198                                                        \{                                                    {\cf20 // Function to allocate new node connections vector}\par
00199   {\cf20 /* Body */}\par
00200   Connection* tmp_nd_conn_ptr = calloc(({\cf18 size_t})num, {\cf17 sizeof}(Connection));                                    {\cf20 // Tmp node connection ptr creation to point at first allocated memo cell inside heap}\par
00201   {\cf19 if} (tmp_nd_conn_ptr == NULL || num == 0)\{                                                                 {\cf20 // Check calloc funct output to detect dynamic memory allocation errors}\par
00202     fbk_err({\cf22 "Ops! Encountred error during graph data management"});                                          {\cf20 // Error fbk}\par
00203     perror({\cf22 "Found error during node connections vector dynamic memory allocation with calloc!"});            {\cf20 // Print perror fbk}\par
00204     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00205     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00206   \}\par
00207   {\cf19 return} tmp_nd_conn_ptr;                                                                                   {\cf20 // Return tmp node connection ptr, firtst allocated memo cell inside heap (pointer)}\par
00208 \}\par
}
}
{\xe \v allocate_new_nodes\:lib_graph.c}
{\xe \v lib_graph.c\:allocate_new_nodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void allocate_new_nodes (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 134 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00134                                 \{                                                                           {\cf20 // Function to allocate new graph nodes (single/vect)}\par
00135   {\cf20 /* Body */}\par
00136   nds_collect_size = 0;                                                                                     {\cf20 // Make sure to have nodes collection vect size set to zero}\par
00137   nodes_collect_vect = calloc(1, {\cf17 sizeof}(Node));                                                             {\cf20 // Tmp graph node ptr creation to point at first allocated memo cell inside heap}\par
00138   {\cf19 if} (nodes_collect_vect == NULL)\{                                                                          {\cf20 // Check calloc funct output to detect dynamic memory allocation errors}\par
00139     fbk_err({\cf22 "Ops! Encountred error during graph data management"});                                          {\cf20 // Error fbk}\par
00140     perror({\cf22 "Found error during graph nodes dynamic memory allocation with calloc!"});                        {\cf20 // Print perror fbk}\par
00141     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00142     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00143   \} {\cf19 else}                                                                                                    {\cf20 // In case of dyn memo allocation OK}\par
00144     ++nds_collect_size;                                                                                     {\cf20 // Upd nodes collection vect size}\par
00145 \}\par
}
}
{\xe \v buid_shortest_path\:lib_graph.c}
{\xe \v lib_graph.c\:buid_shortest_path}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void buid_shortest_path ({\b C_str}  {\i dest_nd_name}, {\b Verbose_mode}  {\i v_mode})}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 514 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00514                                                                 \{                                           {\cf20 // Reconstruct shortest path to specified destination node from source node (pre-defined in Dijkstra's algorithm, min path connections vect allocated/reallocated inside heap) - Y/N for verbose mode}\par
00515   {\cf20 /* Body */}\par
00516   fbk_nl(1);  fbk_gn_pu({\cf22 "Building min cost path from pre-defined source to specified destination..."});      {\cf20 // Print reconstructin' shortest path from pre-defined source to specified destination fbk}\par
00517   {\cf19 if} (realloc_flg != 0)\{                                                                                    {\cf20 // If Dijkstra's algorithm has already been called at least once}\par
00518     {\cf20 // Print info fbks}\par
00519     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "--> Source node name"}, nodes_collect_vect[src_node_idx].name);           {\cf20 // Print src-nd name fbk}\par
00520     {\cf18 int} dest_nd_num = idx_by_name(ND, dest_nd_name);                                                        {\cf20 // Get destination node idx by-name}\par
00521     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "--> Destination node name"}, dest_nd_name);                               {\cf20 // Print dest-nd name fbk}\par
00522     {\cf19 if} (dest_nd_num >= 0)\{                                                                                  {\cf20 // Check error conditions ok}\par
00523       dest_node_idx = dest_nd_num;                                                                          {\cf20 // Set/upd destination node idx lib-var val}\par
00524       {\cf19 if} (nodes_collect_vect[dest_nd_num].dd->min_path_cost < _REAL_MAX_ && dest_nd_num != src_node_idx)\{   {\cf20 // If destination node is reachble from pre-defined source node}\par
00525         fbk_nl(1);                                                                                          {\cf20 // Print new-line fbk}\par
00526         fbk_gn_lbu_ye_real({\cf22 "Min path cost to node"}, nodes_collect_vect[dest_nd_num].dd->min_path_cost);     {\cf20 // Print min path cost to reach destination node from pre-defined source node fbk}\par
00527       \} {\cf19 else} {\cf19 if} (dest_nd_num == src_node_idx)\{                                                              {\cf20 // Else if destination node memo addr corresponds to the source node memo addr}\par
00528         fbk_nl(1);                                                                                          {\cf20 // Print new-line fbk}\par
00529         fbk_gn_lbu_ye_str({\cf22 "Min path cost to node"}, {\cf22 "Destination corresponds to pre-defined source node!"});  {\cf20 // Print destination node correspondin' to the pre-defined source node fbk}\par
00530       \} {\cf19 else} \{                                                                                              {\cf20 // Else if destination node is unreachble from pre-defined source node}\par
00531         fbk_nl(1);                                                                                          {\cf20 // Print new-line fbk}\par
00532         fbk_gn_lbu_ye_str({\cf22 "Min path cost to node"}, {\cf22 "Destination unreachble from pre-defined source node!"}); {\cf20 // Print destination node unreachble fbk}\par
00533       \}\par
00534       {\cf20 // Find min-cost path archs & nodes goin' backward from destination to source node}\par
00535       Graph_node tmp_nd = &nodes_collect_vect[dest_nd_num];                                                 {\cf20 // Init tmp node var to reconstruct min-cost path backwards}\par
00536       List_elem* tmpl = NULL;                                                                               {\cf20 // Def tmp list ptr var (for archs) to reconstruct min-cost path backwards}\par
00537       {\cf19 if} (min_pth_conn_vect_size != 0)                                                                      {\cf20 // If min-cost paths vector size ain't zero}\par
00538         min_pth_conn_vect_size = 0;                                                                         {\cf20 // Make it zero}\par
00539       {\cf19 while} (tmp_nd != NULL)\{                                                                               {\cf20 // Scroll min-cost path backwars 'till src node}\par
00540         {\cf19 if} (realloc_flg == 0)\{                                                                              {\cf20 // If realloc flag ain't been set}\par
00541           min_path_conn_vect = allocate_new_nd_conn_vect(++min_pth_conn_vect_size);                         {\cf20 // Allocate (inside heap) a new min path connections vector}\par
00542           ++realloc_flg;                                                                                    {\cf20 // And then upd realloc flag val to use reallocs instead of callocs 'till "free_graph()" funct call}\par
00543         \} {\cf19 else}                                                                                              {\cf20 // Else if realloc flag has already been set}\par
00544           reallocate_nd_conn_vect(&min_path_conn_vect, ++min_pth_conn_vect_size);                           {\cf20 // Reallocate (inside heap) the min path connections vector}\par
00545         tmpl = tmp_nd->archs_lst;                                                                           {\cf20 // Init tmp archs list ptr var}\par
00546         {\cf19 for} (; tmpl != NULL; tmpl = tmpl->nxt)\{                                                             {\cf20 // Scroll min-cost parh node connection archs list to find min-cost path connection arch}\par
00547           {\cf19 if} ((tmp_nd == tmpl->ar->nd1 && tmpl->ar->nd2 == tmp_nd->dd->prev_nd) ||\par
00548               (tmp_nd == tmpl->ar->nd2 && tmpl->ar->nd1 == tmp_nd->dd->prev_nd))\{                           {\cf20 // Min-cost path connection arch detectin' cond}\par
00549             (min_path_conn_vect+iaddr(V, min_pth_conn_vect_size-1, min_pth_conn_vect_size))->ar = tmpl->ar; {\cf20 // Save arch ptr val inside min path connections vector (min-path connection arch)}\par
00550           \}\par
00551         \}\par
00552         (min_path_conn_vect+iaddr(V, min_pth_conn_vect_size-1, min_pth_conn_vect_size))->nd = tmp_nd;       {\cf20 // Save node ptr val inside min path connections vector (min-path connection node)}\par
00553         tmp_nd = tmp_nd->dd->prev_nd;                                                                       {\cf20 // Upd tmp node var to reconstruct min-cost path backwards}\par
00554       \}\par
00555       {\cf20 // Swap elements to obtain shortest path (backward-to-forward path conversion)}\par
00556       Connection tmp_conn;                                                                                  {\cf20 // Tmp connection var to swap connections}\par
00557       {\cf19 for} ({\cf18 int} i = 0; i < min_pth_conn_vect_size/2; ++i)\{                                                   {\cf20 // Half min path connections vector scrollin' FOR cycle}\par
00558         tmp_conn = min_path_conn_vect[i];                                                                   {\cf20 // Define tmp var to swap connections}\par
00559         min_path_conn_vect[i] = min_path_conn_vect[min_pth_conn_vect_size-1-i];                             {\cf20 // Swap-step1}\par
00560         min_path_conn_vect[min_pth_conn_vect_size-i-1] = tmp_conn;                                          {\cf20 // Swap-step2}\par
00561       \}\par
00562       {\cf20 // Print shortest path from pre-defined source node to specified destination node}\par
00563       {\cf19 if} (v_mode == Y)                                                                                      {\cf20 // If verbose mode is enabled, print fbks}\par
00564         print_shortest_path();                                                                              {\cf20 // Print shortest path funct call}\par
00565       fbk_nl(1);  fbk_gn_cy({\cf22 "Destination node min cost path correctly identified!\\n"});                      {\cf20 // Print destination node min cost path correctly identified fbk}\par
00566     \} {\cf19 else}                                                                                                  {\cf20 // If error conditions ain't ok}\par
00567       fbk_err({\cf22 "Error, not able to find destination node min cost path with Dijkstra's algorithm"});          {\cf20 // Print error fbk}\par
00568   \} {\cf19 else}                                                                                                    {\cf20 // Else if Dijkstra's algorithm ain't been called}\par
00569     fbk_err({\cf22 "Error, min path can be reconstructed only after having called Dijkstra's algorithm!"});         {\cf20 // Print error fbk}\par
00570 \}\par
}
}
{\xe \v connect_node_arch\:lib_graph.c}
{\xe \v lib_graph.c\:connect_node_arch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void connect_node_arch ({\b C_str}  {\i ar_name}, {\b C_str}  {\i nd_name}, {\b Node_pos_in_arch}  {\i nd_pos}, {\b Arch_pos_typ}  {\i ar_pos},   {\i ...})}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 389 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00389                                                                                                        \{    {\cf20 // Function to connect arch-node in graph (new arch list element allocated inside heap, opt param --> arch pos in arches list, non-zero index)}\par
00390   {\cf20 /* Body */}\par
00391   fbk_nl(1);  fbk_gn_pu({\cf22 "Creating bidirectional connection between node and arch..."});                      {\cf20 // Creatin' bidirectional connection between node and arch}\par
00392   {\cf18 int} ar_num = idx_by_name(AR, ar_name);                                                                    {\cf20 // Get arch idx by-name}\par
00393   {\cf18 int} nd_num = idx_by_name(ND, nd_name);                                                                    {\cf20 // Get node idx by-name}\par
00394   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Working on node"}, nd_name);                                                {\cf20 // Print node name fbk}\par
00395   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Working on arch"}, ar_name);                                                {\cf20 // Print arch name fbk}\par
00396   {\cf18 int} lst_pos = 0;                                                                                          {\cf20 // List position in which arch must be placed in node conn. arches list}\par
00397   {\cf20 // Function optional parameters management}\par
00398   {\cf19 if} (ar_pos == LIST_POS)\{                                                                                  {\cf20 // If selected arch position type in list is specific position, read list position optional parameter}\par
00399     va_list args_lst;                                                                                       {\cf20 // Function optional parameters list int}\par
00400     va_start(args_lst, ar_pos);                                                                             {\cf20 // Define optional params list startin' point}\par
00401     lst_pos = va_arg(args_lst, {\cf18 int});                                                                        {\cf20 // Read the first optional parameter in funct opt params list (= define list position)}\par
00402   \}\par
00403   {\cf19 if} (nd_num >= 0 && ar_num >= 0 && ((ar_pos == LIST_POS && lst_pos >= 1) || ar_pos != LIST_POS))\{          {\cf20 // Check error conditions ok}\par
00404     {\cf20 // Assign node to arch}\par
00405     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Connecting node to"}, node_pos_in_arch_str[nd_pos]);                      {\cf20 // Connectin' node to arch fbk}\par
00406     {\cf19 switch} (nd_pos)\{                                                                                        {\cf20 // Node assignin' position in arch switch-case (where to assign node in arch)}\par
00407       {\cf19 case} ARCH_ND1:                                                                                        {\cf20 // Case: assign node to arch node1 position}\par
00408         archs_collect_vect[ar_num].nd1 = &nodes_collect_vect[nd_num];                                       {\cf20 // Assign node to arch node1 pos}\par
00409         {\cf19 break};\par
00411       {\cf19 case} ARCH_ND2:                                                                                        {\cf20 // Case: assign node to arch node2 position}\par
00412         archs_collect_vect[ar_num].nd2 = &nodes_collect_vect[nd_num];                                       {\cf20 // Assign node to arch node2 pos}\par
00413         {\cf19 break};\par
00415       {\cf19 default}:                                                                                              {\cf20 // Unknown case}\par
00416         fbk_err({\cf22 "Error, bad parameter value! A function got an unexpected patameter value"});                {\cf20 // Print error fbk}\par
00417         perror({\cf22 "Wrong \\"nd_pos\\" parameter value passsed to \\"connect_node_arch\\" function!"});              {\cf20 // Print perror fbk}\par
00418         {\cf19 break};\par
00419     \}\par
00420     {\cf20 // Assign arch to node}\par
00421     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Connecting arch to node connection archs"}, arch_pos_typ_str[ar_pos]);    {\cf20 // Connectin' node to arch fbk}\par
00422     List_elem* tmp_el = allocate_new_list_elems(1);                                                         {\cf20 // Tmp list element ptr creation}\par
00423     tmp_el->ar = &archs_collect_vect[ar_num];                                                               {\cf20 // Tmp list element ptr def with input arch memo cell addr}\par
00424     {\cf19 switch} (ar_pos)\{                                                                                        {\cf20 // Arch assignin' position type in node arches list switch-case (where to assign arch in node arches connections list) switch-case}\par
00425       {\cf19 case} LIST_HEAD:                                                                                       {\cf20 // Case: assign arch to node arches connections list (head position)}\par
00426         add_elem_at_list_head(&nodes_collect_vect[nd_num].archs_lst, tmp_el);                               {\cf20 // Assign arch (in tmp list element) to the specified node conn. arches list (head position)}\par
00427         {\cf19 break};\par
00429       {\cf19 case} LIST_POS:                                                                                        {\cf20 // Case: assign arch to node arches connections list (specific position, pos from optional funct param)}\par
00430         fbk_nl(1);  fbk_gn_lbu_ye_int({\cf22 "Specific list position number"}, lst_pos);                            {\cf20 // Specific list position num fbk}\par
00431         add_elem_at_list_pos(&nodes_collect_vect[nd_num].archs_lst, tmp_el, lst_pos);                       {\cf20 // Assign arch (in tmp list element) to the specified node conn. arches list (specific position, non-zero index)}\par
00432         {\cf19 break};\par
00434       {\cf19 case} LIST_TAIL:                                                                                       {\cf20 // Case: assign arch to node arches connections list (tail position)}\par
00435         add_elem_at_list_tail(&nodes_collect_vect[nd_num].archs_lst, tmp_el);                               {\cf20 // Assign arch (in tmp list element) to the specified node conn. arches list (tail position)}\par
00436         {\cf19 break};\par
00438       {\cf19 default}:                                                                                              {\cf20 // Unknown case}\par
00439         fbk_err({\cf22 "Error, bad parameter value! A function got an unexpected patameter value"});                {\cf20 // Print error fbk}\par
00440         perror({\cf22 "Wrong \\"ar_pos\\" parameter value passsed to \\"connect_node_arch\\" function!"});              {\cf20 // Print perror fbk}\par
00441         {\cf19 break};\par
00442     \}\par
00443     fbk_nl(1);  fbk_gn_cy({\cf22 "Bidirectional node-arch connetion correctly created!\\n"});                        {\cf20 // Bidirectional node-arch connection correctly created fbk}\par
00444   \} {\cf19 else} \{                                                                                                  {\cf20 // If error conditions ain't ok}\par
00445     fbk_err({\cf22 "Error, not able to create arch-node connection! Connection not created"});                      {\cf20 // Print error fbk}\par
00446     {\cf19 if} (ar_pos == LIST_POS && lst_pos < 1)                                                                  {\cf20 // List pos err detect cond}\par
00447       fbk_err({\cf22 "Error casued by specific list position flag enabled and invalid position value"});            {\cf20 // Print error fbk}\par
00448   \}\par
00449 \}\par
}
}
{\xe \v dijkstra_alg\:lib_graph.c}
{\xe \v lib_graph.c\:dijkstra_alg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dijkstra_alg ({\b C_str}  {\i src_nd_name}, {\b Verbose_mode}  {\i v_mode})}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 452 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00452                                                          \{                                                  {\cf20 // Dijkstra's alg to find min graph-path btwn source and each destination node (Dijkstra-dataset vect allocated/reallocated inside heap) - Y/N for verbose mode}\par
00453   {\cf20 /* Body */}\par
00454   fbk_nl(1);  fbk_gn_pu({\cf22 "Looking for min path costs from specified source with Dijkstra's algorithm..."});   {\cf20 // Print lookin' 4 shortest path btwn spec src and each dest nd fbk}\par
00455   {\cf18 int} src_nd_num = idx_by_name(ND, src_nd_name);                                                            {\cf20 // Get source node idx by-name}\par
00456   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Source node name"}, src_nd_name);                                           {\cf20 // Print source node name}\par
00457   {\cf19 if} (src_nd_num >= 0)\{                                                                                     {\cf20 // Check error conditions ok}\par
00458     {\cf20 // Algorithm inits}\par
00459     {\cf18 int} min_cost_idx = 0;                                                                                   {\cf20 // Min cost node idx in dataset var init}\par
00460     Real min_cost_val = 0.0;                                                                                {\cf20 // Min cost node val in dataset var init}\par
00461     {\cf18 int} nan_nd_conn_vect_size = 0;                                                                          {\cf20 // Node (non-analyzed) connections vector size var to store selected node non-analyzed connections init}\par
00462     Real new_cost = 0.0;                                                                                    {\cf20 // New cost var init}\par
00463     Connection* nan_nd_conn_vect = NULL;                                                                    {\cf20 // Node (non-analyzed) connections vector ptr var decl}\par
00464     {\cf19 if} (realloc_flg == 0)\{                                                                                  {\cf20 // If realloc flag ain't set}\par
00465       allocate_new_dijk_dataset_vect();                                                                     {\cf20 // Dijkstra-dataset vect init (vector allocated inside heap)}\par
00466       ++realloc_flg;                                                                                        {\cf20 // Set realloc flg}\par
00467     \} {\cf19 else}                                                                                                  {\cf20 // Else if realloc flag has been set}\par
00468       reallocate_dijk_dataset_vect();                                                                       {\cf20 // Dijkstra-dataset vect realloc (vector reallocated inside heap)}\par
00469     {\cf19 for} ({\cf18 int} i = 0; i < nds_collect_size; ++i)\{                                                             {\cf20 // Inits FOR cycle}\par
00470       nodes_collect_vect[i].dd = &dijk_dataset_vect[i];                                                     {\cf20 // Define and init nodes Dijkstra-datasets}\par
00471       nodes_collect_vect[i].dd->prev_nd = NULL;                                                             {\cf20 // Node dataset prev node init}\par
00472       nodes_collect_vect[i].dd->an_flg = 0;                                                                 {\cf20 // Node dataset analyzed flag val preset (as not analyzed)}\par
00473       {\cf19 if} (i != src_nd_num)                                                                                  {\cf20 // If node is different from source node}\par
00474         nodes_collect_vect[i].dd->min_path_cost = _REAL_MAX_;                                               {\cf20 // Init unknown min costs from source node (preset val --> +inf)}\par
00475       {\cf19 else}                                                                                                  {\cf20 // Else if node ain't different from source node}\par
00476         nodes_collect_vect[i].dd->min_path_cost = 0;                                                        {\cf20 // Init source-to-source cost (preset val --> zero)}\par
00477     \}\par
00478     src_node_idx = src_nd_num;                                                                              {\cf20 // Set/upd source node idx lib-var val}\par
00479     {\cf20 // Algorithm loop}\par
00480     {\cf19 for} ({\cf18 int} j = 0; j < nds_collect_size-1; ++j)\{                                                           {\cf20 // Main algo loop}\par
00481       {\cf20 // Select node with min-cost path}\par
00482       min_cost_val = _REAL_MAX_;                                                                            {\cf20 // Min cost node val in dataset upd}\par
00483       {\cf19 for} ({\cf18 int} k = 0; k < nds_collect_size; ++k)\{                                                           {\cf20 // Scroll the entire nodes collection 2 detect min cost path node}\par
00484         {\cf19 if} (nodes_collect_vect[k].dd->an_flg == 0 &&\par
00485             nodes_collect_vect[k].dd->min_path_cost < min_cost_val)\{                                        {\cf20 // Min cost path node detectin' cond (min val and node not alredy analized)}\par
00486           min_cost_val = nodes_collect_vect[k].dd->min_path_cost;                                           {\cf20 // If detectin' cond is met, upd min cost node val}\par
00487           min_cost_idx = k;                                                                                 {\cf20 // And upd min cost node idx}\par
00488         \}\par
00489       \}\par
00490       ++nodes_collect_vect[min_cost_idx].dd->an_flg;                                                        {\cf20 // Mark selected node as alredy analized b4 processin' it}\par
00491       {\cf20 // Find non-analyzed connections of selected node}\par
00492       nan_nd_conn_vect_size = 0;                                                                            {\cf20 // Node (non-analyzed) connections vector size var to store selected node non-analyzed connections (rst)}\par
00493       nan_nd_conn_vect = not_an_node_conn(&nodes_collect_vect[min_cost_idx], &nan_nd_conn_vect_size);       {\cf20 // Define selected node non-analyzed connections vect (vector allocated inside heap)}\par
00494       {\cf19 for} ({\cf18 int} l = 0; l < nan_nd_conn_vect_size; ++l)\{                                                      {\cf20 // Scroll selected node non-analyzed connections vect}\par
00495         new_cost = nodes_collect_vect[min_cost_idx].dd->min_path_cost+nan_nd_conn_vect[l].ar->cost;         {\cf20 // New cost val upd}\par
00496         {\cf20 // Upd min path cost and previous node in shortest path}\par
00497         {\cf19 if} (new_cost < nan_nd_conn_vect[l].nd->dd->min_path_cost)\{                                          {\cf20 // In case new cost val is less than min cost val}\par
00498           nan_nd_conn_vect[l].nd->dd->min_path_cost = new_cost;                                             {\cf20 // Upd min cost val}\par
00499           nan_nd_conn_vect[l].nd->dd->prev_nd = &nodes_collect_vect[min_cost_idx];                          {\cf20 // Upd previous min path node}\par
00500         \}\par
00501       \}\par
00502       {\cf19 if} (nan_nd_conn_vect != NULL)                                                                         {\cf20 // If node non-analyzed connections vector was correctly defined}\par
00503         free(nan_nd_conn_vect);                                                                             {\cf20 // Free node non-analyzed connections vector allocated inside heap}\par
00504     \}\par
00505     {\cf20 // Print each min path cost to reach every single accessible node from specified source-node}\par
00506     {\cf19 if} (v_mode == Y)                                                                                        {\cf20 // If verbose mode is enabled, print fbks}\par
00507       print_min_paths();                                                                                    {\cf20 // Print min paths funct call}\par
00508     fbk_nl(1);  fbk_gn_cy({\cf22 "Min path costs correctly found!\\n"});                                             {\cf20 // Print min path costs correctly found fbk}\par
00509   \} {\cf19 else}                                                                                                    {\cf20 // If error conditions ain't ok}\par
00510     fbk_err({\cf22 "Error, not able to find min path costs with Dijkstra's algorithm"});                            {\cf20 // Print error fbk}\par
00511 \}\par
}
}
{\xe \v free_graph\:lib_graph.c}
{\xe \v lib_graph.c\:free_graph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void free_graph ()}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 573 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00573                  \{                                                                                          {\cf20 // Function to free graph allocated memory inside heap}\par
00574   {\cf20 /* Body */}\par
00575   fbk_nl(1);  fbk_gn_pu({\cf22 "Clearing the whole graph structure..."});                                           {\cf20 // Clearing the whole graph from heap fbk}\par
00576   {\cf19 for} ({\cf18 int} i = 0; i < nds_collect_size; ++i)                                                                {\cf20 // Graph nodes scrollin' FOR cycle}\par
00577     {\cf19 if} (nodes_collect_vect[i].archs_lst != NULL)\{                                                           {\cf20 // If node arches list ain't null}\par
00578       free_list_elems(&nodes_collect_vect[i].archs_lst, N);                                                 {\cf20 // Free graph arches list elems associated to each graph node - NO --> without verbose mode}\par
00579       nodes_collect_vect[i].archs_lst = NULL;                                                               {\cf20 // Set node arches list to null}\par
00580     \}\par
00581   {\cf19 if} (archs_collect_vect != NULL)\{                                                                          {\cf20 // If arches collection vector needs to be cleared from heap}\par
00582     free(archs_collect_vect);                                                                               {\cf20 // Free arches collection vector allocated memo inside heap}\par
00583     archs_collect_vect = NULL;                                                                              {\cf20 // Set arches collection vector to null}\par
00584   \}\par
00585   {\cf19 if} (nodes_collect_vect != NULL)\{                                                                          {\cf20 // If nodes collection vector needs to be cleared from heap}\par
00586     free(nodes_collect_vect);                                                                               {\cf20 // Free nodes collection vector allocated memo inside heap}\par
00587     nodes_collect_vect = NULL;                                                                              {\cf20 // Set nodes collection vector to null}\par
00588   \}\par
00589   {\cf19 if} (dijk_dataset_vect != NULL)\{                                                                           {\cf20 // If Dijkstra-dataset vector needs to be cleared from heap}\par
00590     free(dijk_dataset_vect);                                                                                {\cf20 // Free Dijkstra-dataset vector allocated memo inside heap}\par
00591     dijk_dataset_vect = NULL;                                                                               {\cf20 // Set Dijkstra-dataset vector to null}\par
00592   \}\par
00593   {\cf19 if} (min_path_conn_vect != NULL)\{                                                                          {\cf20 // If min path connections vector needs to be cleared from heap}\par
00594     free(min_path_conn_vect);                                                                               {\cf20 // Free min path connections vector allocated memo inside heap}\par
00595     min_path_conn_vect = NULL;                                                                              {\cf20 // Set min path connections vector to null}\par
00596   \}\par
00597   ars_collect_size = 0;                                                                                     {\cf20 // Set graph arches number back to zero}\par
00598   nds_collect_size = 0;                                                                                     {\cf20 // Set graph nodes number back to zero}\par
00599   min_pth_conn_vect_size = 0;                                                                               {\cf20 // Set min path connections vector size back to zero}\par
00600   realloc_flg = 0;                                                                                          {\cf20 // Realloc flag rst}\par
00601   fbk_nl(1);  fbk_gn_cy({\cf22 "Graph structure correctly erased!\\n"});                                             {\cf20 // Graph structure correctly created erased from heap fbk}\par
00602 \}\par
}
}
{\xe \v free_list_elems\:lib_graph.c}
{\xe \v lib_graph.c\:free_list_elems}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void free_list_elems ({\b List} *  {\i list_head}, {\b Verbose_mode}  {\i v_mode}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 103 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00103                                                                  \{                                          {\cf20 // Function to free allocated elements inside heap, startin' from specified list (or sub-list) head, 'till list (or sub-list) tail - Y/N for verbose mode}\par
00104   {\cf20 /* Body */}\par
00105   List tmp_list_head = *list_head;                                                                          {\cf20 // Tmp var to clear allocated memo inside heap (list element)}\par
00106   List tmp_nxt_el = *list_head;                                                                             {\cf20 // Tmp var to store next element in list memo inside heap}\par
00107   {\cf19 for} ({\cf18 int} i = 0; tmp_list_head != NULL; tmp_list_head = tmp_nxt_el, ++i)\{                                  {\cf20 // List (or sub-list) scrollin' FOR cycle to clear heap allocated memo}\par
00108     {\cf19 if} (tmp_list_head != NULL)\{                                                                             {\cf20 // If allocated element ain't null}\par
00109       {\cf19 if} (v_mode == Y)\{                                                                                     {\cf20 // If verbose mode is enabled, print fbk}\par
00110         fbk_nl(1);  fbk_gn_lbu_ye_int({\cf22 "Removing allocated list element from heap, element number"}, i+1);    {\cf20 // Print removing element from heap fbk}\par
00111       \}\par
00112       tmp_nxt_el = tmp_list_head->nxt;                                                                      {\cf20 // Updn ext element in list var}\par
00113       free(tmp_list_head);                                                                                  {\cf20 // Clear allocated elements}\par
00114     \}\par
00115   \}\par
00116   *list_head = NULL;                                                                                        {\cf20 // Set elements list (or sub-list) head to null}\par
00117 \}\par
}
}
{\xe \v iaddr\:lib_graph.c}
{\xe \v lib_graph.c\:iaddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int iaddr ({\b C_int}  {\i i}, {\b C_int}  {\i j}, {\b C_int}  {\i lda}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 29 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00029                                              \{                                                              {\cf20 // Arrays/vectors memo addressing}\par
00030   {\cf20 /* Body */}\par
00031   {\cf19 if} (i >= 0 && j >= 0 && lda >= 0)                                                                         {\cf20 // Check params ok}\par
00032     {\cf19 return} (i*lda)+j;                                                                                       {\cf20 // Return index number}\par
00033   {\cf19 else} \{                                                                                                    {\cf20 // If params ain't ok}\par
00034     fbk_err({\cf22 "Ops! Encountred error during arrays data management"});                                         {\cf20 // Error fbk}\par
00035     perror({\cf22 "Found error during array-elements access with 'iaddr' function! Parameters must be positive!"}); {\cf20 // Print perror fbk}\par
00036     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00037     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00038     {\cf19 return} -1;                                                                                              {\cf20 // Random return to avoid compile-errors}\par
00039   \}\par
00040 \}\par
}
}
{\xe \v idx_by_name\:lib_graph.c}
{\xe \v lib_graph.c\:idx_by_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int idx_by_name ({\b Obj_type}  {\i object_type}, {\b C_str}  {\i object_name})}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 308 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00308                                                         \{                                                   {\cf20 // Function to get object (arch/node) vector index by name (-1 = No match found / -2 = Error)}\par
00309   {\cf20 /* Body */}\par
00310   {\cf18 int} match_found = -1;                                                                                     {\cf20 // Match found idx (-1 = No match found / -2 = Error)}\par
00311   {\cf19 switch} (object_type)\{                                                                                     {\cf20 // Object type switch-case}\par
00312     {\cf19 case} AR:                                                                                                {\cf20 // Object type = arch}\par
00313       {\cf19 for} ({\cf18 int} i = 0; i < ars_collect_size; ++i)                                                            {\cf20 // Search match by-name in arches collection vector}\par
00314         {\cf19 if} (strcmp(object_name, archs_collect_vect[i].name) == 0)                                           {\cf20 // Match detecting condition}\par
00315           match_found = i;                                                                                  {\cf20 // Retun match idx in vect}\par
00316       {\cf19 break};\par
00318     {\cf19 case} ND:                                                                                                {\cf20 // Object type = node}\par
00319       {\cf19 for} ({\cf18 int} j = 0; j < nds_collect_size; ++j)                                                            {\cf20 // Search match by-name in nodes collection vector}\par
00320         {\cf19 if} (strcmp(object_name, nodes_collect_vect[j].name) == 0)                                           {\cf20 // Match detecting condition}\par
00321           match_found = j;                                                                                  {\cf20 // Retun match idx in vect}\par
00322       {\cf19 break};\par
00324     {\cf19 default}:                                                                                                {\cf20 // Unknown object type}\par
00325       fbk_err({\cf22 "Error, bad parameter value! A function got an unexpected patameter value"});                  {\cf20 // Print error fbk}\par
00326       perror({\cf22 "Wrong \\"object_type\\" parameter value passsed to \\"idx_by_name\\" function!"});                 {\cf20 // Print perror fbk}\par
00327       --match_found;                                                                                        {\cf20 // Decrease match found val to indicate error}\par
00328       {\cf19 break};\par
00329   \}\par
00330   {\cf19 if} (match_found == -1)                                                                                    {\cf20 // No march found cond}\par
00331     fbk_err({\cf22 "Error, no match found! Specified name probably wrong or not present in collection"});           {\cf20 // Print err fbk}\par
00332   {\cf19 return} match_found;                                                                                       {\cf20 // Return val}\par
00333 \}\par
}
}
{\xe \v not_an_node_conn\:lib_graph.c}
{\xe \v lib_graph.c\:not_an_node_conn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b Connection}* not_an_node_conn ({\b Node} *  {\i nd}, int *const  {\i vect_size}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 223 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00223                                                                    \{                                        {\cf20 // Function to get a vector of non-analyzed connections associated to a specific node (vector allocated inside heap)}\par
00224   {\cf20 /* Body */}\par
00225   List_elem* tmp_el = nd->archs_lst;                                                                        {\cf20 // Define tmp list elem ptr var (to scroll arches inside node conn. arches list)}\par
00226   Connection* nan_nd_conn_vect = NULL;                                                                      {\cf20 // Vector of non-analyzed connections associated to a specific node}\par
00227   *vect_size = 0;                                                                                           {\cf20 // Number of non-analyzed connections associated to a specific node (rst)}\par
00228   {\cf19 for} (; tmp_el != NULL; tmp_el = tmp_el->nxt)\{                                                             {\cf20 // Scroll node conn. arches list, upd num of non-analyzed connections associated to a specific node, resize node connections vect inside heap and define vector elements}\par
00229     {\cf19 if} ((nd == tmp_el->ar->nd1 && tmp_el->ar->nd2->dd->an_flg == 0) ||\par
00230         (nd == tmp_el->ar->nd2 && tmp_el->ar->nd1->dd->an_flg == 0))\{                                       {\cf20 // Add node non-analyzed connection only if the destination node ain't been already analyzed}\par
00231       {\cf19 if} (*vect_size == 0)                                                                                  {\cf20 // If it's the first iteration, allocate vector of non-analyzed connections associated to a specific node}\par
00232         nan_nd_conn_vect = allocate_new_nd_conn_vect(*vect_size+1);                                         {\cf20 // Init node non-analyzed connections vect inside heap}\par
00233       {\cf19 else}                                                                                                  {\cf20 // If it's not the first iteration, reallocate vector of non-analyzed connections associated to a specific node (resize)}\par
00234         reallocate_nd_conn_vect(&nan_nd_conn_vect, *vect_size+1);                                           {\cf20 // Resize node non-analyzed connections vect inside heap}\par
00235       {\cf19 if} (nd == tmp_el->ar->nd1)                                                                            {\cf20 // If specified node memo addr corresponds to the arch conn. node1, assign arch conn. node2 in newly allocated element inside vect}\par
00236         (nan_nd_conn_vect+iaddr(V, *vect_size, *vect_size+1))->nd = tmp_el->ar->nd2;                        {\cf20 // Define elements of node (non-analyzed) connections vect inside heap (connection node)}\par
00237       {\cf19 else}                                                                                                  {\cf20 // If specified node memo addr doesn't correspond to the arch conn. node1, assign arch conn. node1 in newly allocated element inside vect}\par
00238         (nan_nd_conn_vect+iaddr(V, *vect_size, *vect_size+1))->nd = tmp_el->ar->nd1;                        {\cf20 // Define elements of node (non-analyzed) connections vect inside heap (connection node)}\par
00239       (nan_nd_conn_vect+iaddr(V, *vect_size, *vect_size+1))->ar = tmp_el->ar;                               {\cf20 // Define elements of node (non-analyzed) connections vect inside heap (connection arch)}\par
00240       ++*vect_size;                                                                                         {\cf20 // Vector of non-analyzed connections associated to a specific node size val upd}\par
00241     \}\par
00242   \}\par
00243   {\cf19 return} nan_nd_conn_vect;                                                                                  {\cf20 // Return vector of non-analyzed connections associated to a specific node}\par
00244 \}\par
}
}
{\xe \v print_min_paths\:lib_graph.c}
{\xe \v lib_graph.c\:print_min_paths}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void print_min_paths (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 247 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00247                              \{                                                                              {\cf20 // Function to print each min path cost to reach every single accessible node from specified source-node}\par
00248   {\cf20 /* Body */}\par
00249   {\cf19 for} ({\cf18 int} m = 0; m < nds_collect_size; ++m)\{                                                               {\cf20 // Min path costs printin' FOR cycle}\par
00250     fbk_nl(1);  fbk_separator(SEP_CHR, GN);                                                                 {\cf20 // Print separator fbk}\par
00251     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "--> Node name"}, nodes_collect_vect[m].name);                             {\cf20 // Print node name fbk}\par
00252     {\cf19 if} (nodes_collect_vect[m].dd->min_path_cost < _REAL_MAX_ &&\par
00253         &nodes_collect_vect[m] != &nodes_collect_vect[src_node_idx])\{                                       {\cf20 // If node is reachble from specified source node}\par
00254       fbk_nl(1); fbk_gn_lbu_ye_real({\cf22 "Min path cost to node"}, nodes_collect_vect[m].dd->min_path_cost);      {\cf20 // Print min path cost to reach that node from specified source-node fbk}\par
00255     \} {\cf19 else} \{                                                                                                {\cf20 // Else if node is unreachble from specified source node}\par
00256       {\cf19 if} (&nodes_collect_vect[m] == &nodes_collect_vect[src_node_idx])\{                                     {\cf20 // Else if node memo addr corresponds to the source node memo addr}\par
00257         fbk_nl(1);                                                                                          {\cf20 // Print new-line fbk}\par
00258         fbk_gn_lbu_ye_str({\cf22 "Min path cost to node"}, {\cf22 "This node is the specified source node!"});              {\cf20 // Print node correspondin' to the specified source node fbk}\par
00259       \} {\cf19 else} \{                                                                                              {\cf20 // Else if node is unreachble from specified source node}\par
00260         fbk_nl(1);                                                                                          {\cf20 // Print new-line fbk}\par
00261         fbk_gn_lbu_ye_str({\cf22 "Min path cost to node"}, {\cf22 "Node unreachble from specified source node!"});          {\cf20 // Print node unreachble fbk}\par
00262       \}\par
00263     \}\par
00264   \}\par
00265   fbk_nl(1);  fbk_separator(SEP_CHR, GN);                                                                   {\cf20 // Print separator fbk}\par
00266 \}\par
}
}
{\xe \v print_shortest_path\:lib_graph.c}
{\xe \v lib_graph.c\:print_shortest_path}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void print_shortest_path (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 269 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00269                                  \{                                                                          {\cf20 // Print shortest path from pre-defined source node to specified destination node}\par
00270   {\cf20 /* Body */}\par
00271   {\cf19 if} (min_pth_conn_vect_size >= 2)\{                                                                         {\cf20 // If destination node is reachble and it's different from source node}\par
00272     fbk_nl(1);                                                                                              {\cf20 // New line fbk}\par
00273     fbk_gn_lbu_ye_int({\cf22 "Number of nodes between source and destination node"}, min_pth_conn_vect_size-2);     {\cf20 // Print num of nodes btwn source and destination node fbk}\par
00274     fbk_nl(1);                                                                                              {\cf20 // New line fbk}\par
00275     fbk_gn_lbu_ye_int({\cf22 "Number of arches between source and destination node"}, min_pth_conn_vect_size-1);    {\cf20 // Print num of archs btwn source and destination node fbk}\par
00276     fbk_nl(1);  fbk_separator(SHORT_PTH_SEP_CHR, LGN);                                                      {\cf20 // Print separator fbk}\par
00277     fbk_nl(1);  fbk_gn_pu({\cf22 "Showing shortest path between specified source and destination nodes:"});         {\cf20 // Showin' shortest path fbk}\par
00278     delay(PRINT_DLY_MS);                                                                                    {\cf20 // Wait dly time}\par
00279     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Status"}, {\cf22 "STARTING"});                                                    {\cf20 // Print startin' from source node fbk}\par
00280     delay(PRINT_DLY_MS);                                                                                    {\cf20 // Wait dly time}\par
00281     fbk_nl(1);                                                                                              {\cf20 // New line fbk}\par
00282     fbk_gn_lbu_ye_str({\cf22 "Source-node name"}, min_path_conn_vect[0].nd->name);                                  {\cf20 // Source node name fbk}\par
00283     delay(PRINT_DLY_MS);                                                                                    {\cf20 // Wait dly time}\par
00284     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Path-arch name"}, min_path_conn_vect[1].ar->name);                        {\cf20 // Path arch name fbk}\par
00285     fbk_tabs(1);  fbk_gn_lbu_ye_real({\cf22 "Arch cost"}, min_path_conn_vect[1].ar->cost);                          {\cf20 // Path arch cost fbk}\par
00286     delay(PRINT_DLY_MS);                                                                                    {\cf20 // Wait dly time}\par
00287     {\cf19 for} ({\cf18 int} i = 1; i < min_pth_conn_vect_size-1; ++i)\{                                                     {\cf20 // Min path scrollin' and printin' FOR cycle (btwn src and dest nodes)}\par
00288       fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Path-node name"}, min_path_conn_vect[i].nd->name);                      {\cf20 // Path node name fbk}\par
00289       delay(PRINT_DLY_MS);                                                                                  {\cf20 // Wait dly time}\par
00290       fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Path-arch name"}, min_path_conn_vect[i+1].ar->name);                    {\cf20 // Path arch name fbk}\par
00291       fbk_tabs(1);  fbk_gn_lbu_ye_real({\cf22 "Arch cost"}, min_path_conn_vect[i+1].ar->cost);                      {\cf20 // Path arch cost fbk}\par
00292       delay(PRINT_DLY_MS);                                                                                  {\cf20 // Wait dly time}\par
00293     \}\par
00294     fbk_nl(1);                                                                                              {\cf20 // New line fbk}\par
00295     fbk_gn_lbu_ye_str({\cf22 "Destination-node name"}, min_path_conn_vect[min_pth_conn_vect_size-1].nd->name);      {\cf20 // Destination node name fbk}\par
00296     delay(PRINT_DLY_MS);                                                                                    {\cf20 // Wait dly time}\par
00297     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Status"}, {\cf22 "ARRIVED"});                                                     {\cf20 // Print arrived to destination node fbk}\par
00298     fbk_nl(1);  fbk_separator(SHORT_PTH_SEP_CHR, LGN);                                                      {\cf20 // Print separator fbk}\par
00299     delay(PRINT_DLY_MS);                                                                                    {\cf20 // Wait dly time}\par
00300   \} {\cf19 else} \{                                                                                                  {\cf20 // Else if destination node is unreachble or it's equal to source node}\par
00301     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Number of nodes between source and destination node"}, {\cf22 "-"});              {\cf20 // Print no nodes btwn src and dest nodes}\par
00302     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Path-node name"}, {\cf22 "-"});                                                   {\cf20 // Print no archs btwn src and dest nodes}\par
00303   \}\par
00304 \}\par
}
}
{\xe \v reallocate_dijk_dataset_vect\:lib_graph.c}
{\xe \v lib_graph.c\:reallocate_dijk_dataset_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void reallocate_dijk_dataset_vect (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 186 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00186                                           \{                                                                 {\cf20 // Function to reallocate Dijkstra-dataset vector (resize)}\par
00187   {\cf20 /* Body */}\par
00188   dijk_dataset_vect = realloc(dijk_dataset_vect, ({\cf18 size_t})nds_collect_size*{\cf17 sizeof}(Dijkstra_dataset));        {\cf20 // Dijkstra-dataset vect ptr addr upd to make sure it points at first reallocated memo cell inside heap}\par
00189   {\cf19 if} (dijk_dataset_vect == NULL || nds_collect_size == 0)\{                                                  {\cf20 // Check realloc funct output to detect dynamic memory allocation errors}\par
00190     fbk_err({\cf22 "Ops! Encountred error during graph data management"});                                          {\cf20 // Error fbk}\par
00191     perror({\cf22 "Found error during Dijkstra-dataset vector dynamic memory reallocation with realloc!"});         {\cf20 // Print perror fbk}\par
00192     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00193     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00194   \}\par
00195 \}\par
}
}
{\xe \v reallocate_nd_conn_vect\:lib_graph.c}
{\xe \v lib_graph.c\:reallocate_nd_conn_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void reallocate_nd_conn_vect ({\b Connection} **  {\i nd_conn_vect}, {\b C_int}  {\i size}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 211 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00211                                                                           \{                                 {\cf20 // Function to reallocate node connections vector (resize)}\par
00212   {\cf20 /* Body */}\par
00213   *nd_conn_vect = realloc(*nd_conn_vect, ({\cf18 size_t})size*{\cf17 sizeof}(Connection));                                  {\cf20 // Node connections vect ptr addr upd to make sure it points at first reallocated memo cell inside heap}\par
00214   {\cf19 if} (*nd_conn_vect == NULL || size == 0)\{                                                                  {\cf20 // Check realloc funct output to detect dynamic memory allocation errors}\par
00215     fbk_err({\cf22 "Ops! Encountred error during graph data management"});                                          {\cf20 // Error fbk}\par
00216     perror({\cf22 "Found error during node connections vector dynamic memory reallocation with realloc!"});         {\cf20 // Print perror fbk}\par
00217     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00218     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00219   \}\par
00220 \}\par
}
}
{\xe \v reallocate_new_archs\:lib_graph.c}
{\xe \v lib_graph.c\:reallocate_new_archs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void reallocate_new_archs (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 148 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00148                                   \{                                                                         {\cf20 // Function to reallocate new graph arches (single/vect)}\par
00149   {\cf20 /* Body */}\par
00150   archs_collect_vect = realloc(archs_collect_vect, ({\cf18 size_t})(ars_collect_size+1)*{\cf17 sizeof}(Arch));              {\cf20 // Tmp graph arch ptr creation to point at first allocated memo cell inside heap}\par
00151   {\cf19 if} (archs_collect_vect == NULL)\{                                                                          {\cf20 // Check realloc funct output to detect dynamic memory allocation errors}\par
00152     fbk_err({\cf22 "Ops! Encountred error during graph data management"});                                          {\cf20 // Error fbk}\par
00153     perror({\cf22 "Found error during graph arches dynamic memory reallocation with realloc!"});                    {\cf20 // Print perror fbk}\par
00154     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00155     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00156   \} {\cf19 else}                                                                                                    {\cf20 // In case of dyn memo reallocation OK}\par
00157     ++ars_collect_size;                                                                                     {\cf20 // Upd arches collection vect size}\par
00158 \}\par
}
}
{\xe \v reallocate_new_nodes\:lib_graph.c}
{\xe \v lib_graph.c\:reallocate_new_nodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void reallocate_new_nodes (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 161 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00161                                   \{                                                                         {\cf20 // Function to reallocate new graph nodes (single/vect)}\par
00162   {\cf20 /* Body */}\par
00163   nodes_collect_vect = realloc(nodes_collect_vect, ({\cf18 size_t})(nds_collect_size+1)*{\cf17 sizeof}(Node));              {\cf20 // Tmp graph node ptr creation to point at first allocated memo cell inside heap}\par
00164   {\cf19 if} (nodes_collect_vect == NULL)\{                                                                          {\cf20 // Check realloc funct output to detect dynamic memory allocation errors}\par
00165     fbk_err({\cf22 "Ops! Encountred error during graph data management"});                                          {\cf20 // Error fbk}\par
00166     perror({\cf22 "Found error during graph nodes dynamic memory reallocation with realloc!"});                     {\cf20 // print Perror fbk}\par
00167     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00168     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00169   \} {\cf19 else}                                                                                                    {\cf20 // In case of dyn memo reallocation OK}\par
00170     ++nds_collect_size;                                                                                     {\cf20 // Upd nodes collection vect size}\par
00171 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v _REAL_MAX_\:lib_graph.c}
{\xe \v lib_graph.c\:_REAL_MAX_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Real} _REAL_MAX_ = __DBL_MAX__}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file lib_graph.c.}\par
}
{\xe \v archs_collect_vect\:lib_graph.c}
{\xe \v lib_graph.c\:archs_collect_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Arch}* archs_collect_vect = NULL}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file lib_graph.c.}\par
}
{\xe \v ars_collect_size\:lib_graph.c}
{\xe \v lib_graph.c\:ars_collect_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ars_collect_size = 0}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file lib_graph.c.}\par
}
{\xe \v dest_node_idx\:lib_graph.c}
{\xe \v lib_graph.c\:dest_node_idx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int dest_node_idx = 0}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 23 of file lib_graph.c.}\par
}
{\xe \v dijk_dataset_vect\:lib_graph.c}
{\xe \v lib_graph.c\:dijk_dataset_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Dijkstra_dataset}* dijk_dataset_vect = NULL}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 24 of file lib_graph.c.}\par
}
{\xe \v min_path_conn_vect\:lib_graph.c}
{\xe \v lib_graph.c\:min_path_conn_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Connection}* min_path_conn_vect = NULL}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file lib_graph.c.}\par
}
{\xe \v min_pth_conn_vect_size\:lib_graph.c}
{\xe \v lib_graph.c\:min_pth_conn_vect_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int min_pth_conn_vect_size = 0}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file lib_graph.c.}\par
}
{\xe \v nds_collect_size\:lib_graph.c}
{\xe \v lib_graph.c\:nds_collect_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int nds_collect_size = 0}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file lib_graph.c.}\par
}
{\xe \v nodes_collect_vect\:lib_graph.c}
{\xe \v lib_graph.c\:nodes_collect_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Node}* nodes_collect_vect = NULL}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file lib_graph.c.}\par
}
{\xe \v realloc_flg\:lib_graph.c}
{\xe \v lib_graph.c\:realloc_flg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Byte} realloc_flg = 0}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 25 of file lib_graph.c.}\par
}
{\xe \v src_node_idx\:lib_graph.c}
{\xe \v lib_graph.c\:src_node_idx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int src_node_idx = 0}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 23 of file lib_graph.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/graph/lib_graph.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/graph/lib_graph.h}
{\xe \v lib/graph/lib_graph.h}
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../ui/lib_ui.h"}\par
{\f2 #include "../timer/lib_timer.h"}\par
{\f2 #include <limits.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b list_elem}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b node}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b arch}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dijkstra_dataset}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b connection}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ND_STR_LEN}\~ 31\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AR_STR_LEN}\~ 31\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SEP_CHR}\~ '-'\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHORT_PTH_SEP_CHR}\~ '*'\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PRINT_DLY_MS}\~ 500\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b list_elem} {\b List_elem}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b List_elem} * {\b List}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b node} {\b Node}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b Node} * {\b Graph_node}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b arch} {\b Arch}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b Arch} * {\b Graph_arch}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b dijkstra_dataset} {\b Dijkstra_dataset}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b connection} {\b Connection}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b vect_coords} {\b Vect_coords}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b verbose_mode} {\b Verbose_mode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b obj_type} {\b Obj_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b node_pos_in_arch} {\b Node_pos_in_arch}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b arch_pos_typ} {\b Arch_pos_typ}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b vect_coords} \{ {\b V}, 
{\b V2}, 
{\b V3}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b verbose_mode} \{ {\b Y}, 
{\b N}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b obj_type} \{ {\b AR}, 
{\b ND}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b node_pos_in_arch} \{ {\b ARCH_ND1}, 
{\b ARCH_ND2}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b arch_pos_typ} \{ {\b LIST_HEAD}, 
{\b LIST_POS}, 
{\b LIST_TAIL}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b idx_by_name} ({\b Obj_type} object_type, {\b C_str} object_name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add_new_arch} ({\b C_str}, {\b C_real} cost)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add_new_node} ({\b C_str} name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b connect_node_arch} ({\b C_str} ar_name, {\b C_str} nd_name, {\b Node_pos_in_arch} nd_pos, {\b Arch_pos_typ} ar_pos,...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dijkstra_alg} ({\b C_str} src_nd_name, {\b Verbose_mode} v_mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b buid_shortest_path} ({\b C_str} dest_nd_name, {\b Verbose_mode} v_mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b free_graph} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b C_str} {\b node_pos_in_arch_str} [] = \{"ARCH NODE1 POSITION", "ARCH NODE2 POSITION"\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b C_str} {\b arch_pos_typ_str} [] = \{"LIST HEAD POSITION", "LIST SPECIFIC POSITION", "LIST TAIL POSITION"\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Real} {\b _REAL_MAX}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ars_collect_size}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b nds_collect_size}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b min_pth_conn_vect_size}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Arch} * {\b archs_collect_vect}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Node} * {\b nodes_collect_vect}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Connection} * {\b min_path_conn_vect}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v AR_STR_LEN\:lib_graph.h}
{\xe \v lib_graph.h\:AR_STR_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AR_STR_LEN\~ 31}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file lib_graph.h.}\par
}
{\xe \v ND_STR_LEN\:lib_graph.h}
{\xe \v lib_graph.h\:ND_STR_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ND_STR_LEN\~ 31}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file lib_graph.h.}\par
}
{\xe \v PRINT_DLY_MS\:lib_graph.h}
{\xe \v lib_graph.h\:PRINT_DLY_MS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PRINT_DLY_MS\~ 500}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 21 of file lib_graph.h.}\par
}
{\xe \v SEP_CHR\:lib_graph.h}
{\xe \v lib_graph.h\:SEP_CHR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SEP_CHR\~ '-'}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file lib_graph.h.}\par
}
{\xe \v SHORT_PTH_SEP_CHR\:lib_graph.h}
{\xe \v lib_graph.h\:SHORT_PTH_SEP_CHR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHORT_PTH_SEP_CHR\~ '*'}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v Arch\:lib_graph.h}
{\xe \v lib_graph.h\:Arch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b arch} {\b Arch}}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Arch_pos_typ\:lib_graph.h}
{\xe \v lib_graph.h\:Arch_pos_typ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b arch_pos_typ} {\b Arch_pos_typ}}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Connection\:lib_graph.h}
{\xe \v lib_graph.h\:Connection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b connection} {\b Connection}}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Dijkstra_dataset\:lib_graph.h}
{\xe \v lib_graph.h\:Dijkstra_dataset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b dijkstra_dataset} {\b Dijkstra_dataset}}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Graph_arch\:lib_graph.h}
{\xe \v lib_graph.h\:Graph_arch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b Arch}* {\b Graph_arch}}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file lib_graph.h.}\par
}
{\xe \v Graph_node\:lib_graph.h}
{\xe \v lib_graph.h\:Graph_node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b Node}* {\b Graph_node}}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file lib_graph.h.}\par
}
{\xe \v List\:lib_graph.h}
{\xe \v lib_graph.h\:List}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b List_elem}* {\b List}}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 30 of file lib_graph.h.}\par
}
{\xe \v List_elem\:lib_graph.h}
{\xe \v lib_graph.h\:List_elem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b list_elem} {\b List_elem}}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Node\:lib_graph.h}
{\xe \v lib_graph.h\:Node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b node} {\b Node}}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Node_pos_in_arch\:lib_graph.h}
{\xe \v lib_graph.h\:Node_pos_in_arch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b node_pos_in_arch} {\b Node_pos_in_arch}}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Obj_type\:lib_graph.h}
{\xe \v lib_graph.h\:Obj_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b obj_type} {\b Obj_type}}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Vect_coords\:lib_graph.h}
{\xe \v lib_graph.h\:Vect_coords}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b vect_coords} {\b Vect_coords}}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Verbose_mode\:lib_graph.h}
{\xe \v lib_graph.h\:Verbose_mode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b verbose_mode} {\b Verbose_mode}}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v arch_pos_typ\:lib_graph.h}
{\xe \v lib_graph.h\:arch_pos_typ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b arch_pos_typ}}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v LIST_HEAD\:lib_graph.h}
{\xe \v lib_graph.h\:LIST_HEAD}
{\qr LIST_HEAD{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
\cell }{\cell }{\row }
{\xe \v LIST_POS\:lib_graph.h}
{\xe \v lib_graph.h\:LIST_POS}
{\qr LIST_POS{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
\cell }{\cell }{\row }
{\xe \v LIST_TAIL\:lib_graph.h}
{\xe \v lib_graph.h\:LIST_TAIL}
{\qr LIST_TAIL{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
\cell }{\cell }{\row }
}
\par
{
Definition at line 71 of file lib_graph.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00071 \{LIST_HEAD, LIST_POS, LIST_TAIL\} Arch_pos_typ;                                    {\cf20 // Position type to add arch in node arches connections list enum typedef}\par
}
}
{\xe \v node_pos_in_arch\:lib_graph.h}
{\xe \v lib_graph.h\:node_pos_in_arch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b node_pos_in_arch}}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v ARCH_ND1\:lib_graph.h}
{\xe \v lib_graph.h\:ARCH_ND1}
{\qr ARCH_ND1{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
\cell }{\cell }{\row }
{\xe \v ARCH_ND2\:lib_graph.h}
{\xe \v lib_graph.h\:ARCH_ND2}
{\qr ARCH_ND2{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
\cell }{\cell }{\row }
}
\par
{
Definition at line 68 of file lib_graph.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00068 \{ARCH_ND1, ARCH_ND2\} Node_pos_in_arch;                                  {\cf20 // Node position in arch enum typedef}\par
}
}
{\xe \v obj_type\:lib_graph.h}
{\xe \v lib_graph.h\:obj_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b obj_type}}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v AR\:lib_graph.h}
{\xe \v lib_graph.h\:AR}
{\qr AR{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
\cell }{\cell }{\row }
{\xe \v ND\:lib_graph.h}
{\xe \v lib_graph.h\:ND}
{\qr ND{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
\cell }{\cell }{\row }
}
\par
{
Definition at line 66 of file lib_graph.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00066 \{AR, ND\} Obj_type;                                                              {\cf20 // Object type enum typedef (arch/node)}\par
}
}
{\xe \v vect_coords\:lib_graph.h}
{\xe \v lib_graph.h\:vect_coords}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b vect_coords}}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v V\:lib_graph.h}
{\xe \v lib_graph.h\:V}
{\qr V{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
\cell }{\cell }{\row }
{\xe \v V2\:lib_graph.h}
{\xe \v lib_graph.h\:V2}
{\qr V2{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
\cell }{\cell }{\row }
{\xe \v V3\:lib_graph.h}
{\xe \v lib_graph.h\:V3}
{\qr V3{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
\cell }{\cell }{\row }
}
\par
{
Definition at line 62 of file lib_graph.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00062 \{V, V2, V3\} Vect_coords;                                                     {\cf20 // Matrix/vectors enum typedef}\par
}
}
{\xe \v verbose_mode\:lib_graph.h}
{\xe \v lib_graph.h\:verbose_mode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b verbose_mode}}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Y\:lib_graph.h}
{\xe \v lib_graph.h\:Y}
{\qr Y{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
\cell }{\cell }{\row }
{\xe \v N\:lib_graph.h}
{\xe \v lib_graph.h\:N}
{\qr N{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
\cell }{\cell }{\row }
}
\par
{
Definition at line 64 of file lib_graph.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00064 \{Y, N\} Verbose_mode;                                                        {\cf20 // Verbose mode enum typedef}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v add_new_arch\:lib_graph.h}
{\xe \v lib_graph.h\:add_new_arch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void add_new_arch ({\b C_str} , {\b C_real}  {\i cost})}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 336 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00336                                           \{                                                                 {\cf20 // Function to add new graph arch (arch allocated inside heap)}\par
00337   {\cf20 /* Body */}\par
00338   fbk_nl(1);  fbk_gn_pu({\cf22 "Adding new graph arch..."});                                                        {\cf20 // Adding new graph arch fbk}\par
00339   {\cf19 if} (cost > 0.0)\{                                                                                          {\cf20 // If cost is positive}\par
00340     {\cf19 if} (archs_collect_vect == NULL)                                                                         {\cf20 // Check arches collection vector, if null}\par
00341       allocate_new_archs();                                                                                 {\cf20 // Allocate a new graph arch inside arches collection vector (vect calloc)}\par
00342     {\cf19 else}                                                                                                    {\cf20 // Else if not null}\par
00343       reallocate_new_archs();                                                                               {\cf20 // Allocate a new graph arch inside arches collection vector (vect realloc)}\par
00344     {\cf19 if} (strlen(name) > 0 && strlen(name) < AR_STR_LEN)\{                                                     {\cf20 // Check arch name length consistency, if ok}\par
00345       strcpy(archs_collect_vect[ars_collect_size-1].name, name);  fbk_nl(1);                                {\cf20 // Copy name inside arch name var}\par
00346     \} {\cf19 else} \{                                                                                                {\cf20 // Else if arch name length consistency ain't ok}\par
00347       fbk_err({\cf22 "Error, invalid arch name size! Overriding arch name with arch number in collection"});        {\cf20 // Print error fbk}\par
00348       {\cf18 char} name_ovrd[AR_STR_LEN];                                                                           {\cf20 // Define new name to override input name}\par
00349       sprintf(name_ovrd, {\cf22 "%d"}, ars_collect_size);                                                           {\cf20 // Define override-name as arch number in arches collection vect}\par
00350       strcpy(archs_collect_vect[ars_collect_size-1].name, name_ovrd);                                       {\cf20 // Copy override-name inside arch name var}\par
00351     \}\par
00352     archs_collect_vect[ars_collect_size-1].cost = cost;                                                     {\cf20 // Define arch cost}\par
00353     archs_collect_vect[ars_collect_size-1].nd1 = NULL;                                                      {\cf20 // Set node1 connection to NULL}\par
00354     archs_collect_vect[ars_collect_size-1].nd2 = NULL;                                                      {\cf20 // Set node2 connection to NULL}\par
00355     fbk_gn_lbu_ye_str({\cf22 "New arch name"}, archs_collect_vect[ars_collect_size-1].name);                        {\cf20 // New graph arch name fbk}\par
00356     fbk_nl(1);  fbk_gn_lbu_ye_real({\cf22 "New arch cost"}, archs_collect_vect[ars_collect_size-1].cost);           {\cf20 // New graph arch cost fbk}\par
00357     fbk_nl(1);  fbk_gn_cy({\cf22 "New graph arch correctly added!\\n"});                                             {\cf20 // New graph arch correctly added fbk}\par
00358   \} {\cf19 else} \{                                                                                                  {\cf20 // Else if cost ain't positive}\par
00359     fbk_err({\cf22 "Ops! Encountred error during graph data management"});                                          {\cf20 // Error fbk}\par
00360     perror({\cf22 "Found error during arch object creation, its cost must be strictly positive!"});                 {\cf20 // Print perror fbk}\par
00361     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00362     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00363   \}\par
00364 \}\par
}
}
{\xe \v add_new_node\:lib_graph.h}
{\xe \v lib_graph.h\:add_new_node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void add_new_node ({\b C_str}  {\i name})}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 367 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00367                              \{                                                                              {\cf20 // Function to add new graph node (node allocated inside heap)}\par
00368   {\cf20 /* Body */}\par
00369   fbk_nl(1);  fbk_gn_pu({\cf22 "Adding new graph node..."});                                                        {\cf20 // Adding new graph node fbk}\par
00370   {\cf19 if} (nodes_collect_vect == NULL)                                                                           {\cf20 // Check nodes collection vector, if null}\par
00371     allocate_new_nodes();                                                                                   {\cf20 // Allocate a new graph node inside nodes collection vector (vect calloc)}\par
00372   {\cf19 else}                                                                                                      {\cf20 // Else if not null}\par
00373     reallocate_new_nodes();                                                                                 {\cf20 // Allocate a new graph node inside nodes collection vector (vect realloc)}\par
00374   {\cf19 if} (strlen(name) > 0 && strlen(name) < ND_STR_LEN)\{                                                       {\cf20 // Check node name length consistency, if ok}\par
00375     strcpy(nodes_collect_vect[nds_collect_size-1].name, name);  fbk_nl(1);                                  {\cf20 // Copy name inside node name var}\par
00376   \} {\cf19 else} \{                                                                                                  {\cf20 // Else if node name length consistency ain't ok}\par
00377     fbk_err({\cf22 "Error, invalid node name size! Overriding arch name with node number in collection"});          {\cf20 // Print error fbk}\par
00378     {\cf18 char} name_ovrd[ND_STR_LEN];                                                                             {\cf20 // Define new name to override input name}\par
00379     sprintf(name_ovrd, {\cf22 "%d"}, nds_collect_size);                                                             {\cf20 // Define override-name as node number in arches collection vect}\par
00380     strcpy(nodes_collect_vect[nds_collect_size-1].name, name_ovrd);                                         {\cf20 // Copy override-name inside node name var}\par
00381   \}\par
00382   nodes_collect_vect[nds_collect_size-1].archs_lst = NULL;                                                  {\cf20 // Set node arches list to NULL}\par
00383   nodes_collect_vect[nds_collect_size-1].dd = NULL;                                                         {\cf20 // Set node Dijkstra-dataset to NULL}\par
00384   fbk_gn_lbu_ye_str({\cf22 "New node name"}, nodes_collect_vect[nds_collect_size-1].name);                          {\cf20 // New graph arch name fbk}\par
00385   fbk_nl(1);  fbk_gn_cy({\cf22 "New graph node correctly added!\\n"});                                               {\cf20 // New graph node correctly added fbk}\par
00386 \}\par
}
}
{\xe \v buid_shortest_path\:lib_graph.h}
{\xe \v lib_graph.h\:buid_shortest_path}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void buid_shortest_path ({\b C_str}  {\i dest_nd_name}, {\b Verbose_mode}  {\i v_mode})}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 514 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00514                                                                 \{                                           {\cf20 // Reconstruct shortest path to specified destination node from source node (pre-defined in Dijkstra's algorithm, min path connections vect allocated/reallocated inside heap) - Y/N for verbose mode}\par
00515   {\cf20 /* Body */}\par
00516   fbk_nl(1);  fbk_gn_pu({\cf22 "Building min cost path from pre-defined source to specified destination..."});      {\cf20 // Print reconstructin' shortest path from pre-defined source to specified destination fbk}\par
00517   {\cf19 if} (realloc_flg != 0)\{                                                                                    {\cf20 // If Dijkstra's algorithm has already been called at least once}\par
00518     {\cf20 // Print info fbks}\par
00519     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "--> Source node name"}, nodes_collect_vect[src_node_idx].name);           {\cf20 // Print src-nd name fbk}\par
00520     {\cf18 int} dest_nd_num = idx_by_name(ND, dest_nd_name);                                                        {\cf20 // Get destination node idx by-name}\par
00521     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "--> Destination node name"}, dest_nd_name);                               {\cf20 // Print dest-nd name fbk}\par
00522     {\cf19 if} (dest_nd_num >= 0)\{                                                                                  {\cf20 // Check error conditions ok}\par
00523       dest_node_idx = dest_nd_num;                                                                          {\cf20 // Set/upd destination node idx lib-var val}\par
00524       {\cf19 if} (nodes_collect_vect[dest_nd_num].dd->min_path_cost < _REAL_MAX_ && dest_nd_num != src_node_idx)\{   {\cf20 // If destination node is reachble from pre-defined source node}\par
00525         fbk_nl(1);                                                                                          {\cf20 // Print new-line fbk}\par
00526         fbk_gn_lbu_ye_real({\cf22 "Min path cost to node"}, nodes_collect_vect[dest_nd_num].dd->min_path_cost);     {\cf20 // Print min path cost to reach destination node from pre-defined source node fbk}\par
00527       \} {\cf19 else} {\cf19 if} (dest_nd_num == src_node_idx)\{                                                              {\cf20 // Else if destination node memo addr corresponds to the source node memo addr}\par
00528         fbk_nl(1);                                                                                          {\cf20 // Print new-line fbk}\par
00529         fbk_gn_lbu_ye_str({\cf22 "Min path cost to node"}, {\cf22 "Destination corresponds to pre-defined source node!"});  {\cf20 // Print destination node correspondin' to the pre-defined source node fbk}\par
00530       \} {\cf19 else} \{                                                                                              {\cf20 // Else if destination node is unreachble from pre-defined source node}\par
00531         fbk_nl(1);                                                                                          {\cf20 // Print new-line fbk}\par
00532         fbk_gn_lbu_ye_str({\cf22 "Min path cost to node"}, {\cf22 "Destination unreachble from pre-defined source node!"}); {\cf20 // Print destination node unreachble fbk}\par
00533       \}\par
00534       {\cf20 // Find min-cost path archs & nodes goin' backward from destination to source node}\par
00535       Graph_node tmp_nd = &nodes_collect_vect[dest_nd_num];                                                 {\cf20 // Init tmp node var to reconstruct min-cost path backwards}\par
00536       List_elem* tmpl = NULL;                                                                               {\cf20 // Def tmp list ptr var (for archs) to reconstruct min-cost path backwards}\par
00537       {\cf19 if} (min_pth_conn_vect_size != 0)                                                                      {\cf20 // If min-cost paths vector size ain't zero}\par
00538         min_pth_conn_vect_size = 0;                                                                         {\cf20 // Make it zero}\par
00539       {\cf19 while} (tmp_nd != NULL)\{                                                                               {\cf20 // Scroll min-cost path backwars 'till src node}\par
00540         {\cf19 if} (realloc_flg == 0)\{                                                                              {\cf20 // If realloc flag ain't been set}\par
00541           min_path_conn_vect = allocate_new_nd_conn_vect(++min_pth_conn_vect_size);                         {\cf20 // Allocate (inside heap) a new min path connections vector}\par
00542           ++realloc_flg;                                                                                    {\cf20 // And then upd realloc flag val to use reallocs instead of callocs 'till "free_graph()" funct call}\par
00543         \} {\cf19 else}                                                                                              {\cf20 // Else if realloc flag has already been set}\par
00544           reallocate_nd_conn_vect(&min_path_conn_vect, ++min_pth_conn_vect_size);                           {\cf20 // Reallocate (inside heap) the min path connections vector}\par
00545         tmpl = tmp_nd->archs_lst;                                                                           {\cf20 // Init tmp archs list ptr var}\par
00546         {\cf19 for} (; tmpl != NULL; tmpl = tmpl->nxt)\{                                                             {\cf20 // Scroll min-cost parh node connection archs list to find min-cost path connection arch}\par
00547           {\cf19 if} ((tmp_nd == tmpl->ar->nd1 && tmpl->ar->nd2 == tmp_nd->dd->prev_nd) ||\par
00548               (tmp_nd == tmpl->ar->nd2 && tmpl->ar->nd1 == tmp_nd->dd->prev_nd))\{                           {\cf20 // Min-cost path connection arch detectin' cond}\par
00549             (min_path_conn_vect+iaddr(V, min_pth_conn_vect_size-1, min_pth_conn_vect_size))->ar = tmpl->ar; {\cf20 // Save arch ptr val inside min path connections vector (min-path connection arch)}\par
00550           \}\par
00551         \}\par
00552         (min_path_conn_vect+iaddr(V, min_pth_conn_vect_size-1, min_pth_conn_vect_size))->nd = tmp_nd;       {\cf20 // Save node ptr val inside min path connections vector (min-path connection node)}\par
00553         tmp_nd = tmp_nd->dd->prev_nd;                                                                       {\cf20 // Upd tmp node var to reconstruct min-cost path backwards}\par
00554       \}\par
00555       {\cf20 // Swap elements to obtain shortest path (backward-to-forward path conversion)}\par
00556       Connection tmp_conn;                                                                                  {\cf20 // Tmp connection var to swap connections}\par
00557       {\cf19 for} ({\cf18 int} i = 0; i < min_pth_conn_vect_size/2; ++i)\{                                                   {\cf20 // Half min path connections vector scrollin' FOR cycle}\par
00558         tmp_conn = min_path_conn_vect[i];                                                                   {\cf20 // Define tmp var to swap connections}\par
00559         min_path_conn_vect[i] = min_path_conn_vect[min_pth_conn_vect_size-1-i];                             {\cf20 // Swap-step1}\par
00560         min_path_conn_vect[min_pth_conn_vect_size-i-1] = tmp_conn;                                          {\cf20 // Swap-step2}\par
00561       \}\par
00562       {\cf20 // Print shortest path from pre-defined source node to specified destination node}\par
00563       {\cf19 if} (v_mode == Y)                                                                                      {\cf20 // If verbose mode is enabled, print fbks}\par
00564         print_shortest_path();                                                                              {\cf20 // Print shortest path funct call}\par
00565       fbk_nl(1);  fbk_gn_cy({\cf22 "Destination node min cost path correctly identified!\\n"});                      {\cf20 // Print destination node min cost path correctly identified fbk}\par
00566     \} {\cf19 else}                                                                                                  {\cf20 // If error conditions ain't ok}\par
00567       fbk_err({\cf22 "Error, not able to find destination node min cost path with Dijkstra's algorithm"});          {\cf20 // Print error fbk}\par
00568   \} {\cf19 else}                                                                                                    {\cf20 // Else if Dijkstra's algorithm ain't been called}\par
00569     fbk_err({\cf22 "Error, min path can be reconstructed only after having called Dijkstra's algorithm!"});         {\cf20 // Print error fbk}\par
00570 \}\par
}
}
{\xe \v connect_node_arch\:lib_graph.h}
{\xe \v lib_graph.h\:connect_node_arch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void connect_node_arch ({\b C_str}  {\i ar_name}, {\b C_str}  {\i nd_name}, {\b Node_pos_in_arch}  {\i nd_pos}, {\b Arch_pos_typ}  {\i ar_pos},   {\i ...})}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 389 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00389                                                                                                        \{    {\cf20 // Function to connect arch-node in graph (new arch list element allocated inside heap, opt param --> arch pos in arches list, non-zero index)}\par
00390   {\cf20 /* Body */}\par
00391   fbk_nl(1);  fbk_gn_pu({\cf22 "Creating bidirectional connection between node and arch..."});                      {\cf20 // Creatin' bidirectional connection between node and arch}\par
00392   {\cf18 int} ar_num = idx_by_name(AR, ar_name);                                                                    {\cf20 // Get arch idx by-name}\par
00393   {\cf18 int} nd_num = idx_by_name(ND, nd_name);                                                                    {\cf20 // Get node idx by-name}\par
00394   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Working on node"}, nd_name);                                                {\cf20 // Print node name fbk}\par
00395   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Working on arch"}, ar_name);                                                {\cf20 // Print arch name fbk}\par
00396   {\cf18 int} lst_pos = 0;                                                                                          {\cf20 // List position in which arch must be placed in node conn. arches list}\par
00397   {\cf20 // Function optional parameters management}\par
00398   {\cf19 if} (ar_pos == LIST_POS)\{                                                                                  {\cf20 // If selected arch position type in list is specific position, read list position optional parameter}\par
00399     va_list args_lst;                                                                                       {\cf20 // Function optional parameters list int}\par
00400     va_start(args_lst, ar_pos);                                                                             {\cf20 // Define optional params list startin' point}\par
00401     lst_pos = va_arg(args_lst, {\cf18 int});                                                                        {\cf20 // Read the first optional parameter in funct opt params list (= define list position)}\par
00402   \}\par
00403   {\cf19 if} (nd_num >= 0 && ar_num >= 0 && ((ar_pos == LIST_POS && lst_pos >= 1) || ar_pos != LIST_POS))\{          {\cf20 // Check error conditions ok}\par
00404     {\cf20 // Assign node to arch}\par
00405     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Connecting node to"}, node_pos_in_arch_str[nd_pos]);                      {\cf20 // Connectin' node to arch fbk}\par
00406     {\cf19 switch} (nd_pos)\{                                                                                        {\cf20 // Node assignin' position in arch switch-case (where to assign node in arch)}\par
00407       {\cf19 case} ARCH_ND1:                                                                                        {\cf20 // Case: assign node to arch node1 position}\par
00408         archs_collect_vect[ar_num].nd1 = &nodes_collect_vect[nd_num];                                       {\cf20 // Assign node to arch node1 pos}\par
00409         {\cf19 break};\par
00411       {\cf19 case} ARCH_ND2:                                                                                        {\cf20 // Case: assign node to arch node2 position}\par
00412         archs_collect_vect[ar_num].nd2 = &nodes_collect_vect[nd_num];                                       {\cf20 // Assign node to arch node2 pos}\par
00413         {\cf19 break};\par
00415       {\cf19 default}:                                                                                              {\cf20 // Unknown case}\par
00416         fbk_err({\cf22 "Error, bad parameter value! A function got an unexpected patameter value"});                {\cf20 // Print error fbk}\par
00417         perror({\cf22 "Wrong \\"nd_pos\\" parameter value passsed to \\"connect_node_arch\\" function!"});              {\cf20 // Print perror fbk}\par
00418         {\cf19 break};\par
00419     \}\par
00420     {\cf20 // Assign arch to node}\par
00421     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Connecting arch to node connection archs"}, arch_pos_typ_str[ar_pos]);    {\cf20 // Connectin' node to arch fbk}\par
00422     List_elem* tmp_el = allocate_new_list_elems(1);                                                         {\cf20 // Tmp list element ptr creation}\par
00423     tmp_el->ar = &archs_collect_vect[ar_num];                                                               {\cf20 // Tmp list element ptr def with input arch memo cell addr}\par
00424     {\cf19 switch} (ar_pos)\{                                                                                        {\cf20 // Arch assignin' position type in node arches list switch-case (where to assign arch in node arches connections list) switch-case}\par
00425       {\cf19 case} LIST_HEAD:                                                                                       {\cf20 // Case: assign arch to node arches connections list (head position)}\par
00426         add_elem_at_list_head(&nodes_collect_vect[nd_num].archs_lst, tmp_el);                               {\cf20 // Assign arch (in tmp list element) to the specified node conn. arches list (head position)}\par
00427         {\cf19 break};\par
00429       {\cf19 case} LIST_POS:                                                                                        {\cf20 // Case: assign arch to node arches connections list (specific position, pos from optional funct param)}\par
00430         fbk_nl(1);  fbk_gn_lbu_ye_int({\cf22 "Specific list position number"}, lst_pos);                            {\cf20 // Specific list position num fbk}\par
00431         add_elem_at_list_pos(&nodes_collect_vect[nd_num].archs_lst, tmp_el, lst_pos);                       {\cf20 // Assign arch (in tmp list element) to the specified node conn. arches list (specific position, non-zero index)}\par
00432         {\cf19 break};\par
00434       {\cf19 case} LIST_TAIL:                                                                                       {\cf20 // Case: assign arch to node arches connections list (tail position)}\par
00435         add_elem_at_list_tail(&nodes_collect_vect[nd_num].archs_lst, tmp_el);                               {\cf20 // Assign arch (in tmp list element) to the specified node conn. arches list (tail position)}\par
00436         {\cf19 break};\par
00438       {\cf19 default}:                                                                                              {\cf20 // Unknown case}\par
00439         fbk_err({\cf22 "Error, bad parameter value! A function got an unexpected patameter value"});                {\cf20 // Print error fbk}\par
00440         perror({\cf22 "Wrong \\"ar_pos\\" parameter value passsed to \\"connect_node_arch\\" function!"});              {\cf20 // Print perror fbk}\par
00441         {\cf19 break};\par
00442     \}\par
00443     fbk_nl(1);  fbk_gn_cy({\cf22 "Bidirectional node-arch connetion correctly created!\\n"});                        {\cf20 // Bidirectional node-arch connection correctly created fbk}\par
00444   \} {\cf19 else} \{                                                                                                  {\cf20 // If error conditions ain't ok}\par
00445     fbk_err({\cf22 "Error, not able to create arch-node connection! Connection not created"});                      {\cf20 // Print error fbk}\par
00446     {\cf19 if} (ar_pos == LIST_POS && lst_pos < 1)                                                                  {\cf20 // List pos err detect cond}\par
00447       fbk_err({\cf22 "Error casued by specific list position flag enabled and invalid position value"});            {\cf20 // Print error fbk}\par
00448   \}\par
00449 \}\par
}
}
{\xe \v dijkstra_alg\:lib_graph.h}
{\xe \v lib_graph.h\:dijkstra_alg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dijkstra_alg ({\b C_str}  {\i src_nd_name}, {\b Verbose_mode}  {\i v_mode})}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 452 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00452                                                          \{                                                  {\cf20 // Dijkstra's alg to find min graph-path btwn source and each destination node (Dijkstra-dataset vect allocated/reallocated inside heap) - Y/N for verbose mode}\par
00453   {\cf20 /* Body */}\par
00454   fbk_nl(1);  fbk_gn_pu({\cf22 "Looking for min path costs from specified source with Dijkstra's algorithm..."});   {\cf20 // Print lookin' 4 shortest path btwn spec src and each dest nd fbk}\par
00455   {\cf18 int} src_nd_num = idx_by_name(ND, src_nd_name);                                                            {\cf20 // Get source node idx by-name}\par
00456   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Source node name"}, src_nd_name);                                           {\cf20 // Print source node name}\par
00457   {\cf19 if} (src_nd_num >= 0)\{                                                                                     {\cf20 // Check error conditions ok}\par
00458     {\cf20 // Algorithm inits}\par
00459     {\cf18 int} min_cost_idx = 0;                                                                                   {\cf20 // Min cost node idx in dataset var init}\par
00460     Real min_cost_val = 0.0;                                                                                {\cf20 // Min cost node val in dataset var init}\par
00461     {\cf18 int} nan_nd_conn_vect_size = 0;                                                                          {\cf20 // Node (non-analyzed) connections vector size var to store selected node non-analyzed connections init}\par
00462     Real new_cost = 0.0;                                                                                    {\cf20 // New cost var init}\par
00463     Connection* nan_nd_conn_vect = NULL;                                                                    {\cf20 // Node (non-analyzed) connections vector ptr var decl}\par
00464     {\cf19 if} (realloc_flg == 0)\{                                                                                  {\cf20 // If realloc flag ain't set}\par
00465       allocate_new_dijk_dataset_vect();                                                                     {\cf20 // Dijkstra-dataset vect init (vector allocated inside heap)}\par
00466       ++realloc_flg;                                                                                        {\cf20 // Set realloc flg}\par
00467     \} {\cf19 else}                                                                                                  {\cf20 // Else if realloc flag has been set}\par
00468       reallocate_dijk_dataset_vect();                                                                       {\cf20 // Dijkstra-dataset vect realloc (vector reallocated inside heap)}\par
00469     {\cf19 for} ({\cf18 int} i = 0; i < nds_collect_size; ++i)\{                                                             {\cf20 // Inits FOR cycle}\par
00470       nodes_collect_vect[i].dd = &dijk_dataset_vect[i];                                                     {\cf20 // Define and init nodes Dijkstra-datasets}\par
00471       nodes_collect_vect[i].dd->prev_nd = NULL;                                                             {\cf20 // Node dataset prev node init}\par
00472       nodes_collect_vect[i].dd->an_flg = 0;                                                                 {\cf20 // Node dataset analyzed flag val preset (as not analyzed)}\par
00473       {\cf19 if} (i != src_nd_num)                                                                                  {\cf20 // If node is different from source node}\par
00474         nodes_collect_vect[i].dd->min_path_cost = _REAL_MAX_;                                               {\cf20 // Init unknown min costs from source node (preset val --> +inf)}\par
00475       {\cf19 else}                                                                                                  {\cf20 // Else if node ain't different from source node}\par
00476         nodes_collect_vect[i].dd->min_path_cost = 0;                                                        {\cf20 // Init source-to-source cost (preset val --> zero)}\par
00477     \}\par
00478     src_node_idx = src_nd_num;                                                                              {\cf20 // Set/upd source node idx lib-var val}\par
00479     {\cf20 // Algorithm loop}\par
00480     {\cf19 for} ({\cf18 int} j = 0; j < nds_collect_size-1; ++j)\{                                                           {\cf20 // Main algo loop}\par
00481       {\cf20 // Select node with min-cost path}\par
00482       min_cost_val = _REAL_MAX_;                                                                            {\cf20 // Min cost node val in dataset upd}\par
00483       {\cf19 for} ({\cf18 int} k = 0; k < nds_collect_size; ++k)\{                                                           {\cf20 // Scroll the entire nodes collection 2 detect min cost path node}\par
00484         {\cf19 if} (nodes_collect_vect[k].dd->an_flg == 0 &&\par
00485             nodes_collect_vect[k].dd->min_path_cost < min_cost_val)\{                                        {\cf20 // Min cost path node detectin' cond (min val and node not alredy analized)}\par
00486           min_cost_val = nodes_collect_vect[k].dd->min_path_cost;                                           {\cf20 // If detectin' cond is met, upd min cost node val}\par
00487           min_cost_idx = k;                                                                                 {\cf20 // And upd min cost node idx}\par
00488         \}\par
00489       \}\par
00490       ++nodes_collect_vect[min_cost_idx].dd->an_flg;                                                        {\cf20 // Mark selected node as alredy analized b4 processin' it}\par
00491       {\cf20 // Find non-analyzed connections of selected node}\par
00492       nan_nd_conn_vect_size = 0;                                                                            {\cf20 // Node (non-analyzed) connections vector size var to store selected node non-analyzed connections (rst)}\par
00493       nan_nd_conn_vect = not_an_node_conn(&nodes_collect_vect[min_cost_idx], &nan_nd_conn_vect_size);       {\cf20 // Define selected node non-analyzed connections vect (vector allocated inside heap)}\par
00494       {\cf19 for} ({\cf18 int} l = 0; l < nan_nd_conn_vect_size; ++l)\{                                                      {\cf20 // Scroll selected node non-analyzed connections vect}\par
00495         new_cost = nodes_collect_vect[min_cost_idx].dd->min_path_cost+nan_nd_conn_vect[l].ar->cost;         {\cf20 // New cost val upd}\par
00496         {\cf20 // Upd min path cost and previous node in shortest path}\par
00497         {\cf19 if} (new_cost < nan_nd_conn_vect[l].nd->dd->min_path_cost)\{                                          {\cf20 // In case new cost val is less than min cost val}\par
00498           nan_nd_conn_vect[l].nd->dd->min_path_cost = new_cost;                                             {\cf20 // Upd min cost val}\par
00499           nan_nd_conn_vect[l].nd->dd->prev_nd = &nodes_collect_vect[min_cost_idx];                          {\cf20 // Upd previous min path node}\par
00500         \}\par
00501       \}\par
00502       {\cf19 if} (nan_nd_conn_vect != NULL)                                                                         {\cf20 // If node non-analyzed connections vector was correctly defined}\par
00503         free(nan_nd_conn_vect);                                                                             {\cf20 // Free node non-analyzed connections vector allocated inside heap}\par
00504     \}\par
00505     {\cf20 // Print each min path cost to reach every single accessible node from specified source-node}\par
00506     {\cf19 if} (v_mode == Y)                                                                                        {\cf20 // If verbose mode is enabled, print fbks}\par
00507       print_min_paths();                                                                                    {\cf20 // Print min paths funct call}\par
00508     fbk_nl(1);  fbk_gn_cy({\cf22 "Min path costs correctly found!\\n"});                                             {\cf20 // Print min path costs correctly found fbk}\par
00509   \} {\cf19 else}                                                                                                    {\cf20 // If error conditions ain't ok}\par
00510     fbk_err({\cf22 "Error, not able to find min path costs with Dijkstra's algorithm"});                            {\cf20 // Print error fbk}\par
00511 \}\par
}
}
{\xe \v free_graph\:lib_graph.h}
{\xe \v lib_graph.h\:free_graph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void free_graph ()}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 573 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00573                  \{                                                                                          {\cf20 // Function to free graph allocated memory inside heap}\par
00574   {\cf20 /* Body */}\par
00575   fbk_nl(1);  fbk_gn_pu({\cf22 "Clearing the whole graph structure..."});                                           {\cf20 // Clearing the whole graph from heap fbk}\par
00576   {\cf19 for} ({\cf18 int} i = 0; i < nds_collect_size; ++i)                                                                {\cf20 // Graph nodes scrollin' FOR cycle}\par
00577     {\cf19 if} (nodes_collect_vect[i].archs_lst != NULL)\{                                                           {\cf20 // If node arches list ain't null}\par
00578       free_list_elems(&nodes_collect_vect[i].archs_lst, N);                                                 {\cf20 // Free graph arches list elems associated to each graph node - NO --> without verbose mode}\par
00579       nodes_collect_vect[i].archs_lst = NULL;                                                               {\cf20 // Set node arches list to null}\par
00580     \}\par
00581   {\cf19 if} (archs_collect_vect != NULL)\{                                                                          {\cf20 // If arches collection vector needs to be cleared from heap}\par
00582     free(archs_collect_vect);                                                                               {\cf20 // Free arches collection vector allocated memo inside heap}\par
00583     archs_collect_vect = NULL;                                                                              {\cf20 // Set arches collection vector to null}\par
00584   \}\par
00585   {\cf19 if} (nodes_collect_vect != NULL)\{                                                                          {\cf20 // If nodes collection vector needs to be cleared from heap}\par
00586     free(nodes_collect_vect);                                                                               {\cf20 // Free nodes collection vector allocated memo inside heap}\par
00587     nodes_collect_vect = NULL;                                                                              {\cf20 // Set nodes collection vector to null}\par
00588   \}\par
00589   {\cf19 if} (dijk_dataset_vect != NULL)\{                                                                           {\cf20 // If Dijkstra-dataset vector needs to be cleared from heap}\par
00590     free(dijk_dataset_vect);                                                                                {\cf20 // Free Dijkstra-dataset vector allocated memo inside heap}\par
00591     dijk_dataset_vect = NULL;                                                                               {\cf20 // Set Dijkstra-dataset vector to null}\par
00592   \}\par
00593   {\cf19 if} (min_path_conn_vect != NULL)\{                                                                          {\cf20 // If min path connections vector needs to be cleared from heap}\par
00594     free(min_path_conn_vect);                                                                               {\cf20 // Free min path connections vector allocated memo inside heap}\par
00595     min_path_conn_vect = NULL;                                                                              {\cf20 // Set min path connections vector to null}\par
00596   \}\par
00597   ars_collect_size = 0;                                                                                     {\cf20 // Set graph arches number back to zero}\par
00598   nds_collect_size = 0;                                                                                     {\cf20 // Set graph nodes number back to zero}\par
00599   min_pth_conn_vect_size = 0;                                                                               {\cf20 // Set min path connections vector size back to zero}\par
00600   realloc_flg = 0;                                                                                          {\cf20 // Realloc flag rst}\par
00601   fbk_nl(1);  fbk_gn_cy({\cf22 "Graph structure correctly erased!\\n"});                                             {\cf20 // Graph structure correctly created erased from heap fbk}\par
00602 \}\par
}
}
{\xe \v idx_by_name\:lib_graph.h}
{\xe \v lib_graph.h\:idx_by_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int idx_by_name ({\b Obj_type}  {\i object_type}, {\b C_str}  {\i object_name})}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 308 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00308                                                         \{                                                   {\cf20 // Function to get object (arch/node) vector index by name (-1 = No match found / -2 = Error)}\par
00309   {\cf20 /* Body */}\par
00310   {\cf18 int} match_found = -1;                                                                                     {\cf20 // Match found idx (-1 = No match found / -2 = Error)}\par
00311   {\cf19 switch} (object_type)\{                                                                                     {\cf20 // Object type switch-case}\par
00312     {\cf19 case} AR:                                                                                                {\cf20 // Object type = arch}\par
00313       {\cf19 for} ({\cf18 int} i = 0; i < ars_collect_size; ++i)                                                            {\cf20 // Search match by-name in arches collection vector}\par
00314         {\cf19 if} (strcmp(object_name, archs_collect_vect[i].name) == 0)                                           {\cf20 // Match detecting condition}\par
00315           match_found = i;                                                                                  {\cf20 // Retun match idx in vect}\par
00316       {\cf19 break};\par
00318     {\cf19 case} ND:                                                                                                {\cf20 // Object type = node}\par
00319       {\cf19 for} ({\cf18 int} j = 0; j < nds_collect_size; ++j)                                                            {\cf20 // Search match by-name in nodes collection vector}\par
00320         {\cf19 if} (strcmp(object_name, nodes_collect_vect[j].name) == 0)                                           {\cf20 // Match detecting condition}\par
00321           match_found = j;                                                                                  {\cf20 // Retun match idx in vect}\par
00322       {\cf19 break};\par
00324     {\cf19 default}:                                                                                                {\cf20 // Unknown object type}\par
00325       fbk_err({\cf22 "Error, bad parameter value! A function got an unexpected patameter value"});                  {\cf20 // Print error fbk}\par
00326       perror({\cf22 "Wrong \\"object_type\\" parameter value passsed to \\"idx_by_name\\" function!"});                 {\cf20 // Print perror fbk}\par
00327       --match_found;                                                                                        {\cf20 // Decrease match found val to indicate error}\par
00328       {\cf19 break};\par
00329   \}\par
00330   {\cf19 if} (match_found == -1)                                                                                    {\cf20 // No march found cond}\par
00331     fbk_err({\cf22 "Error, no match found! Specified name probably wrong or not present in collection"});           {\cf20 // Print err fbk}\par
00332   {\cf19 return} match_found;                                                                                       {\cf20 // Return val}\par
00333 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v _REAL_MAX\:lib_graph.h}
{\xe \v lib_graph.h\:_REAL_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Real} _REAL_MAX}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v arch_pos_typ_str\:lib_graph.h}
{\xe \v lib_graph.h\:arch_pos_typ_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b C_str} arch_pos_typ_str[] = \{"LIST HEAD POSITION", "LIST SPECIFIC POSITION", "LIST TAIL POSITION"\}}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file lib_graph.h.}\par
}
{\xe \v archs_collect_vect\:lib_graph.h}
{\xe \v lib_graph.h\:archs_collect_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Arch}* archs_collect_vect}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file lib_graph.c.}\par
}
{\xe \v ars_collect_size\:lib_graph.h}
{\xe \v lib_graph.h\:ars_collect_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ars_collect_size}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file lib_graph.c.}\par
}
{\xe \v min_path_conn_vect\:lib_graph.h}
{\xe \v lib_graph.h\:min_path_conn_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Connection}* min_path_conn_vect}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file lib_graph.c.}\par
}
{\xe \v min_pth_conn_vect_size\:lib_graph.h}
{\xe \v lib_graph.h\:min_pth_conn_vect_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int min_pth_conn_vect_size}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file lib_graph.h.}\par
}
{\xe \v nds_collect_size\:lib_graph.h}
{\xe \v lib_graph.h\:nds_collect_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int nds_collect_size}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file lib_graph.h.}\par
}
{\xe \v node_pos_in_arch_str\:lib_graph.h}
{\xe \v lib_graph.h\:node_pos_in_arch_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b C_str} node_pos_in_arch_str[] = \{"ARCH NODE1 POSITION", "ARCH NODE2 POSITION"\}}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 69 of file lib_graph.h.}\par
}
{\xe \v nodes_collect_vect\:lib_graph.h}
{\xe \v lib_graph.h\:nodes_collect_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Node}* nodes_collect_vect}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file lib_graph.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/graph/lib_graph.so File Reference\par \pard\plain 
{\tc\tcl2 \v lib/graph/lib_graph.so}
{\xe \v lib/graph/lib_graph.so}
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/timer/lib_timer.c File Reference\par \pard\plain 
{\tc\tcl2 \v lib/timer/lib_timer.c}
{\xe \v lib/timer/lib_timer.c}
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "lib_timer.h"}\par
{\f2 #include "../ui/lib_ui.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b val_in_rage} ({\b C_int} val_min, {\b C_int} val, {\b C_int} val_max)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b delay} (const long time_ms)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Date_time} {\b get_date_time} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Date_time} {\b assign_date_time} ({\b C_int} yyyy, {\b C_int} mn, {\b C_int} dd, {\b C_int} hh, {\b C_int} mm, {\b C_int} ss)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Cmp_res} {\b cmp_date_time} ({\b Date_time} *const date1, const {\b Date_cmp} cmp_typ, {\b Date_time} *const date2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Cmp_res} {\b chk_date_in_range} (const {\b Date_time} date)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_date_time} (const char *const prfx_str_lbu, const {\b Date_time} *const date)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v assign_date_time\:lib_timer.c}
{\xe \v lib_timer.c\:assign_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Date_time} assign_date_time ({\b C_int}  {\i yyyy}, {\b C_int}  {\i mn}, {\b C_int}  {\i dd}, {\b C_int}  {\i hh}, {\b C_int}  {\i mm}, {\b C_int}  {\i ss})}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00052                                                                                         \{                   {\cf20 // Assign date/time function}\par
00053   {\cf20 /* Body */}\par
00054   Date_time tmp_date_time;                                                                                  {\cf20 // Temporary date/time var to return}\par
00055   tmp_date_time.yyyy = yyyy;                                                                                {\cf20 // Save years var}\par
00056   tmp_date_time.mn = mn;                                                                                    {\cf20 // Save months var}\par
00057   tmp_date_time.dd = dd;                                                                                    {\cf20 // Save days var}\par
00058   tmp_date_time.hh = hh+1;                                                                                  {\cf20 // Save hours var (+1)}\par
00059   tmp_date_time.mm = mm+1;                                                                                  {\cf20 // Save minutes var (+1)}\par
00060   tmp_date_time.ss = ss+1;                                                                                  {\cf20 // Save seconds var (+1)}\par
00061   {\cf19 if} (chk_date_in_range(tmp_date_time) == NOT_OK)\{                                                          {\cf20 // Check date/time consistency (case NOT-OK)}\par
00062     tmp_date_time.yyyy = 0;                                                                                 {\cf20 // Set years var to ZERO}\par
00063     tmp_date_time.mn = 0;                                                                                   {\cf20 // Set months var to ZERO}\par
00064     tmp_date_time.dd = 0;                                                                                   {\cf20 // Set days var to ZERO}\par
00065     tmp_date_time.hh = 0;                                                                                   {\cf20 // Set hours var to ZERO}\par
00066     tmp_date_time.mm = 0;                                                                                   {\cf20 // Set minutes var to ZERO}\par
00067     tmp_date_time.ss = 0;                                                                                   {\cf20 // Set seconds var to ZERO}\par
00068   \}\par
00069   {\cf19 return} tmp_date_time;                                                                                     {\cf20 // Return date/time var}\par
00070 \}\par
}
}
{\xe \v chk_date_in_range\:lib_timer.c}
{\xe \v lib_timer.c\:chk_date_in_range}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Cmp_res} chk_date_in_range (const {\b Date_time}  {\i date})}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 112 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00112                                                \{                                                            {\cf20 // Check date/time in range function}\par
00113   {\cf20 /* Body */}\par
00114   {\cf19 if} (val_in_rage(MIN_YY, date.yyyy, MAX_YY) && val_in_rage(MIN_MN, date.mn, MAX_MN) &&\par
00115       val_in_rage(MIN_DD, date.dd, MAX_DD) && val_in_rage(MIN_HH, date.hh, MAX_HH) &&\par
00116       val_in_rage(MIN_MM, date.mm, MAX_MM) && val_in_rage(MIN_SS, date.ss, MAX_SS))                         {\cf20 // If date/time is in range}\par
00117     {\cf19 return} OK;                                                                                              {\cf20 // Return OK}\par
00118   {\cf19 else}                                                                                                      {\cf20 // Else if date/time isn't in range}\par
00119     {\cf19 return} NOT_OK;                                                                                          {\cf20 // Return NOT-OK}\par
00120 \}\par
}
}
{\xe \v cmp_date_time\:lib_timer.c}
{\xe \v lib_timer.c\:cmp_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Cmp_res} cmp_date_time ({\b Date_time} *const  {\i date1}, const {\b Date_cmp}  {\i cmp_typ}, {\b Date_time} *const  {\i date2})}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00073                                                                                              \{              {\cf20 // Compare date/time function}\par
00074   {\cf20 /* Body */}\par
00075   {\cf18 int} *date1_val_ptr = &date1->yyyy, *date2_val_ptr = &date2->yyyy;                                         {\cf20 // Date/time ptrs vals}\par
00076   {\cf19 for} (Byte idx = 1; *date1_val_ptr == *date2_val_ptr && idx < 6; ++idx)\{                                   {\cf20 // Compare and redefine date1 and date2 ptr vals FOR cylce (cycle 'till years/months/days/hours/minutes/seconds are different)}\par
00077     {\cf19 switch} (idx)\{                                                                                           {\cf20 // Redefinition index switch-case}\par
00078       {\cf19 case} 1:                                                                                               {\cf20 // If years are equivalents, check months}\par
00079         date1_val_ptr = &date1->mn;                                                                         {\cf20 // Redefine date1 ptr val to date1 months}\par
00080         date2_val_ptr = &date2->mn;                                                                         {\cf20 // Redefine date2 ptr val to date2 months}\par
00081         {\cf19 break};\par
00083       {\cf19 case} 2:                                                                                               {\cf20 // If months are equivalents, check days}\par
00084         date1_val_ptr = &date1->dd;                                                                         {\cf20 // Redefine date1 ptr val to date1 days}\par
00085         date2_val_ptr = &date2->dd;                                                                         {\cf20 // Redefine date2 ptr val to date2 days}\par
00086         {\cf19 break};\par
00088       {\cf19 case} 3:                                                                                               {\cf20 // If days are equivalents, check hours}\par
00089         date1_val_ptr = &date1->hh;                                                                         {\cf20 // Redefine date1 ptr val to date1 hours}\par
00090         date2_val_ptr = &date2->hh;                                                                         {\cf20 // Redefine date2 ptr val to date2 hours}\par
00091         {\cf19 break};\par
00093       {\cf19 case} 4:                                                                                               {\cf20 // If hours are equivalents, check minutes}\par
00094         date1_val_ptr = &date1->mm;                                                                         {\cf20 // Redefine date1 ptr val to date1 minutes}\par
00095         date2_val_ptr = &date2->mm;                                                                         {\cf20 // Redefine date2 ptr val to date2 minutes}\par
00096         {\cf19 break};\par
00098       {\cf19 case} 5:                                                                                               {\cf20 // If minutes are equivalents, check seconds}\par
00099         date1_val_ptr = &date1->ss;                                                                         {\cf20 // Redefine date1 ptr val to date1 seconds}\par
00100         date2_val_ptr = &date2->ss;                                                                         {\cf20 // Redefine date2 ptr val to date2 seconds}\par
00101         {\cf19 break};        \par
00102     \}\par
00103   \}\par
00104   {\cf19 if} ((cmp_typ == OLDER && *date1_val_ptr < *date2_val_ptr) ||\par
00105       (cmp_typ == NEWER && *date1_val_ptr > *date2_val_ptr))                                                {\cf20 // Comparison conditions, if comparison is OK}\par
00106     {\cf19 return} OK;                                                                                              {\cf20 // Return compare OK}\par
00107   {\cf19 else}                                                                                                      {\cf20 // Else if comparison is NOT-OK}\par
00108     {\cf19 return} NOT_OK;                                                                                          {\cf20 // Return compare NOT-OK}\par
00109 \}\par
}
}
{\xe \v delay\:lib_timer.c}
{\xe \v lib_timer.c\:delay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void delay (const long  {\i time_ms})}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00026                               \{                                                                             {\cf20 // Delay [ms] function}\par
00027   {\cf20 /* Body */}\par
00028   {\cf19 if} (time_ms > 0)\{                                                                                         {\cf20 // Check ms-dly val}\par
00029     fflush(stdout);                                                                                         {\cf20 // Force pending terminal fbk prints}\par
00030     clock_t start_time = clock();                                                                           {\cf20 // Start time = software execution time}\par
00031     {\cf19 while} ((clock() - start_time) < (time_ms * (CLOCKS_PER_SEC / 1000)));                                   {\cf20 // Check if elapsed time [ms] (time - start_time) is greater or equal to pause time, pause time calculated considering the number of clocks per second}\par
00032   \} {\cf19 else}                                                                                                    {\cf20 // If ms-dly val ain't positive}\par
00033     perror({\cf22 "Error! Delay time must be greater than ZERO!"});                                                 {\cf20 // Print perror fbk}\par
00034 \}\par
}
}
{\xe \v fbk_gn_lbu_date_time\:lib_timer.c}
{\xe \v lib_timer.c\:fbk_gn_lbu_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_date_time (const char *const  {\i prfx_str_lbu}, const {\b Date_time} *const  {\i date})}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 123 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00123                                                                                       \{                     {\cf20 // Green-lightblue-yellow date/time val feedback function}\par
00124   {\cf20 /* Body */}\par
00125   printf({\cf22 "%s>>>%s %s: %s%d%c%d%c%d%c%d%c%d%c%d%s"},\par
00126           GN, LBU, prfx_str_lbu, YE, date->yyyy, DATE_DELIM_CHR, date->mn, DATE_DELIM_CHR, date->dd,\par
00127           DATE_TIME_DELIM_CHR, date->hh-1, TIME_DELIM_CHR, date->mm-1, TIME_DELIM_CHR, date->ss-1, ER);     {\cf20 // Print green-lightblue-yellow date/time val feedback}\par
00128 \}\par
}
}
{\xe \v get_date_time\:lib_timer.c}
{\xe \v lib_timer.c\:get_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Date_time} get_date_time ()}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00037                          \{                                                                                  {\cf20 // Get date/time function}\par
00038   {\cf20 /* Body */}\par
00039   Date_time tmp_date_time;                                                                                  {\cf20 // Temporary date/time var to return}\par
00040   time_t now = time(NULL);                                                                                  {\cf20 // Now timer}\par
00041   {\cf17 struct }tm tm = *localtime(&now);                                                                          {\cf20 // Get now date/time}\par
00042   tmp_date_time.yyyy = 1900+tm.tm_year;                                                                     {\cf20 // Save years var}\par
00043   tmp_date_time.mn = 1+tm.tm_mon;                                                                           {\cf20 // Save months var}\par
00044   tmp_date_time.dd = tm.tm_mday;                                                                            {\cf20 // Save days var}\par
00045   tmp_date_time.hh = tm.tm_hour+1;                                                                          {\cf20 // Save hours var (+1)}\par
00046   tmp_date_time.mm = tm.tm_min+1;                                                                           {\cf20 // Save minutes var (+1)}\par
00047   tmp_date_time.ss = tm.tm_sec+1;                                                                           {\cf20 // Save seconds var (+1)}\par
00048   {\cf19 return} tmp_date_time;                                                                                     {\cf20 // Return date/time}\par
00049 \}\par
}
}
{\xe \v val_in_rage\:lib_timer.c}
{\xe \v lib_timer.c\:val_in_rage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int val_in_rage ({\b C_int}  {\i val_min}, {\b C_int}  {\i val}, {\b C_int}  {\i val_max}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00016                                                                \{                                            {\cf20 // Function to check val in range}\par
00017   {\cf20 /* Body */}\par
00018   {\cf19 if} (val >= val_min && val <= val_max)                                                                     {\cf20 // If val is in range}\par
00019     {\cf19 return} 1;                                                                                               {\cf20 // Return 1}\par
00020   {\cf19 else}                                                                                                      {\cf20 // Else if val isn't in range}\par
00021     {\cf19 return} 0;                                                                                               {\cf20 // Return 0}\par
00022 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/timer/lib_timer.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/timer/lib_timer.h}
{\xe \v lib/timer/lib_timer.h}
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <time.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b date_time}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DATE_TIME_STR_LEN}\~ 20\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DATE_DELIM_CHR}\~ '/'\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DATE_TIME_DELIM_CHR}\~ ' '\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TIME_DELIM_CHR}\~ ':'\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_YY}\~ 2025\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MIN_YY}\~ 2015\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_MN}\~ 12\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MIN_MN}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_DD}\~ 31\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MIN_DD}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_HH}\~ 24\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MIN_HH}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_MM}\~ 60\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MIN_MM}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_SS}\~ 60\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MIN_SS}\~ 1\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b date_time} {\b Date_time}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b date_cmp} {\b Date_cmp}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b cmp_res} {\b Cmp_res}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b date_cmp} \{ {\b OLDER}, 
{\b NEWER}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b cmp_res} \{ {\b OK}, 
{\b NOT_OK}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b delay} (const long time_ms)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Date_time} {\b get_date_time} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Date_time} {\b assign_date_time} (const int yyyy, const int mn, const int dd, const int hh, const int mm, const int ss)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Cmp_res} {\b cmp_date_time} ({\b Date_time} *const date1, const {\b Date_cmp} cmp_typ, {\b Date_time} *const date2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Cmp_res} {\b chk_date_in_range} (const {\b Date_time} date)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_date_time} (const char *const prfx_str_lbu, const {\b Date_time} *const date)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DATE_DELIM_CHR\:lib_timer.h}
{\xe \v lib_timer.h\:DATE_DELIM_CHR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DATE_DELIM_CHR\~ '/'}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file lib_timer.h.}\par
}
{\xe \v DATE_TIME_DELIM_CHR\:lib_timer.h}
{\xe \v lib_timer.h\:DATE_TIME_DELIM_CHR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DATE_TIME_DELIM_CHR\~ ' '}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file lib_timer.h.}\par
}
{\xe \v DATE_TIME_STR_LEN\:lib_timer.h}
{\xe \v lib_timer.h\:DATE_TIME_STR_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DATE_TIME_STR_LEN\~ 20}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file lib_timer.h.}\par
}
{\xe \v MAX_DD\:lib_timer.h}
{\xe \v lib_timer.h\:MAX_DD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_DD\~ 31}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 23 of file lib_timer.h.}\par
}
{\xe \v MAX_HH\:lib_timer.h}
{\xe \v lib_timer.h\:MAX_HH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_HH\~ 24}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 25 of file lib_timer.h.}\par
}
{\xe \v MAX_MM\:lib_timer.h}
{\xe \v lib_timer.h\:MAX_MM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_MM\~ 60}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 27 of file lib_timer.h.}\par
}
{\xe \v MAX_MN\:lib_timer.h}
{\xe \v lib_timer.h\:MAX_MN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_MN\~ 12}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 21 of file lib_timer.h.}\par
}
{\xe \v MAX_SS\:lib_timer.h}
{\xe \v lib_timer.h\:MAX_SS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_SS\~ 60}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 29 of file lib_timer.h.}\par
}
{\xe \v MAX_YY\:lib_timer.h}
{\xe \v lib_timer.h\:MAX_YY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_YY\~ 2025}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file lib_timer.h.}\par
}
{\xe \v MIN_DD\:lib_timer.h}
{\xe \v lib_timer.h\:MIN_DD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MIN_DD\~ 1}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 24 of file lib_timer.h.}\par
}
{\xe \v MIN_HH\:lib_timer.h}
{\xe \v lib_timer.h\:MIN_HH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MIN_HH\~ 1}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file lib_timer.h.}\par
}
{\xe \v MIN_MM\:lib_timer.h}
{\xe \v lib_timer.h\:MIN_MM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MIN_MM\~ 1}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file lib_timer.h.}\par
}
{\xe \v MIN_MN\:lib_timer.h}
{\xe \v lib_timer.h\:MIN_MN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MIN_MN\~ 1}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 22 of file lib_timer.h.}\par
}
{\xe \v MIN_SS\:lib_timer.h}
{\xe \v lib_timer.h\:MIN_SS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MIN_SS\~ 1}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 30 of file lib_timer.h.}\par
}
{\xe \v MIN_YY\:lib_timer.h}
{\xe \v lib_timer.h\:MIN_YY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MIN_YY\~ 2015}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file lib_timer.h.}\par
}
{\xe \v TIME_DELIM_CHR\:lib_timer.h}
{\xe \v lib_timer.h\:TIME_DELIM_CHR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TIME_DELIM_CHR\~ ':'}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file lib_timer.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v Cmp_res\:lib_timer.h}
{\xe \v lib_timer.h\:Cmp_res}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b cmp_res} {\b Cmp_res}}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Date_cmp\:lib_timer.h}
{\xe \v lib_timer.h\:Date_cmp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b date_cmp} {\b Date_cmp}}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Date_time\:lib_timer.h}
{\xe \v lib_timer.h\:Date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b date_time} {\b Date_time}}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v cmp_res\:lib_timer.h}
{\xe \v lib_timer.h\:cmp_res}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b cmp_res}}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v OK\:lib_timer.h}
{\xe \v lib_timer.h\:OK}
{\qr OK{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
\cell }{\cell }{\row }
{\xe \v NOT_OK\:lib_timer.h}
{\xe \v lib_timer.h\:NOT_OK}
{\qr NOT_OK{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
\cell }{\cell }{\row }
}
\par
{
Definition at line 45 of file lib_timer.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00045 \{OK, NOT_OK\} Cmp_res;                                                                   {\cf20 // Date/time compare result enum}\par
}
}
{\xe \v date_cmp\:lib_timer.h}
{\xe \v lib_timer.h\:date_cmp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b date_cmp}}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v OLDER\:lib_timer.h}
{\xe \v lib_timer.h\:OLDER}
{\qr OLDER{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
\cell }{\cell }{\row }
{\xe \v NEWER\:lib_timer.h}
{\xe \v lib_timer.h\:NEWER}
{\qr NEWER{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
\cell }{\cell }{\row }
}
\par
{
Definition at line 43 of file lib_timer.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00043 \{OLDER, NEWER\} Date_cmp;                                                              {\cf20 // Date/time compare enum}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v assign_date_time\:lib_timer.h}
{\xe \v lib_timer.h\:assign_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Date_time} assign_date_time (const int  {\i yyyy}, const int  {\i mn}, const int  {\i dd}, const int  {\i hh}, const int  {\i mm}, const int  {\i ss})}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v chk_date_in_range\:lib_timer.h}
{\xe \v lib_timer.h\:chk_date_in_range}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Cmp_res} chk_date_in_range (const {\b Date_time}  {\i date})}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 112 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00112                                                \{                                                            {\cf20 // Check date/time in range function}\par
00113   {\cf20 /* Body */}\par
00114   {\cf19 if} (val_in_rage(MIN_YY, date.yyyy, MAX_YY) && val_in_rage(MIN_MN, date.mn, MAX_MN) &&\par
00115       val_in_rage(MIN_DD, date.dd, MAX_DD) && val_in_rage(MIN_HH, date.hh, MAX_HH) &&\par
00116       val_in_rage(MIN_MM, date.mm, MAX_MM) && val_in_rage(MIN_SS, date.ss, MAX_SS))                         {\cf20 // If date/time is in range}\par
00117     {\cf19 return} OK;                                                                                              {\cf20 // Return OK}\par
00118   {\cf19 else}                                                                                                      {\cf20 // Else if date/time isn't in range}\par
00119     {\cf19 return} NOT_OK;                                                                                          {\cf20 // Return NOT-OK}\par
00120 \}\par
}
}
{\xe \v cmp_date_time\:lib_timer.h}
{\xe \v lib_timer.h\:cmp_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Cmp_res} cmp_date_time ({\b Date_time} *const  {\i date1}, const {\b Date_cmp}  {\i cmp_typ}, {\b Date_time} *const  {\i date2})}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00073                                                                                              \{              {\cf20 // Compare date/time function}\par
00074   {\cf20 /* Body */}\par
00075   {\cf18 int} *date1_val_ptr = &date1->yyyy, *date2_val_ptr = &date2->yyyy;                                         {\cf20 // Date/time ptrs vals}\par
00076   {\cf19 for} (Byte idx = 1; *date1_val_ptr == *date2_val_ptr && idx < 6; ++idx)\{                                   {\cf20 // Compare and redefine date1 and date2 ptr vals FOR cylce (cycle 'till years/months/days/hours/minutes/seconds are different)}\par
00077     {\cf19 switch} (idx)\{                                                                                           {\cf20 // Redefinition index switch-case}\par
00078       {\cf19 case} 1:                                                                                               {\cf20 // If years are equivalents, check months}\par
00079         date1_val_ptr = &date1->mn;                                                                         {\cf20 // Redefine date1 ptr val to date1 months}\par
00080         date2_val_ptr = &date2->mn;                                                                         {\cf20 // Redefine date2 ptr val to date2 months}\par
00081         {\cf19 break};\par
00083       {\cf19 case} 2:                                                                                               {\cf20 // If months are equivalents, check days}\par
00084         date1_val_ptr = &date1->dd;                                                                         {\cf20 // Redefine date1 ptr val to date1 days}\par
00085         date2_val_ptr = &date2->dd;                                                                         {\cf20 // Redefine date2 ptr val to date2 days}\par
00086         {\cf19 break};\par
00088       {\cf19 case} 3:                                                                                               {\cf20 // If days are equivalents, check hours}\par
00089         date1_val_ptr = &date1->hh;                                                                         {\cf20 // Redefine date1 ptr val to date1 hours}\par
00090         date2_val_ptr = &date2->hh;                                                                         {\cf20 // Redefine date2 ptr val to date2 hours}\par
00091         {\cf19 break};\par
00093       {\cf19 case} 4:                                                                                               {\cf20 // If hours are equivalents, check minutes}\par
00094         date1_val_ptr = &date1->mm;                                                                         {\cf20 // Redefine date1 ptr val to date1 minutes}\par
00095         date2_val_ptr = &date2->mm;                                                                         {\cf20 // Redefine date2 ptr val to date2 minutes}\par
00096         {\cf19 break};\par
00098       {\cf19 case} 5:                                                                                               {\cf20 // If minutes are equivalents, check seconds}\par
00099         date1_val_ptr = &date1->ss;                                                                         {\cf20 // Redefine date1 ptr val to date1 seconds}\par
00100         date2_val_ptr = &date2->ss;                                                                         {\cf20 // Redefine date2 ptr val to date2 seconds}\par
00101         {\cf19 break};        \par
00102     \}\par
00103   \}\par
00104   {\cf19 if} ((cmp_typ == OLDER && *date1_val_ptr < *date2_val_ptr) ||\par
00105       (cmp_typ == NEWER && *date1_val_ptr > *date2_val_ptr))                                                {\cf20 // Comparison conditions, if comparison is OK}\par
00106     {\cf19 return} OK;                                                                                              {\cf20 // Return compare OK}\par
00107   {\cf19 else}                                                                                                      {\cf20 // Else if comparison is NOT-OK}\par
00108     {\cf19 return} NOT_OK;                                                                                          {\cf20 // Return compare NOT-OK}\par
00109 \}\par
}
}
{\xe \v delay\:lib_timer.h}
{\xe \v lib_timer.h\:delay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void delay (const long  {\i time_ms})}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00026                               \{                                                                             {\cf20 // Delay [ms] function}\par
00027   {\cf20 /* Body */}\par
00028   {\cf19 if} (time_ms > 0)\{                                                                                         {\cf20 // Check ms-dly val}\par
00029     fflush(stdout);                                                                                         {\cf20 // Force pending terminal fbk prints}\par
00030     clock_t start_time = clock();                                                                           {\cf20 // Start time = software execution time}\par
00031     {\cf19 while} ((clock() - start_time) < (time_ms * (CLOCKS_PER_SEC / 1000)));                                   {\cf20 // Check if elapsed time [ms] (time - start_time) is greater or equal to pause time, pause time calculated considering the number of clocks per second}\par
00032   \} {\cf19 else}                                                                                                    {\cf20 // If ms-dly val ain't positive}\par
00033     perror({\cf22 "Error! Delay time must be greater than ZERO!"});                                                 {\cf20 // Print perror fbk}\par
00034 \}\par
}
}
{\xe \v fbk_gn_lbu_date_time\:lib_timer.h}
{\xe \v lib_timer.h\:fbk_gn_lbu_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_date_time (const char *const  {\i prfx_str_lbu}, const {\b Date_time} *const  {\i date})}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 123 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00123                                                                                       \{                     {\cf20 // Green-lightblue-yellow date/time val feedback function}\par
00124   {\cf20 /* Body */}\par
00125   printf({\cf22 "%s>>>%s %s: %s%d%c%d%c%d%c%d%c%d%c%d%s"},\par
00126           GN, LBU, prfx_str_lbu, YE, date->yyyy, DATE_DELIM_CHR, date->mn, DATE_DELIM_CHR, date->dd,\par
00127           DATE_TIME_DELIM_CHR, date->hh-1, TIME_DELIM_CHR, date->mm-1, TIME_DELIM_CHR, date->ss-1, ER);     {\cf20 // Print green-lightblue-yellow date/time val feedback}\par
00128 \}\par
}
}
{\xe \v get_date_time\:lib_timer.h}
{\xe \v lib_timer.h\:get_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Date_time} get_date_time ()}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00037                          \{                                                                                  {\cf20 // Get date/time function}\par
00038   {\cf20 /* Body */}\par
00039   Date_time tmp_date_time;                                                                                  {\cf20 // Temporary date/time var to return}\par
00040   time_t now = time(NULL);                                                                                  {\cf20 // Now timer}\par
00041   {\cf17 struct }tm tm = *localtime(&now);                                                                          {\cf20 // Get now date/time}\par
00042   tmp_date_time.yyyy = 1900+tm.tm_year;                                                                     {\cf20 // Save years var}\par
00043   tmp_date_time.mn = 1+tm.tm_mon;                                                                           {\cf20 // Save months var}\par
00044   tmp_date_time.dd = tm.tm_mday;                                                                            {\cf20 // Save days var}\par
00045   tmp_date_time.hh = tm.tm_hour+1;                                                                          {\cf20 // Save hours var (+1)}\par
00046   tmp_date_time.mm = tm.tm_min+1;                                                                           {\cf20 // Save minutes var (+1)}\par
00047   tmp_date_time.ss = tm.tm_sec+1;                                                                           {\cf20 // Save seconds var (+1)}\par
00048   {\cf19 return} tmp_date_time;                                                                                     {\cf20 // Return date/time}\par
00049 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/timer/lib_timer.so File Reference\par \pard\plain 
{\tc\tcl2 \v lib/timer/lib_timer.so}
{\xe \v lib/timer/lib_timer.so}
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/ui/lib_ui.c File Reference\par \pard\plain 
{\tc\tcl2 \v lib/ui/lib_ui.c}
{\xe \v lib/ui/lib_ui.c}
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "lib_ui.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b unused} {\b __attribute__} (({\b unused}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logo} ({\b Cu_shrt} start_sp, {\b C_str} txt, {\b C_str} txt_col, {\b C_char} bkg_chr, {\b C_str} bkg_col)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b press_enter} ({\b C_str} req_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_nl} ({\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_spaces} ({\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_tabs} ({\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_separator} ({\b C_char} chr, {\b C_str} col)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_cy} ({\b C_str} fbk_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_pu} ({\b C_str} fbk_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_int} ({\b C_str} prfx_str_lbu, {\b C_int} val_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_str} ({\b C_str} prfx_str_lbu, {\b C_str} str_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_real} ({\b C_str} prfx_str_lbu, {\b C_real} val_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_lreal} ({\b C_str} prfx_str_lbu, {\b Cl_real} val_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_ptr} ({\b C_str} prfx_str_lbu, {\b C_ptr} val_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_err} ({\b C_str} fbk_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Str} {\b read_term_in} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Str} {\b read_term_in_min_chrs} ({\b C_byte} min_chrs, {\b C_str} req_str, {\b C_str} err_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Confirm} {\b read_term_in_confirm} ({\b C_str} req_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Str} {\b read_term_in_min_chrs_exit_chr} ({\b C_byte} min_chrs, {\b C_str} req_str, {\b C_str} err_str, {\b C_char} exit_chr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b read_term_in_int} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b read_term_in_int_inrange} ({\b C_int} min_val, {\b C_int} max_val, {\b C_str} req_str, {\b C_str} err_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clr_term_in} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_print} ({\b C_str} str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_str} ({\b C_str} str, {\b C_str} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_int} ({\b C_str} str, {\b C_int} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_real} ({\b C_str} str, {\b C_real} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_lreal} ({\b C_str} str, {\b Cl_real} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_ptr} ({\b C_str} str, {\b C_ptr} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_err} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_fbk} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_keyboard_interrupt} ({\b C_int} signal)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b term_in_buff} [{\b IN_BUFF_SIZE}] = ""\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:lib_ui.c}
{\xe \v lib_ui.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b unused} __attribute__ (({\b unused}) )}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v close_err\:lib_ui.c}
{\xe \v lib_ui.c\:close_err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_err ()}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 313 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00313                 \{                                                                                           {\cf20 // Close software with error function}\par
00314   {\cf20 /* Body */}\par
00315   printf({\cf22 "\\n%s>>>%s Closin' due to error... %sSorry! %s:(%s\\n"}, OG, RD, CY, OG, ER);                        {\cf20 // Closin' due to error fbk}\par
00316   exit(EXIT_FAILURE);                                                                                       {\cf20 // Close software}\par
00317 \}\par
}
}
{\xe \v close_fbk\:lib_ui.c}
{\xe \v lib_ui.c\:close_fbk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_fbk ()}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 320 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00320                 \{                                                                                           {\cf20 // Function to close software with feedback}\par
00321   {\cf20 /* Body */}\par
00322   printf({\cf22 "\\n\\n%s>>>%s Closin'... %sBye! %s;)%s\\n"}, GN, PU, CY, RD, ER);                                     {\cf20 // Closin' fbk}\par
00323   exit(EXIT_SUCCESS);                                                                                       {\cf20 // Close software}\par
00324 \}\par
}
}
{\xe \v close_keyboard_interrupt\:lib_ui.c}
{\xe \v lib_ui.c\:close_keyboard_interrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_keyboard_interrupt ({\b C_int}  {\i signal})}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 327 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00327                                            \{                                                                {\cf20 // Function to close SW with fbk due to keyboard interrupt detected (ctrl+c)}\par
00328   {\cf20 /* Body */}\par
00329   printf({\cf22 "\\n\\n%s>>>%s Keyboard interrupt detected, closin'... %sBye! %s;)%s\\n"}, GN, PU, CY, RD, ER);        {\cf20 // Closin' fbk}\par
00330   exit(signal);                                                                                             {\cf20 // Exit SW with signal}\par
00331 \}\par
}
}
{\xe \v clr_term_in\:lib_ui.c}
{\xe \v lib_ui.c\:clr_term_in}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void clr_term_in ()}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 265 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00265                   \{                                                                                         {\cf20 // Clear terminal input buffer function}\par
00266   {\cf20 /* Body */}\par
00267   strcpy(term_in_buff, {\cf22 "\\0"});                                                                               {\cf20 // Clear input buffer char array}\par
00268 \}\par
}
}
{\xe \v dbg\:lib_ui.c}
{\xe \v lib_ui.c\:dbg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg ()}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 271 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00271           \{                                                                                                 {\cf20 // Fast debug function}\par
00272   {\cf20 /* Body */}\par
00273   printf({\cf22 "\\n\\n%s    >>>>>> %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, LGN, ER);                                   {\cf20 // Print debug line}\par
00274 \}\par
}
}
{\xe \v dbg_int\:lib_ui.c}
{\xe \v lib_ui.c\:dbg_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_int ({\b C_str}  {\i str}, {\b C_int}  {\i val})}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 289 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00289                                   \{                                                                         {\cf20 // Debug int val print function}\par
00290   {\cf20 /* Body */}\par
00291   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%d %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);      {\cf20 // Print debug line}\par
00292 \}\par
}
}
{\xe \v dbg_lreal\:lib_ui.c}
{\xe \v lib_ui.c\:dbg_lreal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_lreal ({\b C_str}  {\i str}, {\b Cl_real}  {\i val})}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 301 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00301                                       \{                                                                     {\cf20 // Debug long real val print function}\par
00302   {\cf20 /* Body */}\par
00303   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%Lg %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);     {\cf20 // Print debug line}\par
00304 \}\par
}
}
{\xe \v dbg_print\:lib_ui.c}
{\xe \v lib_ui.c\:dbg_print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_print ({\b C_str}  {\i str})}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 277 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00277                          \{                                                                                  {\cf20 // Debug print function}\par
00278   {\cf20 /* Body */}\par
00279   printf({\cf22 "\\n\\n%s    >>>>>>%s %s %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, LGN, ER);                     {\cf20 // Print debug line}\par
00280 \}\par
}
}
{\xe \v dbg_ptr\:lib_ui.c}
{\xe \v lib_ui.c\:dbg_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_ptr ({\b C_str}  {\i str}, {\b C_ptr}  {\i val})}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 307 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00307                                   \{                                                                         {\cf20 // Debug ptr val print function}\par
00308   {\cf20 /* Body */}\par
00309   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%p %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);      {\cf20 // Print debug line}\par
00310 \}\par
}
}
{\xe \v dbg_real\:lib_ui.c}
{\xe \v lib_ui.c\:dbg_real}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_real ({\b C_str}  {\i str}, {\b C_real}  {\i val})}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 295 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00295                                     \{                                                                       {\cf20 // Debug real val print function}\par
00296   {\cf20 /* Body */}\par
00297   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%g %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);      {\cf20 // Print debug line}\par
00298 \}\par
}
}
{\xe \v dbg_str\:lib_ui.c}
{\xe \v lib_ui.c\:dbg_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_str ({\b C_str}  {\i str}, {\b C_str}  {\i val})}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 283 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00283                                   \{                                                                         {\cf20 // Debug string val print function}\par
00284   {\cf20 /* Body */}\par
00285   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%s %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);      {\cf20 // Print debug line}\par
00286 \}\par
}
}
{\xe \v fbk_err\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_err ({\b C_str}  {\i fbk_str})}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 151 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00151                            \{                                                                                {\cf20 // Error feedback function}\par
00152   {\cf20 /* Body */}\par
00153   printf({\cf22 "\\n%s>>>%s %s!%s\\n"}, OG, RD, fbk_str, ER);                                                         {\cf20 // Print error fbk}\par
00154 \}\par
}
}
{\xe \v fbk_gn_cy\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_gn_cy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_cy ({\b C_str}  {\i fbk_str})}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 109 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00109                              \{                                                                              {\cf20 // Green-cyan feedback function}\par
00110   {\cf20 /* Body */}\par
00111   printf({\cf22 "%s>>>%s %s%s"}, GN, CY, fbk_str, ER);                                                              {\cf20 // Print green-cyan string fbk}\par
00112 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_int\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_gn_lbu_ye_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_int ({\b C_str}  {\i prfx_str_lbu}, {\b C_int}  {\i val_ye})}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 121 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00121                                                         \{                                                   {\cf20 // Green-lightblue-yellow int val feedback function}\par
00122   {\cf20 /* Body */}\par
00123   printf({\cf22 "%s>>>%s %s: %s%d%s"}, GN, LBU, prfx_str_lbu, YE, val_ye, ER);                                      {\cf20 // Print green-lightblue-yellow int val feedback}\par
00124 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_lreal\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_gn_lbu_ye_lreal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_lreal ({\b C_str}  {\i prfx_str_lbu}, {\b Cl_real}  {\i val_ye})}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00139                                                             \{                                               {\cf20 // Green-lightblue-yellow long real val feedback function}\par
00140   {\cf20 /* Body */}\par
00141   printf({\cf22 "%s>>>%s %s: %s%Lg%s"}, GN, LBU, prfx_str_lbu, YE, val_ye, ER);                                     {\cf20 // Print green-lightblue-yellow long real val feedback}\par
00142 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_ptr\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_gn_lbu_ye_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_ptr ({\b C_str}  {\i prfx_str_lbu}, {\b C_ptr}  {\i val_ye})}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 145 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00145                                                         \{                                                   {\cf20 // Green-lightblue-yellow ptr val feedback function}\par
00146   {\cf20 /* Body */}\par
00147   printf({\cf22 "%s>>>%s %s: %s%p%s"}, GN, LBU, prfx_str_lbu, YE, val_ye, ER);                                      {\cf20 // Print green-lightblue-yellow ptr val feedback}\par
00148 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_real\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_gn_lbu_ye_real}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_real ({\b C_str}  {\i prfx_str_lbu}, {\b C_real}  {\i val_ye})}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 133 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00133                                                           \{                                                 {\cf20 // Green-lightblue-yellow real val feedback function}\par
00134   {\cf20 /* Body */}\par
00135   printf({\cf22 "%s>>>%s %s: %s%g%s"}, GN, LBU, prfx_str_lbu, YE, val_ye, ER);                                      {\cf20 // Print green-lightblue-yellow real val feedback}\par
00136 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_str\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_gn_lbu_ye_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_str ({\b C_str}  {\i prfx_str_lbu}, {\b C_str}  {\i str_ye})}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 127 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00127                                                         \{                                                   {\cf20 // Green-lightblue-yellow str val feedback function}\par
00128   {\cf20 /* Body */}\par
00129   printf({\cf22 "%s>>>%s %s: %s%s%s"}, GN, LBU, prfx_str_lbu, YE, str_ye, ER);                                      {\cf20 // Print green-lightblue-yellow str val feedback}\par
00130 \}\par
}
}
{\xe \v fbk_gn_pu\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_gn_pu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_pu ({\b C_str}  {\i fbk_str})}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 115 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00115                              \{                                                                              {\cf20 // Green-purple feedback function}\par
00116   {\cf20 /* Body */}\par
00117   printf({\cf22 "%s>>>%s %s%s"}, GN, PU, fbk_str, ER);                                                              {\cf20 // Print green-purple string fbk}\par
00118 \}\par
}
}
{\xe \v fbk_nl\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_nl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_nl ({\b C_int}  {\i num})}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00079                       \{                                                                                     {\cf20 // New lines feedback function}\par
00080   {\cf20 /* Body */}\par
00081   {\cf19 for} ({\cf18 int} i = 0; i < num; ++i)                                                                             {\cf20 // Chars printin' FOR cycle}\par
00082     printf({\cf22 "\\n"});                                                                                           {\cf20 // Print new line fbk}\par
00083 \}\par
}
}
{\xe \v fbk_separator\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_separator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_separator ({\b C_char}  {\i chr}, {\b C_str}  {\i col})}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 100 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00100                                          \{                                                                  {\cf20 // Separator feedback function}\par
00101   {\cf20 /* Body */}\par
00102   {\cf17 struct }winsize w;                                                                                         {\cf20 // Window-size struct declaration}\par
00103   ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);                                                                     {\cf20 // Save the number of terminal's rows/cloumns in window-size struct}\par
00104   {\cf19 for} ({\cf18 int} i = 0; i < w.ws_col; ++i)                                                                        {\cf20 // Chars printin' FOR cycle}\par
00105     printf({\cf22 "%s%c%s"}, col, chr, ER);                                                                         {\cf20 // Print space fbk}\par
00106 \}\par
}
}
{\xe \v fbk_spaces\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_spaces}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_spaces ({\b C_int}  {\i num})}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 86 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00086                           \{                                                                                 {\cf20 // Spces feedback function}\par
00087   {\cf20 /* Body */}\par
00088   {\cf19 for} ({\cf18 int} i = 0; i < num; ++i)                                                                             {\cf20 // Chars printin' FOR cycle}\par
00089     printf({\cf22 " "});                                                                                            {\cf20 // Print space fbk}\par
00090 \}\par
}
}
{\xe \v fbk_tabs\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_tabs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_tabs ({\b C_int}  {\i num})}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 93 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00093                         \{                                                                                   {\cf20 // Tabs feedback function}\par
00094   {\cf20 /* Body */}\par
00095   {\cf19 for} ({\cf18 int} i = 0; i < num; ++i)                                                                             {\cf20 // Chars printin' FOR cycle}\par
00096     printf({\cf22 "\\t"});                                                                                           {\cf20 // Print tab fbk}\par
00097 \}\par
}
}
{\xe \v logo\:lib_ui.c}
{\xe \v lib_ui.c\:logo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void logo ({\b Cu_shrt}  {\i start_sp}, {\b C_str}  {\i txt}, {\b C_str}  {\i txt_col}, {\b C_char}  {\i bkg_chr}, {\b C_str}  {\i bkg_col})}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00020                                                                                     \{                       {\cf20 // Print responsive-logo function}\par
00021   {\cf20 /* Body */}\par
00022   {\cf17 struct }winsize w;                                                                                         {\cf20 // Window-size struct declaration}\par
00023   ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);                                                                     {\cf20 // Save the number of terminal's rows/cloumns in window-size struct}\par
00024   Cu_shrt vthck = (w.ws_row / 5);                                                                           {\cf20 // Logo bkg vertical thickness calc}\par
00025   Cu_shrt lthck = (w.ws_col / 6);                                                                           {\cf20 // Logo bkg lateral thickness calc}\par
00026   Cu_shrt lsp = (Cu_shrt)(w.ws_col - 2*lthck - 2*start_sp - (Cu_shrt)strlen(txt)) / 2;                      {\cf20 // Logo internal lateral spaces calc}\par
00027   Cu_shrt len = (Cu_shrt)(2*lthck+2*lsp+(Cu_shrt)strlen(txt));                                              {\cf20 // Logo length calc}\par
00028   {\cf20 // Print logo}\par
00029   printf({\cf22 "\\n%s"}, bkg_col);                                                                                  {\cf20 // New line fbk}\par
00030   {\cf19 for} (U_shrt i = 0; i < (4*vthck+1); ++i)\{                                                                 {\cf20 // Logo lines print FOR cycle}\par
00031     {\cf19 for} (U_shrt j = 0; j < start_sp; ++j)\{                                                                  {\cf20 // Initial spaces print FOR cycle}\par
00032       printf({\cf22 " "});                                                                                          {\cf20 // Print initial spaces}\par
00033     \}\par
00034     {\cf19 if} ((i < vthck || i > (3*vthck)) && (i != (4*vthck)/2))\{                                                {\cf20 // Full bkg logo lines print cond}\par
00035       {\cf19 for} (U_shrt h = 0; h < len; ++h)\{                                                                     {\cf20 // Full bkg logo lines print FOR cycle}\par
00036         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Bkg logo char print}\par
00037       \}\par
00038       fbk_nl(1);                                                                                            {\cf20 // New line feedback function call}\par
00039     \} {\cf19 else} {\cf19 if} ((i >= vthck && i <= (3*vthck)) && (i != (4*vthck)/2)) \{                                      {\cf20 // Partial-empty bkg logo lines print cond}\par
00040       {\cf19 for} (U_shrt l = 0; l < lthck; ++l)\{                                                                   {\cf20 // Partial-empty bkg logo lines, initial full part print FOR cycle}\par
00041         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Partial-empty bkg logo lines, initial full part print}\par
00042       \}\par
00043       {\cf19 for} (U_shrt m = 0; m < (len - 2*lthck); ++m)\{                                                         {\cf20 // Partial-empty bkg logo lines, central empty part print FOR cycle}\par
00044         printf({\cf22 " "});                                                                                        {\cf20 // Partial-empty bkg logo lines, central empty part print}\par
00045       \}\par
00046       {\cf19 for} (U_shrt n = 0; n < lthck; ++n)\{                                                                   {\cf20 // Partial-empty bkg logo lines, final full part print FOR cycle}\par
00047         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Partial-empty bkg logo lines, final full part print}\par
00048       \}\par
00049       fbk_nl(1);                                                                                            {\cf20 // New line feedback function call}\par
00050     \} {\cf19 else} {\cf19 if} (i == ((4*vthck)/2)) \{                                                                        {\cf20 // Text logo line initial full part print cond}\par
00051       {\cf19 for} (U_shrt o = 0; o < lthck; ++o)\{                                                                   {\cf20 // Text logo line initial full part print FOR cycle}\par
00052         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Text logo line initial full part print}\par
00053       \}\par
00054       {\cf19 for} (U_shrt p = 0; p < lsp; ++p)\{                                                                     {\cf20 // Text logo line central empty part print FOR cycle}\par
00055         printf({\cf22 " "});                                                                                        {\cf20 // Text logo line central empty part print}\par
00056       \}\par
00057       printf({\cf22 "%s%s%s"}, txt_col, txt, bkg_col);                                                              {\cf20 // Text logo line central text part print}\par
00058       {\cf19 for} (U_shrt q = 0; q < lsp; ++q)\{                                                                     {\cf20 // Text logo line central empty part print FOR cycle}\par
00059         printf({\cf22 " "});                                                                                        {\cf20 // Text logo line central empty part print}\par
00060       \}\par
00061       {\cf19 for} (U_shrt r = 0; r < lthck; ++r)\{                                                                   {\cf20 // Text logo line final full part print FOR cycle}\par
00062         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Text logo line final full part print}\par
00063       \}\par
00064       fbk_nl(1);                                                                                            {\cf20 // New line feedback function call}\par
00065     \}\par
00066   \}\par
00067   printf(ER);                                                                                               {\cf20 // New line fbk and erase logo bkg color}\par
00068 \}\par
}
}
{\xe \v press_enter\:lib_ui.c}
{\xe \v lib_ui.c\:press_enter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void press_enter ({\b C_str}  {\i req_str})}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00071                                \{                                                                            {\cf20 // Press enter function}\par
00072   {\cf20 /* Body */}\par
00073   printf({\cf22 "\\n\\n%s>>>%s %s! %sPress %sENTER%s to contine... %s;)%s"},\par
00074           GN, PU, req_str, CY, YE, CY, RD, ER);                                                             {\cf20 // Build map, press enter key to start fbk}\par
00075   read_term_in();                                                                                           {\cf20 // Wait enter key to start (read terminal input function call)}\par
00076 \}\par
}
}
{\xe \v read_term_in\:lib_ui.c}
{\xe \v lib_ui.c\:read_term_in}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Str} read_term_in ()}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 157 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00157                   \{                                                                                         {\cf20 // Read terminal input function}\par
00158   {\cf20 /* Body */}\par
00159   unused = scanf({\cf22 "%30[^\\n]"}, term_in_buff);                                                                 {\cf20 // Reads the string 'till '\\n' char, avoidin' scanf stop at space char and saving '\\n' chr (str var definition) --> avoid buffer overflow assigning max input str size to (31-1)=30 for '\\0' char}\par
00160   {\cf19 while} ((getchar()) != {\cf23 '\\n'});                                                                              {\cf20 // Instruction to clear input buffer when buffer overflow occurs, avoiding to save next char as new input}\par
00161   {\cf19 return} term_in_buff;                                                                                      {\cf20 // Return terminal input string}\par
00162 \}\par
}
}
{\xe \v read_term_in_confirm\:lib_ui.c}
{\xe \v lib_ui.c\:read_term_in_confirm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Confirm} read_term_in_confirm ({\b C_str}  {\i req_str})}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 186 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00186                                            \{                                                                {\cf20 // Read terminal input confirmation function}\par
00187   {\cf20 /* Body */}\par
00188   Str in_str;                                                                                               {\cf20 // Terminal input string tmp var}\par
00189   Confirm answ;                                                                                             {\cf20 // Confirmation answer}\par
00190   Byte exit_flg = 0;                                                                                        {\cf20 // Terminal input while-loop exit flag}\par
00191   {\cf20 // Read input from terminal}\par
00192   {\cf19 do}\{\par
00193     clr_term_in();                                                                                          {\cf20 // Clear terminal input buffer function call}\par
00194     printf({\cf22 "%s>>>%s %s?%s Options %s(yes/no/cancel)%s%s: %s"}, GN, PU, req_str, BU, OG, BU, PU, ER);         {\cf20 // Print request fbk}\par
00195     in_str = read_term_in();                                                                                {\cf20 // Read terminal input function call}\par
00196     {\cf19 if} (0 == strcmp(in_str, {\cf22 "yes"}) || 0 == strcmp(in_str, {\cf22 "YES"}) || 0 == strcmp(in_str, {\cf22 "Yes"}))\{            {\cf20 // YES answer}\par
00197       answ = YES;                                                                                           {\cf20 // Set answer = YES}\par
00198       ++exit_flg;                                                                                           {\cf20 // Set exit flag}\par
00199     \} {\cf19 else} {\cf19 if} (0 == strcmp(in_str, {\cf22 "no"}) || 0 == strcmp(in_str, {\cf22 "NO"}) ||\par
00200                0 == strcmp(in_str, {\cf22 "No"}) || 0 == strcmp(in_str, {\cf22 "nO"}))\{                                     {\cf20 // NO answer}\par
00201       answ = NO;                                                                                            {\cf20 // Set answer = NO}\par
00202       ++exit_flg;                                                                                           {\cf20 // Set exit flag}\par
00203     \} {\cf19 else} {\cf19 if}(0 == strcmp(in_str, {\cf22 "cancel"}) || 0 == strcmp(in_str, {\cf22 "CANCEL"}) ||\par
00204               0 == strcmp(in_str, {\cf22 "Cancel"}))\{                                                               {\cf20 // CANCEL answer}\par
00205       answ = CANCEL;                                                                                        {\cf20 // Set answer = CANCEL}\par
00206       ++exit_flg;                                                                                           {\cf20 // Set exit flag}\par
00207     \}\par
00208     {\cf20 // Chk xit flg}\par
00209     {\cf19 if} (!exit_flg)                                                                                          {\cf20 // Exit flag val chack}\par
00210       printf({\cf22 "%s>>>%s The answer must be %s(yes/no/cancel)%s!%s\\n"}, OG, RD, YE, RD, ER);                    {\cf20 // Print terminal input error fbk}\par
00211   \} {\cf19 while}(!exit_flg);                                                                                       {\cf20 // Check while-loop exit flag val}\par
00212   \par
00213   {\cf19 return} answ;                                                                                              {\cf20 // Return confirmation answer}\par
00214 \}\par
}
}
{\xe \v read_term_in_int\:lib_ui.c}
{\xe \v lib_ui.c\:read_term_in_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int read_term_in_int ()}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 238 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00238                       \{                                                                                     {\cf20 // Read terminal input INT function}\par
00239   {\cf20 /* Body */}\par
00240   {\cf19 return} atoi(read_term_in());                                                                              {\cf20 // Return integer conversion of input string}\par
00241 \}\par
}
}
{\xe \v read_term_in_int_inrange\:lib_ui.c}
{\xe \v lib_ui.c\:read_term_in_int_inrange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int read_term_in_int_inrange ({\b C_int}  {\i min_val}, {\b C_int}  {\i max_val}, {\b C_str}  {\i req_str}, {\b C_str}  {\i err_str})}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 244 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00244                                                                                         \{                   {\cf20 // Read terminal input INT (in-range) function}\par
00245   {\cf20 /* Body */}\par
00246   {\cf18 int} val = 0;                                                                                              {\cf20 // Terminal input value}\par
00247   Byte exit_flg = 0;                                                                                        {\cf20 // Terminal input while-loop exit flag}\par
00248   {\cf20 // Read terminal input}\par
00249   {\cf19 do}\{\par
00250     clr_term_in();                                                                                          {\cf20 // Clear terminal input buffer function call}\par
00251     printf({\cf22 "%s>>>%s %s %s(min %s%d%s, max %s%d%s and NOT %s0%s)%s: %s"},\par
00252             GN, PU, req_str, BU, OG, min_val, BU, OG, max_val, BU, OG, BU, PU, ER);                         {\cf20 // Enter the number of crosses to allocate fbk}\par
00253     val = read_term_in_int();                                                                               {\cf20 // Read terminal input INT function call}\par
00254     exit_flg = (val >= min_val && val <= max_val && val != 0);                                              {\cf20 // Terminal input while-loop exit flag val upd}\par
00255     {\cf20 // Chk xit flg}\par
00256     {\cf19 if} (!exit_flg)                                                                                          {\cf20 // Exit flag val chack}\par
00257       printf({\cf22 "%s>>>%s %s must be in %s[%d, %d]%s range!%s\\n"},\par
00258               OG, RD, err_str, YE, min_val, max_val, RD, ER);                                               {\cf20 // Print terminal input error fbk}\par
00259   \} {\cf19 while}(!exit_flg);                                                                                       {\cf20 // Check while-loop exit flag val}\par
00260     \par
00261   {\cf19 return} val;                                                                                               {\cf20 // Return terminal input val}\par
00262 \}\par
}
}
{\xe \v read_term_in_min_chrs\:lib_ui.c}
{\xe \v lib_ui.c\:read_term_in_min_chrs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Str} read_term_in_min_chrs ({\b C_byte}  {\i min_chrs}, {\b C_str}  {\i req_str}, {\b C_str}  {\i err_str})}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 165 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00165                                                                         \{                                   {\cf20 // Read terminal input (min chars) function}\par
00166   {\cf20 /* Body */}\par
00167   Str in_str;                                                                                               {\cf20 // Terminal input string tmp var}\par
00168   Byte exit_flg = 0;                                                                                        {\cf20 // Terminal input while-loop exit flag}\par
00169   {\cf20 // Read input from terminal}\par
00170   {\cf19 do}\{\par
00171     clr_term_in();                                                                                          {\cf20 // Clear terminal input buffer function call}\par
00172     printf({\cf22 "\\n%s>>>%s %s,%s at least %s%d%s char(s), max %s%d%s chars%s: %s"},\par
00173             GN, PU, req_str, BU, OG, min_chrs, BU, OG, IN_BUFF_SIZE-1, BU, PU, ER);                         {\cf20 // Print request fbk}\par
00174     in_str = read_term_in();                                                                                {\cf20 // Read terminal input function call}\par
00175     exit_flg = (strlen(in_str) >= min_chrs);                                                                {\cf20 // Terminal input while-loop exit flag val upd}\par
00176     {\cf20 // Chk xit flg}\par
00177     {\cf19 if} (!exit_flg)                                                                                          {\cf20 // Exit flag val chack}\par
00178       printf({\cf22 "%s>>>%s %s must be at least %s%d%s char(s) long!%s\\n"},\par
00179               OG, RD, err_str, YE, min_chrs, RD, ER);                                                       {\cf20 // Print terminal input error fbk}\par
00180   \} {\cf19 while}(!exit_flg);                                                                                       {\cf20 // Check while-loop exit flag val}\par
00181   \par
00182   {\cf19 return} in_str;                                                                                            {\cf20 // Return terminal input string}\par
00183 \}\par
}
}
{\xe \v read_term_in_min_chrs_exit_chr\:lib_ui.c}
{\xe \v lib_ui.c\:read_term_in_min_chrs_exit_chr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Str} read_term_in_min_chrs_exit_chr ({\b C_byte}  {\i min_chrs}, {\b C_str}  {\i req_str}, {\b C_str}  {\i err_str}, {\b C_char}  {\i exit_chr})}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 217 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00217                                                                                                   \{         {\cf20 // Read terminal input (min chars and exit char) function}\par
00218   {\cf20 /* Body */}\par
00219   Str in_str;                                                                                               {\cf20 // Terminal input string tmp var}\par
00220   Byte exit_flg = 0;                                                                                        {\cf20 // Terminal input while-loop exit flag}\par
00221   {\cf20 // Read terminal input}\par
00222   {\cf19 do}\{\par
00223     clr_term_in();                                                                                          {\cf20 // Clear terminal input buffer function call}\par
00224     printf({\cf22 "%s>>>%s %s %s(at least %s%d%s char(s) and max %s%d%s, type %s'%c'%s char to continue)%s: %s"},\par
00225             GN, PU, req_str, BU, OG, min_chrs, BU, OG, IN_BUFF_SIZE-1, BU, OG, exit_chr, BU, PU, ER);       {\cf20 // Print request fbk}\par
00226     in_str = read_term_in();                                                                                {\cf20 // Read terminal input function call}\par
00227     exit_flg = (strlen(in_str) >= min_chrs) || (*in_str == exit_chr);                                       {\cf20 // Terminal input while-loop exit flag val upd}\par
00228     {\cf20 // Chk xit flg}\par
00229     {\cf19 if} (!exit_flg)                                                                                          {\cf20 // Exit flag val chack}\par
00230       printf({\cf22 "%s>>>%s %s must be at least %s%d%s char(s) long!%s\\n"},\par
00231               OG, RD, err_str, YE, min_chrs, RD, ER);                                                       {\cf20 // Print terminal input error fbk}\par
00232   \} {\cf19 while}(!exit_flg);                                                                                       {\cf20 // Check while-loop exit flag val}\par
00233   \par
00234   {\cf19 return} in_str;                                                                                            {\cf20 // Return terminal input string}\par
00235 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v term_in_buff\:lib_ui.c}
{\xe \v lib_ui.c\:term_in_buff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char term_in_buff[{\b IN_BUFF_SIZE}] = ""}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file lib_ui.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/ui/lib_ui.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/ui/lib_ui.h}
{\xe \v lib/ui/lib_ui.h}
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <sys/ioctl.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <stdarg.h>}\par
{\f2 #include <signal.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IN_BUFF_SIZE}\~ 31\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RD}\~ "\\033[0;31m"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BU}\~ "\\033[0;34m"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LBU}\~ "\\033[1;34m"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PU}\~ "\\033[0;35m"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CY}\~ "\\033[0;36m"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b YE}\~ "\\033[1;33m"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OG}\~ "\\033[0;33m"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GN}\~ "\\033[0;32m"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LGN}\~ "\\033[1;32m"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LGY}\~ "\\033[0;37m"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ER}\~ "\\033[0m"\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b confirm} {\b Confirm}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned char {\b Byte}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned short {\b U_shrt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned int {\b U_int}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned long {\b U_long}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef double {\b Real}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef long double {\b L_real}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef char * {\b Str}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void * {\b Ptr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef const {\b Cstr} {\b C_str}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b confirm} \{ {\b YES}, 
{\b NO}, 
{\b CANCEL}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logo} ({\b Cu_shrt} start_sp, {\b C_str} txt, {\b C_str} txt_col, {\b C_char} bkg_chr, {\b C_str} bkg_col)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b press_enter} ({\b C_str} req_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_nl} ({\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_spaces} ({\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_tabs} ({\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_separator} ({\b C_char} chr, {\b C_str} col)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_cy} ({\b C_str} fbk_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_pu} ({\b C_str} fbk_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_int} ({\b C_str} prfx_str_lbu, {\b C_int} val_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_str} ({\b C_str} prfx_str_lbu, {\b C_str} str_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_real} ({\b C_str} prfx_str_lbu, {\b C_real} val_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_lreal} ({\b C_str} prfx_str_lbu, {\b Cl_real} val_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_ptr} ({\b C_str} prfx_str_lbu, {\b C_ptr} val_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_err} ({\b C_str} fbk_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Str} {\b read_term_in} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Str} {\b read_term_in_min_chrs} ({\b C_byte} min_chrs, {\b C_str} req_str, {\b C_str} err_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Confirm} {\b read_term_in_confirm} ({\b C_str} req_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Str} {\b read_term_in_min_chrs_exit_chr} ({\b C_byte} min_chrs, {\b C_str} req_str, {\b C_str} err_str, {\b C_char} exit_chr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b read_term_in_int} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b read_term_in_int_inrange} ({\b C_int} min_val, {\b C_int} max_val, {\b C_str} req_str, {\b C_str} err_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clr_term_in} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_print} ({\b C_str} str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_str} ({\b C_str} str, {\b C_str} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_int} ({\b C_str} str, {\b C_int} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_real} ({\b C_str} str, {\b C_real} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_lreal} ({\b C_str} str, {\b Cl_real} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_ptr} ({\b C_str} str, {\b C_ptr} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_err} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_fbk} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_keyboard_interrupt} ({\b C_int} signal)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const typedef char {\b C_char}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const typedef {\b Byte} {\b C_byte}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const typedef int {\b C_int}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const typedef {\b Real} {\b C_real}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const typedef long double {\b Cl_real}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const typedef {\b Str} {\b Cstr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const typedef {\b U_shrt} {\b Cu_shrt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const typedef void *const {\b C_ptr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b term_in_buff} [{\b IN_BUFF_SIZE}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b unused}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v BU\:lib_ui.h}
{\xe \v lib_ui.h\:BU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BU\~ "\\033[0;34m"}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file lib_ui.h.}\par
}
{\xe \v CY\:lib_ui.h}
{\xe \v lib_ui.h\:CY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CY\~ "\\033[0;36m"}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 29 of file lib_ui.h.}\par
}
{\xe \v ER\:lib_ui.h}
{\xe \v lib_ui.h\:ER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ER\~ "\\033[0m"}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file lib_ui.h.}\par
}
{\xe \v GN\:lib_ui.h}
{\xe \v lib_ui.h\:GN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GN\~ "\\033[0;32m"}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file lib_ui.h.}\par
}
{\xe \v IN_BUFF_SIZE\:lib_ui.h}
{\xe \v lib_ui.h\:IN_BUFF_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IN_BUFF_SIZE\~ 31}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 21 of file lib_ui.h.}\par
}
{\xe \v LBU\:lib_ui.h}
{\xe \v lib_ui.h\:LBU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LBU\~ "\\033[1;34m"}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 27 of file lib_ui.h.}\par
}
{\xe \v LGN\:lib_ui.h}
{\xe \v lib_ui.h\:LGN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LGN\~ "\\033[1;32m"}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file lib_ui.h.}\par
}
{\xe \v LGY\:lib_ui.h}
{\xe \v lib_ui.h\:LGY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LGY\~ "\\033[0;37m"}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file lib_ui.h.}\par
}
{\xe \v OG\:lib_ui.h}
{\xe \v lib_ui.h\:OG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OG\~ "\\033[0;33m"}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file lib_ui.h.}\par
}
{\xe \v PU\:lib_ui.h}
{\xe \v lib_ui.h\:PU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PU\~ "\\033[0;35m"}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file lib_ui.h.}\par
}
{\xe \v RD\:lib_ui.h}
{\xe \v lib_ui.h\:RD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RD\~ "\\033[0;31m"}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 25 of file lib_ui.h.}\par
}
{\xe \v YE\:lib_ui.h}
{\xe \v lib_ui.h\:YE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define YE\~ "\\033[1;33m"}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 30 of file lib_ui.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v Byte\:lib_ui.h}
{\xe \v lib_ui.h\:Byte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned char {\b Byte}}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file lib_ui.h.}\par
}
{\xe \v C_str\:lib_ui.h}
{\xe \v lib_ui.h\:C_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef const {\b Cstr} {\b C_str}}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file lib_ui.h.}\par
}
{\xe \v Confirm\:lib_ui.h}
{\xe \v lib_ui.h\:Confirm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b confirm} {\b Confirm}}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v L_real\:lib_ui.h}
{\xe \v lib_ui.h\:L_real}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef long double {\b L_real}}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file lib_ui.h.}\par
}
{\xe \v Ptr\:lib_ui.h}
{\xe \v lib_ui.h\:Ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void* {\b Ptr}}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file lib_ui.h.}\par
}
{\xe \v Real\:lib_ui.h}
{\xe \v lib_ui.h\:Real}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef double {\b Real}}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file lib_ui.h.}\par
}
{\xe \v Str\:lib_ui.h}
{\xe \v lib_ui.h\:Str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef char* {\b Str}}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file lib_ui.h.}\par
}
{\xe \v U_int\:lib_ui.h}
{\xe \v lib_ui.h\:U_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned int {\b U_int}}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file lib_ui.h.}\par
}
{\xe \v U_long\:lib_ui.h}
{\xe \v lib_ui.h\:U_long}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned long {\b U_long}}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file lib_ui.h.}\par
}
{\xe \v U_shrt\:lib_ui.h}
{\xe \v lib_ui.h\:U_shrt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned short {\b U_shrt}}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file lib_ui.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v confirm\:lib_ui.h}
{\xe \v lib_ui.h\:confirm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b confirm}}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v YES\:lib_ui.h}
{\xe \v lib_ui.h\:YES}
{\qr YES{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
\cell }{\cell }{\row }
{\xe \v NO\:lib_ui.h}
{\xe \v lib_ui.h\:NO}
{\qr NO{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
\cell }{\cell }{\row }
{\xe \v CANCEL\:lib_ui.h}
{\xe \v lib_ui.h\:CANCEL}
{\qr CANCEL{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
\cell }{\cell }{\row }
}
\par
{
Definition at line 39 of file lib_ui.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00039 \{YES, NO, CANCEL\} Confirm;                                                             {\cf20 // Confirmation enum typedef}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v close_err\:lib_ui.h}
{\xe \v lib_ui.h\:close_err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_err ()}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 313 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00313                 \{                                                                                           {\cf20 // Close software with error function}\par
00314   {\cf20 /* Body */}\par
00315   printf({\cf22 "\\n%s>>>%s Closin' due to error... %sSorry! %s:(%s\\n"}, OG, RD, CY, OG, ER);                        {\cf20 // Closin' due to error fbk}\par
00316   exit(EXIT_FAILURE);                                                                                       {\cf20 // Close software}\par
00317 \}\par
}
}
{\xe \v close_fbk\:lib_ui.h}
{\xe \v lib_ui.h\:close_fbk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_fbk ()}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 320 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00320                 \{                                                                                           {\cf20 // Function to close software with feedback}\par
00321   {\cf20 /* Body */}\par
00322   printf({\cf22 "\\n\\n%s>>>%s Closin'... %sBye! %s;)%s\\n"}, GN, PU, CY, RD, ER);                                     {\cf20 // Closin' fbk}\par
00323   exit(EXIT_SUCCESS);                                                                                       {\cf20 // Close software}\par
00324 \}\par
}
}
{\xe \v close_keyboard_interrupt\:lib_ui.h}
{\xe \v lib_ui.h\:close_keyboard_interrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_keyboard_interrupt ({\b C_int}  {\i signal})}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 327 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00327                                            \{                                                                {\cf20 // Function to close SW with fbk due to keyboard interrupt detected (ctrl+c)}\par
00328   {\cf20 /* Body */}\par
00329   printf({\cf22 "\\n\\n%s>>>%s Keyboard interrupt detected, closin'... %sBye! %s;)%s\\n"}, GN, PU, CY, RD, ER);        {\cf20 // Closin' fbk}\par
00330   exit(signal);                                                                                             {\cf20 // Exit SW with signal}\par
00331 \}\par
}
}
{\xe \v clr_term_in\:lib_ui.h}
{\xe \v lib_ui.h\:clr_term_in}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void clr_term_in ()}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 265 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00265                   \{                                                                                         {\cf20 // Clear terminal input buffer function}\par
00266   {\cf20 /* Body */}\par
00267   strcpy(term_in_buff, {\cf22 "\\0"});                                                                               {\cf20 // Clear input buffer char array}\par
00268 \}\par
}
}
{\xe \v dbg\:lib_ui.h}
{\xe \v lib_ui.h\:dbg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg ()}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 271 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00271           \{                                                                                                 {\cf20 // Fast debug function}\par
00272   {\cf20 /* Body */}\par
00273   printf({\cf22 "\\n\\n%s    >>>>>> %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, LGN, ER);                                   {\cf20 // Print debug line}\par
00274 \}\par
}
}
{\xe \v dbg_int\:lib_ui.h}
{\xe \v lib_ui.h\:dbg_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_int ({\b C_str}  {\i str}, {\b C_int}  {\i val})}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 289 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00289                                   \{                                                                         {\cf20 // Debug int val print function}\par
00290   {\cf20 /* Body */}\par
00291   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%d %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);      {\cf20 // Print debug line}\par
00292 \}\par
}
}
{\xe \v dbg_lreal\:lib_ui.h}
{\xe \v lib_ui.h\:dbg_lreal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_lreal ({\b C_str}  {\i str}, {\b Cl_real}  {\i val})}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 301 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00301                                       \{                                                                     {\cf20 // Debug long real val print function}\par
00302   {\cf20 /* Body */}\par
00303   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%Lg %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);     {\cf20 // Print debug line}\par
00304 \}\par
}
}
{\xe \v dbg_print\:lib_ui.h}
{\xe \v lib_ui.h\:dbg_print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_print ({\b C_str}  {\i str})}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 277 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00277                          \{                                                                                  {\cf20 // Debug print function}\par
00278   {\cf20 /* Body */}\par
00279   printf({\cf22 "\\n\\n%s    >>>>>>%s %s %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, LGN, ER);                     {\cf20 // Print debug line}\par
00280 \}\par
}
}
{\xe \v dbg_ptr\:lib_ui.h}
{\xe \v lib_ui.h\:dbg_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_ptr ({\b C_str}  {\i str}, {\b C_ptr}  {\i val})}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 307 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00307                                   \{                                                                         {\cf20 // Debug ptr val print function}\par
00308   {\cf20 /* Body */}\par
00309   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%p %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);      {\cf20 // Print debug line}\par
00310 \}\par
}
}
{\xe \v dbg_real\:lib_ui.h}
{\xe \v lib_ui.h\:dbg_real}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_real ({\b C_str}  {\i str}, {\b C_real}  {\i val})}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 295 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00295                                     \{                                                                       {\cf20 // Debug real val print function}\par
00296   {\cf20 /* Body */}\par
00297   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%g %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);      {\cf20 // Print debug line}\par
00298 \}\par
}
}
{\xe \v dbg_str\:lib_ui.h}
{\xe \v lib_ui.h\:dbg_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_str ({\b C_str}  {\i str}, {\b C_str}  {\i val})}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 283 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00283                                   \{                                                                         {\cf20 // Debug string val print function}\par
00284   {\cf20 /* Body */}\par
00285   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%s %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);      {\cf20 // Print debug line}\par
00286 \}\par
}
}
{\xe \v fbk_err\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_err ({\b C_str}  {\i fbk_str})}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 151 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00151                            \{                                                                                {\cf20 // Error feedback function}\par
00152   {\cf20 /* Body */}\par
00153   printf({\cf22 "\\n%s>>>%s %s!%s\\n"}, OG, RD, fbk_str, ER);                                                         {\cf20 // Print error fbk}\par
00154 \}\par
}
}
{\xe \v fbk_gn_cy\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_gn_cy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_cy ({\b C_str}  {\i fbk_str})}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 109 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00109                              \{                                                                              {\cf20 // Green-cyan feedback function}\par
00110   {\cf20 /* Body */}\par
00111   printf({\cf22 "%s>>>%s %s%s"}, GN, CY, fbk_str, ER);                                                              {\cf20 // Print green-cyan string fbk}\par
00112 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_int\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_gn_lbu_ye_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_int ({\b C_str}  {\i prfx_str_lbu}, {\b C_int}  {\i val_ye})}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 121 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00121                                                         \{                                                   {\cf20 // Green-lightblue-yellow int val feedback function}\par
00122   {\cf20 /* Body */}\par
00123   printf({\cf22 "%s>>>%s %s: %s%d%s"}, GN, LBU, prfx_str_lbu, YE, val_ye, ER);                                      {\cf20 // Print green-lightblue-yellow int val feedback}\par
00124 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_lreal\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_gn_lbu_ye_lreal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_lreal ({\b C_str}  {\i prfx_str_lbu}, {\b Cl_real}  {\i val_ye})}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00139                                                             \{                                               {\cf20 // Green-lightblue-yellow long real val feedback function}\par
00140   {\cf20 /* Body */}\par
00141   printf({\cf22 "%s>>>%s %s: %s%Lg%s"}, GN, LBU, prfx_str_lbu, YE, val_ye, ER);                                     {\cf20 // Print green-lightblue-yellow long real val feedback}\par
00142 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_ptr\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_gn_lbu_ye_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_ptr ({\b C_str}  {\i prfx_str_lbu}, {\b C_ptr}  {\i val_ye})}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 145 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00145                                                         \{                                                   {\cf20 // Green-lightblue-yellow ptr val feedback function}\par
00146   {\cf20 /* Body */}\par
00147   printf({\cf22 "%s>>>%s %s: %s%p%s"}, GN, LBU, prfx_str_lbu, YE, val_ye, ER);                                      {\cf20 // Print green-lightblue-yellow ptr val feedback}\par
00148 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_real\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_gn_lbu_ye_real}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_real ({\b C_str}  {\i prfx_str_lbu}, {\b C_real}  {\i val_ye})}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 133 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00133                                                           \{                                                 {\cf20 // Green-lightblue-yellow real val feedback function}\par
00134   {\cf20 /* Body */}\par
00135   printf({\cf22 "%s>>>%s %s: %s%g%s"}, GN, LBU, prfx_str_lbu, YE, val_ye, ER);                                      {\cf20 // Print green-lightblue-yellow real val feedback}\par
00136 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_str\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_gn_lbu_ye_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_str ({\b C_str}  {\i prfx_str_lbu}, {\b C_str}  {\i str_ye})}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 127 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00127                                                         \{                                                   {\cf20 // Green-lightblue-yellow str val feedback function}\par
00128   {\cf20 /* Body */}\par
00129   printf({\cf22 "%s>>>%s %s: %s%s%s"}, GN, LBU, prfx_str_lbu, YE, str_ye, ER);                                      {\cf20 // Print green-lightblue-yellow str val feedback}\par
00130 \}\par
}
}
{\xe \v fbk_gn_pu\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_gn_pu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_pu ({\b C_str}  {\i fbk_str})}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 115 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00115                              \{                                                                              {\cf20 // Green-purple feedback function}\par
00116   {\cf20 /* Body */}\par
00117   printf({\cf22 "%s>>>%s %s%s"}, GN, PU, fbk_str, ER);                                                              {\cf20 // Print green-purple string fbk}\par
00118 \}\par
}
}
{\xe \v fbk_nl\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_nl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_nl ({\b C_int}  {\i num})}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00079                       \{                                                                                     {\cf20 // New lines feedback function}\par
00080   {\cf20 /* Body */}\par
00081   {\cf19 for} ({\cf18 int} i = 0; i < num; ++i)                                                                             {\cf20 // Chars printin' FOR cycle}\par
00082     printf({\cf22 "\\n"});                                                                                           {\cf20 // Print new line fbk}\par
00083 \}\par
}
}
{\xe \v fbk_separator\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_separator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_separator ({\b C_char}  {\i chr}, {\b C_str}  {\i col})}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 100 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00100                                          \{                                                                  {\cf20 // Separator feedback function}\par
00101   {\cf20 /* Body */}\par
00102   {\cf17 struct }winsize w;                                                                                         {\cf20 // Window-size struct declaration}\par
00103   ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);                                                                     {\cf20 // Save the number of terminal's rows/cloumns in window-size struct}\par
00104   {\cf19 for} ({\cf18 int} i = 0; i < w.ws_col; ++i)                                                                        {\cf20 // Chars printin' FOR cycle}\par
00105     printf({\cf22 "%s%c%s"}, col, chr, ER);                                                                         {\cf20 // Print space fbk}\par
00106 \}\par
}
}
{\xe \v fbk_spaces\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_spaces}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_spaces ({\b C_int}  {\i num})}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 86 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00086                           \{                                                                                 {\cf20 // Spces feedback function}\par
00087   {\cf20 /* Body */}\par
00088   {\cf19 for} ({\cf18 int} i = 0; i < num; ++i)                                                                             {\cf20 // Chars printin' FOR cycle}\par
00089     printf({\cf22 " "});                                                                                            {\cf20 // Print space fbk}\par
00090 \}\par
}
}
{\xe \v fbk_tabs\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_tabs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_tabs ({\b C_int}  {\i num})}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 93 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00093                         \{                                                                                   {\cf20 // Tabs feedback function}\par
00094   {\cf20 /* Body */}\par
00095   {\cf19 for} ({\cf18 int} i = 0; i < num; ++i)                                                                             {\cf20 // Chars printin' FOR cycle}\par
00096     printf({\cf22 "\\t"});                                                                                           {\cf20 // Print tab fbk}\par
00097 \}\par
}
}
{\xe \v logo\:lib_ui.h}
{\xe \v lib_ui.h\:logo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void logo ({\b Cu_shrt}  {\i start_sp}, {\b C_str}  {\i txt}, {\b C_str}  {\i txt_col}, {\b C_char}  {\i bkg_chr}, {\b C_str}  {\i bkg_col})}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00020                                                                                     \{                       {\cf20 // Print responsive-logo function}\par
00021   {\cf20 /* Body */}\par
00022   {\cf17 struct }winsize w;                                                                                         {\cf20 // Window-size struct declaration}\par
00023   ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);                                                                     {\cf20 // Save the number of terminal's rows/cloumns in window-size struct}\par
00024   Cu_shrt vthck = (w.ws_row / 5);                                                                           {\cf20 // Logo bkg vertical thickness calc}\par
00025   Cu_shrt lthck = (w.ws_col / 6);                                                                           {\cf20 // Logo bkg lateral thickness calc}\par
00026   Cu_shrt lsp = (Cu_shrt)(w.ws_col - 2*lthck - 2*start_sp - (Cu_shrt)strlen(txt)) / 2;                      {\cf20 // Logo internal lateral spaces calc}\par
00027   Cu_shrt len = (Cu_shrt)(2*lthck+2*lsp+(Cu_shrt)strlen(txt));                                              {\cf20 // Logo length calc}\par
00028   {\cf20 // Print logo}\par
00029   printf({\cf22 "\\n%s"}, bkg_col);                                                                                  {\cf20 // New line fbk}\par
00030   {\cf19 for} (U_shrt i = 0; i < (4*vthck+1); ++i)\{                                                                 {\cf20 // Logo lines print FOR cycle}\par
00031     {\cf19 for} (U_shrt j = 0; j < start_sp; ++j)\{                                                                  {\cf20 // Initial spaces print FOR cycle}\par
00032       printf({\cf22 " "});                                                                                          {\cf20 // Print initial spaces}\par
00033     \}\par
00034     {\cf19 if} ((i < vthck || i > (3*vthck)) && (i != (4*vthck)/2))\{                                                {\cf20 // Full bkg logo lines print cond}\par
00035       {\cf19 for} (U_shrt h = 0; h < len; ++h)\{                                                                     {\cf20 // Full bkg logo lines print FOR cycle}\par
00036         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Bkg logo char print}\par
00037       \}\par
00038       fbk_nl(1);                                                                                            {\cf20 // New line feedback function call}\par
00039     \} {\cf19 else} {\cf19 if} ((i >= vthck && i <= (3*vthck)) && (i != (4*vthck)/2)) \{                                      {\cf20 // Partial-empty bkg logo lines print cond}\par
00040       {\cf19 for} (U_shrt l = 0; l < lthck; ++l)\{                                                                   {\cf20 // Partial-empty bkg logo lines, initial full part print FOR cycle}\par
00041         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Partial-empty bkg logo lines, initial full part print}\par
00042       \}\par
00043       {\cf19 for} (U_shrt m = 0; m < (len - 2*lthck); ++m)\{                                                         {\cf20 // Partial-empty bkg logo lines, central empty part print FOR cycle}\par
00044         printf({\cf22 " "});                                                                                        {\cf20 // Partial-empty bkg logo lines, central empty part print}\par
00045       \}\par
00046       {\cf19 for} (U_shrt n = 0; n < lthck; ++n)\{                                                                   {\cf20 // Partial-empty bkg logo lines, final full part print FOR cycle}\par
00047         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Partial-empty bkg logo lines, final full part print}\par
00048       \}\par
00049       fbk_nl(1);                                                                                            {\cf20 // New line feedback function call}\par
00050     \} {\cf19 else} {\cf19 if} (i == ((4*vthck)/2)) \{                                                                        {\cf20 // Text logo line initial full part print cond}\par
00051       {\cf19 for} (U_shrt o = 0; o < lthck; ++o)\{                                                                   {\cf20 // Text logo line initial full part print FOR cycle}\par
00052         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Text logo line initial full part print}\par
00053       \}\par
00054       {\cf19 for} (U_shrt p = 0; p < lsp; ++p)\{                                                                     {\cf20 // Text logo line central empty part print FOR cycle}\par
00055         printf({\cf22 " "});                                                                                        {\cf20 // Text logo line central empty part print}\par
00056       \}\par
00057       printf({\cf22 "%s%s%s"}, txt_col, txt, bkg_col);                                                              {\cf20 // Text logo line central text part print}\par
00058       {\cf19 for} (U_shrt q = 0; q < lsp; ++q)\{                                                                     {\cf20 // Text logo line central empty part print FOR cycle}\par
00059         printf({\cf22 " "});                                                                                        {\cf20 // Text logo line central empty part print}\par
00060       \}\par
00061       {\cf19 for} (U_shrt r = 0; r < lthck; ++r)\{                                                                   {\cf20 // Text logo line final full part print FOR cycle}\par
00062         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Text logo line final full part print}\par
00063       \}\par
00064       fbk_nl(1);                                                                                            {\cf20 // New line feedback function call}\par
00065     \}\par
00066   \}\par
00067   printf(ER);                                                                                               {\cf20 // New line fbk and erase logo bkg color}\par
00068 \}\par
}
}
{\xe \v press_enter\:lib_ui.h}
{\xe \v lib_ui.h\:press_enter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void press_enter ({\b C_str}  {\i req_str})}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00071                                \{                                                                            {\cf20 // Press enter function}\par
00072   {\cf20 /* Body */}\par
00073   printf({\cf22 "\\n\\n%s>>>%s %s! %sPress %sENTER%s to contine... %s;)%s"},\par
00074           GN, PU, req_str, CY, YE, CY, RD, ER);                                                             {\cf20 // Build map, press enter key to start fbk}\par
00075   read_term_in();                                                                                           {\cf20 // Wait enter key to start (read terminal input function call)}\par
00076 \}\par
}
}
{\xe \v read_term_in\:lib_ui.h}
{\xe \v lib_ui.h\:read_term_in}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Str} read_term_in ()}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 157 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00157                   \{                                                                                         {\cf20 // Read terminal input function}\par
00158   {\cf20 /* Body */}\par
00159   unused = scanf({\cf22 "%30[^\\n]"}, term_in_buff);                                                                 {\cf20 // Reads the string 'till '\\n' char, avoidin' scanf stop at space char and saving '\\n' chr (str var definition) --> avoid buffer overflow assigning max input str size to (31-1)=30 for '\\0' char}\par
00160   {\cf19 while} ((getchar()) != {\cf23 '\\n'});                                                                              {\cf20 // Instruction to clear input buffer when buffer overflow occurs, avoiding to save next char as new input}\par
00161   {\cf19 return} term_in_buff;                                                                                      {\cf20 // Return terminal input string}\par
00162 \}\par
}
}
{\xe \v read_term_in_confirm\:lib_ui.h}
{\xe \v lib_ui.h\:read_term_in_confirm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Confirm} read_term_in_confirm ({\b C_str}  {\i req_str})}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 186 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00186                                            \{                                                                {\cf20 // Read terminal input confirmation function}\par
00187   {\cf20 /* Body */}\par
00188   Str in_str;                                                                                               {\cf20 // Terminal input string tmp var}\par
00189   Confirm answ;                                                                                             {\cf20 // Confirmation answer}\par
00190   Byte exit_flg = 0;                                                                                        {\cf20 // Terminal input while-loop exit flag}\par
00191   {\cf20 // Read input from terminal}\par
00192   {\cf19 do}\{\par
00193     clr_term_in();                                                                                          {\cf20 // Clear terminal input buffer function call}\par
00194     printf({\cf22 "%s>>>%s %s?%s Options %s(yes/no/cancel)%s%s: %s"}, GN, PU, req_str, BU, OG, BU, PU, ER);         {\cf20 // Print request fbk}\par
00195     in_str = read_term_in();                                                                                {\cf20 // Read terminal input function call}\par
00196     {\cf19 if} (0 == strcmp(in_str, {\cf22 "yes"}) || 0 == strcmp(in_str, {\cf22 "YES"}) || 0 == strcmp(in_str, {\cf22 "Yes"}))\{            {\cf20 // YES answer}\par
00197       answ = YES;                                                                                           {\cf20 // Set answer = YES}\par
00198       ++exit_flg;                                                                                           {\cf20 // Set exit flag}\par
00199     \} {\cf19 else} {\cf19 if} (0 == strcmp(in_str, {\cf22 "no"}) || 0 == strcmp(in_str, {\cf22 "NO"}) ||\par
00200                0 == strcmp(in_str, {\cf22 "No"}) || 0 == strcmp(in_str, {\cf22 "nO"}))\{                                     {\cf20 // NO answer}\par
00201       answ = NO;                                                                                            {\cf20 // Set answer = NO}\par
00202       ++exit_flg;                                                                                           {\cf20 // Set exit flag}\par
00203     \} {\cf19 else} {\cf19 if}(0 == strcmp(in_str, {\cf22 "cancel"}) || 0 == strcmp(in_str, {\cf22 "CANCEL"}) ||\par
00204               0 == strcmp(in_str, {\cf22 "Cancel"}))\{                                                               {\cf20 // CANCEL answer}\par
00205       answ = CANCEL;                                                                                        {\cf20 // Set answer = CANCEL}\par
00206       ++exit_flg;                                                                                           {\cf20 // Set exit flag}\par
00207     \}\par
00208     {\cf20 // Chk xit flg}\par
00209     {\cf19 if} (!exit_flg)                                                                                          {\cf20 // Exit flag val chack}\par
00210       printf({\cf22 "%s>>>%s The answer must be %s(yes/no/cancel)%s!%s\\n"}, OG, RD, YE, RD, ER);                    {\cf20 // Print terminal input error fbk}\par
00211   \} {\cf19 while}(!exit_flg);                                                                                       {\cf20 // Check while-loop exit flag val}\par
00212   \par
00213   {\cf19 return} answ;                                                                                              {\cf20 // Return confirmation answer}\par
00214 \}\par
}
}
{\xe \v read_term_in_int\:lib_ui.h}
{\xe \v lib_ui.h\:read_term_in_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int read_term_in_int ()}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 238 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00238                       \{                                                                                     {\cf20 // Read terminal input INT function}\par
00239   {\cf20 /* Body */}\par
00240   {\cf19 return} atoi(read_term_in());                                                                              {\cf20 // Return integer conversion of input string}\par
00241 \}\par
}
}
{\xe \v read_term_in_int_inrange\:lib_ui.h}
{\xe \v lib_ui.h\:read_term_in_int_inrange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int read_term_in_int_inrange ({\b C_int}  {\i min_val}, {\b C_int}  {\i max_val}, {\b C_str}  {\i req_str}, {\b C_str}  {\i err_str})}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 244 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00244                                                                                         \{                   {\cf20 // Read terminal input INT (in-range) function}\par
00245   {\cf20 /* Body */}\par
00246   {\cf18 int} val = 0;                                                                                              {\cf20 // Terminal input value}\par
00247   Byte exit_flg = 0;                                                                                        {\cf20 // Terminal input while-loop exit flag}\par
00248   {\cf20 // Read terminal input}\par
00249   {\cf19 do}\{\par
00250     clr_term_in();                                                                                          {\cf20 // Clear terminal input buffer function call}\par
00251     printf({\cf22 "%s>>>%s %s %s(min %s%d%s, max %s%d%s and NOT %s0%s)%s: %s"},\par
00252             GN, PU, req_str, BU, OG, min_val, BU, OG, max_val, BU, OG, BU, PU, ER);                         {\cf20 // Enter the number of crosses to allocate fbk}\par
00253     val = read_term_in_int();                                                                               {\cf20 // Read terminal input INT function call}\par
00254     exit_flg = (val >= min_val && val <= max_val && val != 0);                                              {\cf20 // Terminal input while-loop exit flag val upd}\par
00255     {\cf20 // Chk xit flg}\par
00256     {\cf19 if} (!exit_flg)                                                                                          {\cf20 // Exit flag val chack}\par
00257       printf({\cf22 "%s>>>%s %s must be in %s[%d, %d]%s range!%s\\n"},\par
00258               OG, RD, err_str, YE, min_val, max_val, RD, ER);                                               {\cf20 // Print terminal input error fbk}\par
00259   \} {\cf19 while}(!exit_flg);                                                                                       {\cf20 // Check while-loop exit flag val}\par
00260     \par
00261   {\cf19 return} val;                                                                                               {\cf20 // Return terminal input val}\par
00262 \}\par
}
}
{\xe \v read_term_in_min_chrs\:lib_ui.h}
{\xe \v lib_ui.h\:read_term_in_min_chrs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Str} read_term_in_min_chrs ({\b C_byte}  {\i min_chrs}, {\b C_str}  {\i req_str}, {\b C_str}  {\i err_str})}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 165 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00165                                                                         \{                                   {\cf20 // Read terminal input (min chars) function}\par
00166   {\cf20 /* Body */}\par
00167   Str in_str;                                                                                               {\cf20 // Terminal input string tmp var}\par
00168   Byte exit_flg = 0;                                                                                        {\cf20 // Terminal input while-loop exit flag}\par
00169   {\cf20 // Read input from terminal}\par
00170   {\cf19 do}\{\par
00171     clr_term_in();                                                                                          {\cf20 // Clear terminal input buffer function call}\par
00172     printf({\cf22 "\\n%s>>>%s %s,%s at least %s%d%s char(s), max %s%d%s chars%s: %s"},\par
00173             GN, PU, req_str, BU, OG, min_chrs, BU, OG, IN_BUFF_SIZE-1, BU, PU, ER);                         {\cf20 // Print request fbk}\par
00174     in_str = read_term_in();                                                                                {\cf20 // Read terminal input function call}\par
00175     exit_flg = (strlen(in_str) >= min_chrs);                                                                {\cf20 // Terminal input while-loop exit flag val upd}\par
00176     {\cf20 // Chk xit flg}\par
00177     {\cf19 if} (!exit_flg)                                                                                          {\cf20 // Exit flag val chack}\par
00178       printf({\cf22 "%s>>>%s %s must be at least %s%d%s char(s) long!%s\\n"},\par
00179               OG, RD, err_str, YE, min_chrs, RD, ER);                                                       {\cf20 // Print terminal input error fbk}\par
00180   \} {\cf19 while}(!exit_flg);                                                                                       {\cf20 // Check while-loop exit flag val}\par
00181   \par
00182   {\cf19 return} in_str;                                                                                            {\cf20 // Return terminal input string}\par
00183 \}\par
}
}
{\xe \v read_term_in_min_chrs_exit_chr\:lib_ui.h}
{\xe \v lib_ui.h\:read_term_in_min_chrs_exit_chr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Str} read_term_in_min_chrs_exit_chr ({\b C_byte}  {\i min_chrs}, {\b C_str}  {\i req_str}, {\b C_str}  {\i err_str}, {\b C_char}  {\i exit_chr})}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 217 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00217                                                                                                   \{         {\cf20 // Read terminal input (min chars and exit char) function}\par
00218   {\cf20 /* Body */}\par
00219   Str in_str;                                                                                               {\cf20 // Terminal input string tmp var}\par
00220   Byte exit_flg = 0;                                                                                        {\cf20 // Terminal input while-loop exit flag}\par
00221   {\cf20 // Read terminal input}\par
00222   {\cf19 do}\{\par
00223     clr_term_in();                                                                                          {\cf20 // Clear terminal input buffer function call}\par
00224     printf({\cf22 "%s>>>%s %s %s(at least %s%d%s char(s) and max %s%d%s, type %s'%c'%s char to continue)%s: %s"},\par
00225             GN, PU, req_str, BU, OG, min_chrs, BU, OG, IN_BUFF_SIZE-1, BU, OG, exit_chr, BU, PU, ER);       {\cf20 // Print request fbk}\par
00226     in_str = read_term_in();                                                                                {\cf20 // Read terminal input function call}\par
00227     exit_flg = (strlen(in_str) >= min_chrs) || (*in_str == exit_chr);                                       {\cf20 // Terminal input while-loop exit flag val upd}\par
00228     {\cf20 // Chk xit flg}\par
00229     {\cf19 if} (!exit_flg)                                                                                          {\cf20 // Exit flag val chack}\par
00230       printf({\cf22 "%s>>>%s %s must be at least %s%d%s char(s) long!%s\\n"},\par
00231               OG, RD, err_str, YE, min_chrs, RD, ER);                                                       {\cf20 // Print terminal input error fbk}\par
00232   \} {\cf19 while}(!exit_flg);                                                                                       {\cf20 // Check while-loop exit flag val}\par
00233   \par
00234   {\cf19 return} in_str;                                                                                            {\cf20 // Return terminal input string}\par
00235 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v C_byte\:lib_ui.h}
{\xe \v lib_ui.h\:C_byte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const typedef {\b Byte} C_byte}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file lib_ui.h.}\par
}
{\xe \v C_char\:lib_ui.h}
{\xe \v lib_ui.h\:C_char}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const typedef char C_char}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 51 of file lib_ui.h.}\par
}
{\xe \v C_int\:lib_ui.h}
{\xe \v lib_ui.h\:C_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const typedef int C_int}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 53 of file lib_ui.h.}\par
}
{\xe \v C_ptr\:lib_ui.h}
{\xe \v lib_ui.h\:C_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const typedef void* const C_ptr}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file lib_ui.h.}\par
}
{\xe \v C_real\:lib_ui.h}
{\xe \v lib_ui.h\:C_real}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const typedef {\b Real} C_real}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 54 of file lib_ui.h.}\par
}
{\xe \v Cl_real\:lib_ui.h}
{\xe \v lib_ui.h\:Cl_real}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const typedef long double Cl_real}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file lib_ui.h.}\par
}
{\xe \v Cstr\:lib_ui.h}
{\xe \v lib_ui.h\:Cstr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const typedef {\b Str} Cstr}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file lib_ui.h.}\par
}
{\xe \v Cu_shrt\:lib_ui.h}
{\xe \v lib_ui.h\:Cu_shrt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const typedef {\b U_shrt} Cu_shrt}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 58 of file lib_ui.h.}\par
}
{\xe \v term_in_buff\:lib_ui.h}
{\xe \v lib_ui.h\:term_in_buff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char term_in_buff[{\b IN_BUFF_SIZE}]}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file lib_ui.c.}\par
}
{\xe \v unused\:lib_ui.h}
{\xe \v lib_ui.h\:unused}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int unused}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/ui/lib_ui.so File Reference\par \pard\plain 
{\tc\tcl2 \v lib/ui/lib_ui.so}
{\xe \v lib/ui/lib_ui.so}
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
main/graph_test.c File Reference\par \pard\plain 
{\tc\tcl2 \v main/graph_test.c}
{\xe \v main/graph_test.c}
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
-. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../lib/graph/lib_graph.h"}\par
{\f2 #include "../lib/files/lib_files.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b street}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VERBOSE}\~ {\b Y}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SOURCE_NODE_NAME}\~ "Cross4"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DESTINATION_NODE_NAME}\~ "Cross9"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEST_NODE_NAME_SPECIAL_CASE1}\~ "Cross4"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEST_NODE_NAME_SPECIAL_CASE2}\~ "Cross10"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GPLOT_TEST_GRAPH_LAYOUT_CMD}\~ "gnuplot -e \\"load 'gnuplot/graph_plot.cmd'; pause -1\\""\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GPLOT_SHORTEST_PATH_CMD}\~ "gnuplot -e \\"load 'gnuplot/shortest_plot.cmd'; pause -1\\""\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ARCHS_DAT_FILE}\~ "gnuplot/archs.dat"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COSTS_DAT_FILE}\~ "gnuplot/costs.dat"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NODES_DAT_FILE}\~ "gnuplot/nodes.dat"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHORTEST_ARCHS_DAT_FILE}\~ "gnuplot/shortest_archs.dat"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHORTEST_COSTS_DAT_FILE}\~ "gnuplot/shortest_costs.dat"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHORTEST_NODES_DAT_FILE}\~ "gnuplot/shortest_nodes.dat"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SRC_DEST_NODES_DAT_FILE}\~ "gnuplot/src_dest_nodes.dat"\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b test_choice} {\b Test_choice}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b street} {\b Street}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b test_choice} \{ {\b PREPARED} =1, 
{\b PERSONALIZED}, 
{\b EXIT}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b terminate_keyboard} (int signal)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Static routine to manage close keyboard interrupt signal printing feedback to terminal. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b create_archs} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Static routine to create test-graph arches, working on graph-library public variables. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b create_nodes} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Static routine to create test-graph nodes, working on graph-library public variables. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b create_connections} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Static routine to create test-graph arch-nodes connections, working on graph-library public variables. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b test_option_choice} ({\b Test_choice} *const choice)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Static routine to give give user the possibility to choose testing option: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b build_shortest_path_graphics_data} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b display_test_graph} ({\b C_str} cmd)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b apply_dijkstra} ({\b C_str} src_nd_name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b reconstruct_min_path} ({\b C_str} dest_nd_name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b define_src_node_name} ({\b Str} *src_nd_nm)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b define_dest_node_name} ({\b Str} *dest_nd_nm)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Street} {\b strts_vect} []\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b C_str} {\b crss_names_vect} []\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
-. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
-. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ARCHS_DAT_FILE\:graph_test.c}
{\xe \v graph_test.c\:ARCHS_DAT_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ARCHS_DAT_FILE\~ "gnuplot/archs.dat"}}
\par
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 83 of file graph_test.c.}\par
}
{\xe \v COSTS_DAT_FILE\:graph_test.c}
{\xe \v graph_test.c\:COSTS_DAT_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COSTS_DAT_FILE\~ "gnuplot/costs.dat"}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 84 of file graph_test.c.}\par
}
{\xe \v DEST_NODE_NAME_SPECIAL_CASE1\:graph_test.c}
{\xe \v graph_test.c\:DEST_NODE_NAME_SPECIAL_CASE1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEST_NODE_NAME_SPECIAL_CASE1\~ "Cross4"}}
\par
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file graph_test.c.}\par
}
{\xe \v DEST_NODE_NAME_SPECIAL_CASE2\:graph_test.c}
{\xe \v graph_test.c\:DEST_NODE_NAME_SPECIAL_CASE2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEST_NODE_NAME_SPECIAL_CASE2\~ "Cross10"}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 80 of file graph_test.c.}\par
}
{\xe \v DESTINATION_NODE_NAME\:graph_test.c}
{\xe \v graph_test.c\:DESTINATION_NODE_NAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DESTINATION_NODE_NAME\~ "Cross9"}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 78 of file graph_test.c.}\par
}
{\xe \v GPLOT_SHORTEST_PATH_CMD\:graph_test.c}
{\xe \v graph_test.c\:GPLOT_SHORTEST_PATH_CMD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GPLOT_SHORTEST_PATH_CMD\~ "gnuplot -e \\"load 'gnuplot/shortest_plot.cmd'; pause -1\\""}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 82 of file graph_test.c.}\par
}
{\xe \v GPLOT_TEST_GRAPH_LAYOUT_CMD\:graph_test.c}
{\xe \v graph_test.c\:GPLOT_TEST_GRAPH_LAYOUT_CMD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GPLOT_TEST_GRAPH_LAYOUT_CMD\~ "gnuplot -e \\"load 'gnuplot/graph_plot.cmd'; pause -1\\""}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 81 of file graph_test.c.}\par
}
{\xe \v NODES_DAT_FILE\:graph_test.c}
{\xe \v graph_test.c\:NODES_DAT_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NODES_DAT_FILE\~ "gnuplot/nodes.dat"}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 85 of file graph_test.c.}\par
}
{\xe \v SHORTEST_ARCHS_DAT_FILE\:graph_test.c}
{\xe \v graph_test.c\:SHORTEST_ARCHS_DAT_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHORTEST_ARCHS_DAT_FILE\~ "gnuplot/shortest_archs.dat"}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 86 of file graph_test.c.}\par
}
{\xe \v SHORTEST_COSTS_DAT_FILE\:graph_test.c}
{\xe \v graph_test.c\:SHORTEST_COSTS_DAT_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHORTEST_COSTS_DAT_FILE\~ "gnuplot/shortest_costs.dat"}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 87 of file graph_test.c.}\par
}
{\xe \v SHORTEST_NODES_DAT_FILE\:graph_test.c}
{\xe \v graph_test.c\:SHORTEST_NODES_DAT_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHORTEST_NODES_DAT_FILE\~ "gnuplot/shortest_nodes.dat"}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 88 of file graph_test.c.}\par
}
{\xe \v SOURCE_NODE_NAME\:graph_test.c}
{\xe \v graph_test.c\:SOURCE_NODE_NAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SOURCE_NODE_NAME\~ "Cross4"}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file graph_test.c.}\par
}
{\xe \v SRC_DEST_NODES_DAT_FILE\:graph_test.c}
{\xe \v graph_test.c\:SRC_DEST_NODES_DAT_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SRC_DEST_NODES_DAT_FILE\~ "gnuplot/src_dest_nodes.dat"}}
\par
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 89 of file graph_test.c.}\par
}
{\xe \v VERBOSE\:graph_test.c}
{\xe \v graph_test.c\:VERBOSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VERBOSE\~ {\b Y}}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 76 of file graph_test.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v Street\:graph_test.c}
{\xe \v graph_test.c\:Street}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b street} {\b Street}}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Test_choice\:graph_test.c}
{\xe \v graph_test.c\:Test_choice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b test_choice} {\b Test_choice}}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v test_choice\:graph_test.c}
{\xe \v graph_test.c\:test_choice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b test_choice}}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v PREPARED\:graph_test.c}
{\xe \v graph_test.c\:PREPARED}
{\qr PREPARED{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
\cell }{\cell }{\row }
{\xe \v PERSONALIZED\:graph_test.c}
{\xe \v graph_test.c\:PERSONALIZED}
{\qr PERSONALIZED{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
\cell }{\cell }{\row }
{\xe \v EXIT\:graph_test.c}
{\xe \v graph_test.c\:EXIT}
{\qr EXIT{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
\cell }{\cell }{\row }
}
\par
{
Definition at line 93 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00093 \{PREPARED=1, PERSONALIZED, EXIT\} Test_choice;                                      {\cf20 // Test-choice enum typedef}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v apply_dijkstra\:graph_test.c}
{\xe \v graph_test.c\:apply_dijkstra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void apply_dijkstra ({\b C_str}  {\i src_nd_name}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 353 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00353                                              \{                                                              {\cf20 // Routine to apply Dijkstra's algorithm}\par
00354   {\cf20 /* Body */}\par
00355   dijkstra_alg(src_nd_name, VERBOSE);                                                                       {\cf20 // Apply Dijkstra alg using defined source node (find all min path-costs and prev nodes in shortest paths, Dijkstra-dataset vect allocated/reallocated inside heap) - Y/N for verbose mode}\par
00356 \}\par
}
}
{\xe \v build_shortest_path_graphics_data\:graph_test.c}
{\xe \v graph_test.c\:build_shortest_path_graphics_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void build_shortest_path_graphics_data (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 243 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00243                                                \{                                                            {\cf20 // Routine to build the shortest-path graphics data for gnuplot}\par
00244   {\cf20 /* Body */}\par
00245   fbk_nl(1);  fbk_gn_pu({\cf22 "Building shortest-path graphics data (working on .dat files) for gnuplot..."});     {\cf20 // Print workin' on gnuplot graphics data files fbk}\par
00246   {\cf20 // Open .dat files}\par
00247   Fl archs_dat_file = open_file(ARCHS_DAT_FILE, {\cf22 "r"});                                                       {\cf20 // Open test-graph gnuplot arch-coords .dat file in read mode}\par
00248   Fl costs_dat_file = open_file(COSTS_DAT_FILE, {\cf22 "r"});                                                       {\cf20 // Open test-graph gnuplot arches cost-coords .dat file in read mode}\par
00249   Fl nodes_dat_file = open_file(NODES_DAT_FILE, {\cf22 "r"});                                                       {\cf20 // Open test-graph gnuplot node-coords .dat file in read mode}\par
00250   Fl shortest_archs_dat_file = open_file(SHORTEST_ARCHS_DAT_FILE, {\cf22 "w"});                                     {\cf20 // Open test-graph shortest path gnuplot arch-coords .dat file in write mode, clearin' file at open}\par
00251   Fl shortest_costs_dat_file = open_file(SHORTEST_COSTS_DAT_FILE, {\cf22 "w"});                                     {\cf20 // Open test-graph shortest path gnuplot arches cost-coords .dat file in write mode, clearin' file at open}\par
00252   Fl shortest_nodes_dat_file = open_file(SHORTEST_NODES_DAT_FILE, {\cf22 "w"});                                     {\cf20 // Open test-graph shortest path gnuplot node-coords .dat file in write mode, clearin' file at open}\par
00253   Fl src_dest_nodes_dat_file = open_file(SRC_DEST_NODES_DAT_FILE, {\cf22 "w"});                                     {\cf20 // Open test-graph gnuplot source and destination node-coords .dat file in write mode, clearin' file at open}\par
00254   {\cf20 // Check .dat files correctly opened}\par
00255   {\cf19 if} (archs_dat_file != NULL && costs_dat_file != NULL && nodes_dat_file != NULL &&\par
00256       shortest_archs_dat_file != NULL && shortest_costs_dat_file != NULL &&\par
00257       shortest_nodes_dat_file != NULL && src_dest_nodes_dat_file != NULL)\{                                  {\cf20 // If gnuplot .dat files has been correctly opened}\par
00258     {\cf20 // Vars init to modify gnuplot .dat files}\par
00259     {\cf18 int} tgt_line_num = 0;                                                                                   {\cf20 // Define target-line number var to find path archs/nodes coordinates in test-graph .dat files}\par
00260     Str tgt_line_str = NULL;                                                                                {\cf20 // Define target-line string var to copy path archs/nodes coordinates from test-graph .dat files to shortest-path and src-dest nodes .dat files}\par
00261     {\cf20 // Archs}\par
00262     {\cf19 for} ({\cf18 int} i = 1; i < min_pth_conn_vect_size; ++i)\{                                                       {\cf20 // Shortest-path archs scrollin' FOR cycle}\par
00263       rewind(archs_dat_file);                                                                               {\cf20 // Start/restart scannin' file from line 0}\par
00264       tgt_line_num = get_substr_line_from_file(archs_dat_file, min_path_conn_vect[i].ar->name);             {\cf20 // Define target line number by shortest-path arch name}\par
00265       {\cf19 if} (tgt_line_num >= 0)\{                                                                               {\cf20 // If arch name has been found in shortest-path archs}\par
00266         {\cf19 for} ({\cf18 int} j = 0; j < 3; ++j, ++tgt_line_num)\{                                                        {\cf20 // Extract target-line and the two following lines FOR cycle}\par
00267           rewind(archs_dat_file);                                                                           {\cf20 // Restart scannin' file from line 0}\par
00268           tgt_line_str = get_line_str_from_file(archs_dat_file, tgt_line_num);                              {\cf20 // Get extracted line content (str)}\par
00269           {\cf19 if} (tgt_line_str != NULL)\{                                                                        {\cf20 // If target string ain't NULL (no errors and string correctly acquired)}\par
00270             write_str_on_file(shortest_archs_dat_file, tgt_line_str);                                       {\cf20 // Write extracted string inside dedicated shortest-path gnuplot .dat file}\par
00271           \} {\cf19 else}                                                                                            {\cf20 // Else in case of target string null}\par
00272             fbk_err({\cf22 "Err1"});                                                                                {\cf20 // Print error fbk}\par
00273         \}\par
00274       \} {\cf19 else}                                                                                                {\cf20 // Else in case of no-match found}\par
00275         fbk_err({\cf22 "Err2"});                                                                                    {\cf20 // Print error fbk}\par
00276     \}\par
00277     {\cf20 // Arch-costs}\par
00278     {\cf19 for} ({\cf18 int} i = 1; i < min_pth_conn_vect_size; ++i)\{                                                       {\cf20 // Shortest-path arch-costs scrollin' FOR cycle}\par
00279       rewind(costs_dat_file);                                                                               {\cf20 // Start/restart scannin' file from line 0}\par
00280       tgt_line_num = get_substr_line_from_file(costs_dat_file, min_path_conn_vect[i].ar->name);             {\cf20 // Define target line number by shortest-path arch name}\par
00281       {\cf19 if} (tgt_line_num >= 0)\{                                                                               {\cf20 // If arch name has been found in shortest-path archs}\par
00282         {\cf19 for} ({\cf18 int} j = 0; j < 2; ++j, ++tgt_line_num)\{                                                        {\cf20 // Extract target-line and the following line FOR cycle}\par
00283           rewind(costs_dat_file);                                                                           {\cf20 // Restart scannin' file from line 0}\par
00284           tgt_line_str = get_line_str_from_file(costs_dat_file, tgt_line_num);                              {\cf20 // Get extracted line content (str)}\par
00285           {\cf19 if} (tgt_line_str != NULL)\{                                                                        {\cf20 // If target string ain't NULL (no errors and string correctly acquired)}\par
00286             write_str_on_file(shortest_costs_dat_file, tgt_line_str);                                       {\cf20 // Write extracted string inside dedicated shortest-path gnuplot .dat file}\par
00287           \} {\cf19 else}                                                                                            {\cf20 // Else in case of target string null}\par
00288             fbk_err({\cf22 "Err1"});                                                                                {\cf20 // Print error fbk}\par
00289         \}\par
00290       \} {\cf19 else}                                                                                                {\cf20 // Else in case of no-match found}\par
00291         fbk_err({\cf22 "Err2"});                                                                                    {\cf20 // Print error fbk}\par
00292     \}\par
00293     {\cf20 // Nodes (source and destination excluded)}\par
00294     {\cf19 for} ({\cf18 int} i = 1; i < min_pth_conn_vect_size-1; ++i)\{                                                     {\cf20 // Shortest-path intermediate-nodes scrollin' FOR cycle}\par
00295       rewind(nodes_dat_file);                                                                               {\cf20 // Start/restart scannin' file from line 0}\par
00296       tgt_line_num = get_substr_line_from_file(nodes_dat_file, min_path_conn_vect[i].nd->name);             {\cf20 // Define target line number by shortest-path node name}\par
00297       {\cf19 if} (tgt_line_num >= 0)\{                                                                               {\cf20 // If node name has been found in shortest-path nodes}\par
00298         {\cf19 for} ({\cf18 int} j = 0; j < 2; ++j, ++tgt_line_num)\{                                                        {\cf20 // Extract target-line and the following line FOR cycle}\par
00299           rewind(nodes_dat_file);                                                                           {\cf20 // Restart scannin' file from line 0}\par
00300           tgt_line_str = get_line_str_from_file(nodes_dat_file, tgt_line_num);                              {\cf20 // Get extracted line content (str)}\par
00301           {\cf19 if} (tgt_line_str != NULL)\{                                                                        {\cf20 // If target string ain't NULL (no errors and string correctly acquired)}\par
00302             write_str_on_file(shortest_nodes_dat_file, tgt_line_str);                                       {\cf20 // Write extracted string inside dedicated shortest-path gnuplot .dat file}\par
00303           \} {\cf19 else}                                                                                            {\cf20 // Else in case of target string null}\par
00304             fbk_err({\cf22 "Err1"});                                                                                {\cf20 // Print error fbk}\par
00305         \}\par
00306       \} {\cf19 else}                                                                                                {\cf20 // Else in case of no-match found}\par
00307         fbk_err({\cf22 "Err2"});                                                                                    {\cf20 // Print error fbk}\par
00308     \}\par
00309     {\cf20 // Source and destination nodes}\par
00310     {\cf19 for} ({\cf18 int} i = 0; i < min_pth_conn_vect_size; i += (min_pth_conn_vect_size-1))\{                           {\cf20 // Shortest-path source and destination nodes scrollin' FOR cycle}\par
00311       rewind(nodes_dat_file);                                                                               {\cf20 // Restart scannin' file from line 0}\par
00312       tgt_line_num = get_substr_line_from_file(nodes_dat_file, min_path_conn_vect[i].nd->name);             {\cf20 // Define target line number by shortest-path node name}\par
00313       {\cf19 if} (tgt_line_num >= 0)\{                                                                               {\cf20 // If node name has been found in shortest-path nodes}\par
00314         {\cf19 for} ({\cf18 int} j = 0; j < 2; ++j, ++tgt_line_num)\{                                                        {\cf20 // Extract target-line and the following line FOR cycle}\par
00315           rewind(nodes_dat_file);                                                                           {\cf20 // Restart scannin' file from line 0}\par
00316           tgt_line_str = get_line_str_from_file(nodes_dat_file, tgt_line_num);                              {\cf20 // Get extracted line content (str)}\par
00317           {\cf19 if} (tgt_line_str != NULL)\{                                                                        {\cf20 // If target string ain't NULL (no errors and string correctly acquired)}\par
00318             write_str_on_file(src_dest_nodes_dat_file, tgt_line_str);                                       {\cf20 // Write extracted string inside dedicated shortest-path gnuplot .dat file}\par
00319           \} {\cf19 else}                                                                                            {\cf20 // Else in case of target string null}\par
00320             fbk_err({\cf22 "Err1"});                                                                                {\cf20 // Print error fbk}\par
00321         \}\par
00322       \} {\cf19 else}                                                                                                {\cf20 // Else in case of no-match found}\par
00323         fbk_err({\cf22 "Err2"});                                                                                    {\cf20 // Print error fbk}\par
00324     \}\par
00325     {\cf20 // Close .dat files}\par
00326     close_file(archs_dat_file);                                                                             {\cf20 // Close test-graph gnuplot arch-coords .dat file}\par
00327     close_file(costs_dat_file);                                                                             {\cf20 // Close test-graph gnuplot arches cost-coords .dat file}\par
00328     close_file(nodes_dat_file);                                                                             {\cf20 // Close test-graph gnuplot node-coords .dat file}\par
00329     close_file(shortest_archs_dat_file);                                                                    {\cf20 // Close test-graph shortest path gnuplot arch-coords .dat file}\par
00330     close_file(shortest_costs_dat_file);                                                                    {\cf20 // Close test-graph shortest path gnuplot arches cost-coords .dat file}\par
00331     close_file(shortest_nodes_dat_file);                                                                    {\cf20 // Close test-graph shortest path gnuplot node-coords .dat file}\par
00332     close_file(src_dest_nodes_dat_file);                                                                    {\cf20 // Close test-graph gnuplot source and destination node-coords .dat file}\par
00333     fbk_nl(1);  fbk_gn_cy({\cf22 "Shortest-path graphics data managenent for gnuplot completed!\\n"});               {\cf20 // Print Shortest-path graphics data managenent completed fbk}\par
00334   \} {\cf19 else}                                                                                                    {\cf20 // Else if gnuplot .dat files ain't been correctly opened}\par
00335     fbk_err({\cf22 "Ops! Something went wrong during shortest-path graphics data managenent for gnuplot"});         {\cf20 // Print err fbk}\par
00336 \}\par
}
}
{\xe \v create_archs\:graph_test.c}
{\xe \v graph_test.c\:create_archs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void create_archs (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Static routine to create test-graph arches, working on graph-library public variables. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 132 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00132                           \{                                                                                 {\cf20 // Routine to create archs}\par
00133   {\cf20 /* Body */}\par
00134   {\cf19 for} ({\cf18 int} i = 0; i < (int)({\cf17 sizeof}(strts_vect)/{\cf17 sizeof}({\cf17 const} Street)); ++i)                                  {\cf20 // Streets allocation FOR cycle}\par
00135     add_new_arch((C_str)strts_vect[i].name, strts_vect[i].length);                                          {\cf20 // Create new street (arch allocated inside heap)}\par
00136 \}\par
}
}
{\xe \v create_connections\:graph_test.c}
{\xe \v graph_test.c\:create_connections}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void create_connections (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Static routine to create test-graph arch-nodes connections, working on graph-library public variables. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 156 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00156                                 \{                                                                           {\cf20 // Routine to create connections btwn archs & nodes}\par
00157   {\cf20 /* Body */}\par
00158   connect_node_arch((C_str)strts_vect[0].name, crss_names_vect[0], ARCH_ND1, LIST_TAIL);                    {\cf20 // Connect "Street1" to "Cross1"}\par
00159   connect_node_arch((C_str)strts_vect[0].name, crss_names_vect[1], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street1" to "Cross2"}\par
00160   connect_node_arch((C_str)strts_vect[1].name, crss_names_vect[0], ARCH_ND1, LIST_TAIL);                    {\cf20 // Connect "Street2" to "Cross1"}\par
00161   connect_node_arch((C_str)strts_vect[1].name, crss_names_vect[2], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street2" to "Cross3"}\par
00162   connect_node_arch((C_str)strts_vect[2].name, crss_names_vect[0], ARCH_ND1, LIST_HEAD);                    {\cf20 // Connect "Street3" to "Cross1", add at list head position instead of list tail pos}\par
00163   connect_node_arch((C_str)strts_vect[2].name, crss_names_vect[3], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street3" to "Cross4"}\par
00164   connect_node_arch((C_str)strts_vect[3].name, crss_names_vect[0], ARCH_ND1, LIST_POS, 2);                  {\cf20 // Connect "Street4" to "Cross1", opt param --> add arch at specific pos in archs list, non-zero index}\par
00165   connect_node_arch((C_str)strts_vect[3].name, crss_names_vect[4], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street4" to "Cross5"}\par
00166   connect_node_arch((C_str)strts_vect[4].name, crss_names_vect[4], ARCH_ND1, LIST_TAIL);                    {\cf20 // Connect "Street5" to "Cross5"}\par
00167   connect_node_arch((C_str)strts_vect[4].name, crss_names_vect[5], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street5" to "Cross6"}\par
00168   connect_node_arch((C_str)strts_vect[5].name, crss_names_vect[5], ARCH_ND1, LIST_TAIL);                    {\cf20 // Connect "Street6" to "Cross6"}\par
00169   connect_node_arch((C_str)strts_vect[5].name, crss_names_vect[6], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street6" to "Cross7"}\par
00170   connect_node_arch((C_str)strts_vect[6].name, crss_names_vect[5], ARCH_ND1, LIST_TAIL);                    {\cf20 // Connect "Street7" to "Cross6"}\par
00171   connect_node_arch((C_str)strts_vect[6].name, crss_names_vect[7], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street7" to "Cross8"}\par
00172   connect_node_arch((C_str)strts_vect[7].name, crss_names_vect[7], ARCH_ND1, LIST_TAIL);                    {\cf20 // Connect "Street8" to "Cross8"}\par
00173   connect_node_arch((C_str)strts_vect[7].name, crss_names_vect[8], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street8" to "Cross9"}\par
00174   connect_node_arch((C_str)strts_vect[8].name, crss_names_vect[0], ARCH_ND1, LIST_TAIL);                    {\cf20 // Connect "Street9" to "Cross1"}\par
00175   connect_node_arch((C_str)strts_vect[8].name, crss_names_vect[6], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street9" to "Cross7"}\par
00176   connect_node_arch((C_str)strts_vect[9].name, crss_names_vect[0], ARCH_ND1, LIST_TAIL);                    {\cf20 // Connect "Street10" to "Cross1"}\par
00177   connect_node_arch((C_str)strts_vect[9].name, crss_names_vect[5], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street10" to "Cross6"}\par
00178   connect_node_arch((C_str)strts_vect[10].name, crss_names_vect[3], ARCH_ND1, LIST_TAIL);                   {\cf20 // Connect "Street11" to "Cross4"}\par
00179   connect_node_arch((C_str)strts_vect[10].name, crss_names_vect[4], ARCH_ND2, LIST_TAIL);                   {\cf20 // Connect "Street11" to "Cross5"}\par
00180   connect_node_arch((C_str)strts_vect[11].name, crss_names_vect[4], ARCH_ND1, LIST_TAIL);                   {\cf20 // Connect "Street12" to "Cross5"}\par
00181   connect_node_arch((C_str)strts_vect[11].name, crss_names_vect[7], ARCH_ND2, LIST_TAIL);                   {\cf20 // Connect "Street12" to "Cross8"}\par
00182   connect_node_arch((C_str)strts_vect[12].name, crss_names_vect[4], ARCH_ND1, LIST_TAIL);                   {\cf20 // Connect "Street13" to "Cross5"}\par
00183   connect_node_arch((C_str)strts_vect[12].name, crss_names_vect[8], ARCH_ND2, LIST_TAIL);                   {\cf20 // Connect "Street13" to "Cross9"}\par
00184 \}\par
}
}
{\xe \v create_nodes\:graph_test.c}
{\xe \v graph_test.c\:create_nodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void create_nodes (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Static routine to create test-graph nodes, working on graph-library public variables. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 144 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00144                           \{                                                                                 {\cf20 // Routine to create nodes}\par
00145   {\cf20 /* Body */}\par
00146   {\cf19 for} ({\cf18 int} j = 0; j < (int)({\cf17 sizeof}(crss_names_vect)/{\cf17 sizeof}(C_str)); ++j)                                    {\cf20 // Crosses allocation FOR cycle}\par
00147     add_new_node(crss_names_vect[j]);                                                                       {\cf20 // Create new cross (node allocated inside heap)}\par
00148 \}\par
}
}
{\xe \v define_dest_node_name\:graph_test.c}
{\xe \v graph_test.c\:define_dest_node_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void define_dest_node_name ({\b Str} *  {\i dest_nd_nm}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 376 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00376                                                   \{                                                         {\cf20 // Routine to define presonalized destination-node name}\par
00377   {\cf20 /* Body */}\par
00378   {\cf19 for} ({\cf18 int} i = 0; i < nds_collect_size; ++i)\{                                                               {\cf20 // Nodes collection vect scrollin' FOR cycle}\par
00379     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Node name"}, nodes_collect_vect[i].name);                                 {\cf20 // Print node name fbk}\par
00380   \}\par
00381   {\cf19 do} \{                                                                                                      {\cf20 // Cycle to define personalized destination-node name}\par
00382     *dest_nd_nm = read_term_in_min_chrs(1, {\cf22 "Choose a destination node (by name)"}, {\cf22 "Destination node name"}); {\cf20 // Read user input str}\par
00383   \} {\cf19 while}(idx_by_name(ND, *dest_nd_nm) < 0);                                                                {\cf20 // Check whether node-name specified by the user exists in nodes collection vect, otherwise repeat question}\par
00384 \}\par
}
}
{\xe \v define_src_node_name\:graph_test.c}
{\xe \v graph_test.c\:define_src_node_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void define_src_node_name ({\b Str} *  {\i src_nd_nm}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 365 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00365                                                 \{                                                           {\cf20 // Routine to define presonalized source-node name}\par
00366   {\cf20 /* Body */}\par
00367   {\cf19 for} ({\cf18 int} i = 0; i < nds_collect_size; ++i)\{                                                               {\cf20 // Nodes collection vect scrollin' FOR cycle}\par
00368     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Node name"}, nodes_collect_vect[i].name);                                 {\cf20 // Print node name fbk}\par
00369   \}\par
00370   {\cf19 do} \{                                                                                                      {\cf20 // Cycle to define personalized source-node name}\par
00371     *src_nd_nm = read_term_in_min_chrs(1, {\cf22 "Choose a source node (by name)"}, {\cf22 "Source node name"});            {\cf20 // Read user input str}\par
00372   \} {\cf19 while}(idx_by_name(ND, *src_nd_nm) < 0);                                                                 {\cf20 // Check whether node-name specified by the user exists in nodes collection vect, otherwise repeat question}\par
00373 \}\par
}
}
{\xe \v display_test_graph\:graph_test.c}
{\xe \v graph_test.c\:display_test_graph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void display_test_graph ({\b C_str}  {\i cmd}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 339 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00339                                          \{                                                                  {\cf20 // Routine to display test-graph through gnuplot}\par
00340   {\cf20 /* Body */}\par
00341   fbk_gn_pu({\cf22 "Close gnuplot to continue graph-library test..."}); fbk_nl(1);                                  {\cf20 // Print close gnuplot to continue fbk}\par
00342   {\cf19 if} (strcmp(cmd, GPLOT_SHORTEST_PATH_CMD) == 0)                                                            {\cf20 // If display command request min path}\par
00343     build_shortest_path_graphics_data();                                                                    {\cf20 // Routine call to build the shortest-path graphics data for gnuplot}\par
00344   fflush(stdout);                                                                                           {\cf20 // Force fbk print b4 openin' gnuplot}\par
00345   {\cf18 int} ret_val = system(cmd);                                                                                {\cf20 // Display test-graph layout with gnuplot}\par
00346   {\cf19 if} (ret_val == 0)\{                                                                                        {\cf20 // Chack command return val, if ok}\par
00347     fbk_nl(1);  fbk_gn_cy({\cf22 "Test-graph layout correctly displayed with gnuplot!\\n"});                         {\cf20 // Test-graph layout correctly displayed with gnuplot fbk}\par
00348   \} {\cf19 else}                                                                                                    {\cf20 // Else if command return val ain't ok}\par
00349     fbk_err({\cf22 "Ops! Encountred error during gnuplot command execution, make sure to have gnuplot installed"}); {\cf20 // Error fbk}\par
00350 \}\par
}
}
{\xe \v main\:graph_test.c}
{\xe \v graph_test.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 388 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00388           \{                                                                                                 {\cf20 // Main SW cycle}\par
00389   {\cf20 /* Main vars */}\par
00390   Test_choice choice = 0;                                                                                   {\cf20 // Test choice var}\par
00391 \par
00392   {\cf20 /* Code */}\par
00393   signal(SIGINT, terminate_keyboard);                                                                       {\cf20 // Manage program exit from keyboard ctrl+c shortcut}\par
00394   logo(6, {\cf22 "GRAPHS MANAGEMENT LIBRARY TEST SOFTWARE"}, LBU, {\cf23 '#'}, OG);                                         {\cf20 // Print responsive-logo function call (start_spaces, text, txt_color, background_char, bkgchr_color)}\par
00395   press_enter({\cf22 "Hi"});                                                                                        {\cf20 // Press enter to start SW fbk}\par
00396 \par
00398   {\cf20 //                                          LIBRARY TEST SOFTWATRE                                        // --> TEST BEGIN}\par
00400 {\cf20 }  {\cf20 // (1.1) Create some archs                                                                                // --------------------------------------------------------- (1.1)}\par
00401   fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                                   {\cf20 // Print separator fbk}\par
00402   fbk_nl(1);  fbk_gn_pu({\cf22 "(1.1) Creatin' some archs..."});                                                    {\cf20 // Print creatin' archs fbk}\par
00403   fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                        {\cf20 // Print separator fbk}\par
00404   create_archs();                                                                                           {\cf20 // Routine call to create archs}\par
00405   {\cf20 // (1.2) Create some nodes                                                                                // --------------------------------------------------------- (1.2)}\par
00406   fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                                   {\cf20 // Print separator fbk}\par
00407   fbk_nl(1);  fbk_gn_pu({\cf22 "(1.2) Creatin' some nodes..."});                                                    {\cf20 // Print creatin' nodes fbk}\par
00408   fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                        {\cf20 // Print separator fbk}\par
00409   create_nodes();                                                                                           {\cf20 // Routine call to create nodes}\par
00410   {\cf20 // (2.1) Connect archs & nodes (excluding node "Cross10")                                                 // --------------------------------------------------------- (2.1)}\par
00411   fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                                   {\cf20 // Print separator fbk}\par
00412   fbk_nl(1);  fbk_gn_pu({\cf22 "(2.1) Connectin' archs & nodes..."});                                               {\cf20 // Print connectin' archs and nodes fbk}\par
00413   fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                        {\cf20 // Print separator fbk}\par
00414   create_connections();                                                                                     {\cf20 // Routine call to create connections btwn archs & nodes}\par
00415   {\cf20 // (2.2) Test mode choice                                                                                 // --------------------------------------------------------- (2.2)}\par
00416   fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                                   {\cf20 // Print separator fbk}\par
00417   fbk_nl(1);  fbk_gn_pu({\cf22 "(2.2) Testin' mode choice..."});                                                    {\cf20 // Print testin' mode choice fbk}\par
00418   fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                        {\cf20 // Print separator fbk}\par
00419   test_option_choice(&choice);                                                                              {\cf20 // Routine call to choose testing option}\par
00420   {\cf20 // (2.3) Display test-graph layout with gnuplot                                                           // --------------------------------------------------------- (2.3)}\par
00421   fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                                   {\cf20 // Print separator fbk}\par
00422   fbk_nl(1);  fbk_gn_pu({\cf22 "(2.3) Displayin' test-graph layout with gnuplot..."});                              {\cf20 // Print displayin' test-graph layout with gnuplot fbk}\par
00423   fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                        {\cf20 // Print separator fbk}\par
00424   display_test_graph(GPLOT_TEST_GRAPH_LAYOUT_CMD);                                                          {\cf20 // Routine call to display test-graph through gnuplot}\par
00425   {\cf20 // (3.1) Apply Dijkstra's algorithm and find min parh                                                     //}\par
00426   {\cf19 switch} (choice)\{                                                                                          {\cf20 // Testin' option switch-case}\par
00427     {\cf19 case} PREPARED:                                                                                          {\cf20 // Option [1] -> Prepared test (requires gnuplot)}\par
00428       {\cf20 // (3.1.1) Apply Dijkstra's algorithm (from Cross4)                                                   // --------------------------------------------------------- (3.1.1)}\par
00429       fbk_nl(2);  fbk_separator(SEP_CHR, OG); fbk_nl(1);                                                    {\cf20 // Print separator fbk}\par
00430       fbk_gn_pu({\cf22 "(3.1.1) Applyin' Dijkstra's algorithm to find min paths from \\"Cross4\\" source node..."});  {\cf20 // Print applyin' Dijkstra's algorithm to find min paths fbk}\par
00431       fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                    {\cf20 // Print separator fbk}\par
00432       apply_dijkstra(SOURCE_NODE_NAME);                                                                     {\cf20 // Routine call to apply Dijkstra's algorithm}\par
00433       {\cf20 // (3.2.1) Reconstruct test min path (from Cross4 to Cross9)                                          // --------------------------------------------------------- (3.2.1)}\par
00434       fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                               {\cf20 // Print separator fbk}\par
00435       fbk_nl(1);  fbk_gn_pu({\cf22 "(3.2.1) Reconstructin' test min path (Cross4-Cross9) with delays..."});         {\cf20 // Print reconstructin' test min path fbk}\par
00436       fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                    {\cf20 // Print separator fbk}\par
00437       reconstruct_min_path(DESTINATION_NODE_NAME);                                                          {\cf20 // Routine call to reconstruct min path}\par
00438       {\cf20 // (3.3.1) Display test-graph layout and shortest path with gnuplot (from Cr4 to Cr9)                 // --------------------------------------------------------- (3.3.1)}\par
00439       {\cf19 if} (min_pth_conn_vect_size > 1)\{                                                                      {\cf20 // If min path contains at least src and dest nodes}\par
00440         fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                             {\cf20 // Print separator fbk}\par
00441         fbk_nl(1);  fbk_gn_pu({\cf22 "(3.3.1) Displayin' test-graph and shortest path with gnuplot (Cr4-Cr9)..."}); {\cf20 // Print displayin' test-graph layout and shortest path with gnuplot fbk}\par
00442         fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                  {\cf20 // Print separator fbk}\par
00443         display_test_graph(GPLOT_SHORTEST_PATH_CMD);                                                        {\cf20 // Routine call to display test-graph through gnuplot}\par
00444       \}                                                                                                     {\cf20 //}\par
00445       {\cf20 // (3.4.1) Reconstruct some special-cases paths (Cr4-Cr4 and Cr4-Cr10)                                // --------------------------------------------------------- (3.4.1)}\par
00446       fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                               {\cf20 // Print separator fbk}\par
00447       fbk_nl(1);  fbk_gn_pu({\cf22 "(3.4.1) Reconstructin' some special-cases paths (Cr4-Cr4 and Cr4-Cr10)..."});   {\cf20 // Print reconstructin' some special-cases paths fbk}\par
00448       fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                    {\cf20 // Print separator fbk}\par
00449       reconstruct_min_path(DEST_NODE_NAME_SPECIAL_CASE1);                                                   {\cf20 // Routine call to reconstruct min path}\par
00450       reconstruct_min_path(DEST_NODE_NAME_SPECIAL_CASE2);                                                   {\cf20 // Routine call to reconstruct min path}\par
00451       {\cf19 break};                                                                                                {\cf20 //}\par
00453 {\cf20 }    {\cf19 case} PERSONALIZED:                                                                                      {\cf20 // Option [2] -> Personalized test (requires gnuplot)}\par
00454       {\cf20 // (3.1.2) Apply Dijkstra's algorithm                                                                 // --------------------------------------------------------- (3.1.2)}\par
00455       fbk_nl(2);  fbk_separator(SEP_CHR, OG); fbk_nl(1);                                                    {\cf20 // Print separator fbk}\par
00456       fbk_gn_pu({\cf22 "(3.1.2) Applyin' Dijkstra's algorithm to find min paths from specified source node..."});   {\cf20 // Print applyin' Dijkstra's algorithm to find min paths fbk}\par
00457       fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                    {\cf20 // Print separator fbk}\par
00458       {\cf18 char}* src_nd_nm = NULL;                                                                               {\cf20 // Personalized source-node name str init}\par
00459       define_src_node_name(&src_nd_nm);                                                                     {\cf20 // Routine call to define presonalized source-node name}\par
00460       apply_dijkstra(src_nd_nm);                                                                            {\cf20 // Routine call to apply Dijkstra's algorithm}\par
00461       {\cf20 // (3.2.2) Reconstruct test min path                                                                  // --------------------------------------------------------- (3.2.2)}\par
00462       fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                               {\cf20 // Print separator fbk}\par
00463       fbk_nl(1);  fbk_gn_pu({\cf22 "(3.2.2) Reconstructin' requested min path with delays..."});                    {\cf20 // Print reconstructin' requested min path fbk}\par
00464       fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                    {\cf20 // Print separator fbk}\par
00465       {\cf18 char}* dest_nd_nm = NULL;                                                                              {\cf20 // Personalized destination-node name str init}\par
00466       define_dest_node_name(&dest_nd_nm);                                                                   {\cf20 // Routine call to define presonalized destination-node name}\par
00467       reconstruct_min_path(dest_nd_nm);                                                                     {\cf20 // Routine call to reconstruct min path}\par
00468       {\cf20 // (3.3.2) Display test-graph layout and shortest path with gnuplot                                   // --------------------------------------------------------- (3.3.2)}\par
00469       {\cf19 if} (min_pth_conn_vect_size > 1)\{                                                                      {\cf20 // If min path contains at least src and dest nodes}\par
00470         fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                             {\cf20 // Print separator fbk}\par
00471         fbk_nl(1);  fbk_gn_pu({\cf22 "(3.3.2) Displayin' test-graph and shortest path with gnuplot..."});           {\cf20 // Print displayin' test-graph layout and shortest path with gnuplot fbk}\par
00472         fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                  {\cf20 // Print separator fbk}\par
00473         display_test_graph(GPLOT_SHORTEST_PATH_CMD);                                                        {\cf20 // Routine call to display test-graph through gnuplot}\par
00474       \}                                                                                                     {\cf20 //}\par
00475       {\cf19 break};                                                                                                {\cf20 //}\par
00477 {\cf20 }    {\cf19 default}:                                                                                                {\cf20 // Unknown option (avoid compile errors)}\par
00478       {\cf19 break};                                                                                                {\cf20 //}\par
00479   \}                                                                                                         {\cf20 //}\par
00480   {\cf20 // (4.1) Deallocate the whole graph structure                                                             // --------------------------------------------------------- (4.1)}\par
00481   fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                                   {\cf20 // Print separator fbk}\par
00482   fbk_nl(1);  fbk_gn_pu({\cf22 "(4.1) Deallocatin' the whole graph structure..."});                                 {\cf20 // Print clearin' the whole graph structre fbk}\par
00483   fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                        {\cf20 // Print separator fbk}\par
00484   free_graph();                                                                                             {\cf20 // Clear graph structure from heap and reset some flags to be able to use again lib functions}\par
00486 {\cf20 }  {\cf20 //                                          LIBRARY TEST SOFTWATRE                                        // --> TEST END}\par
00488 {\cf20 }\par
00489   close_fbk();                                                                                              {\cf20 // Close SW with fbk}\par
00490   {\cf19 return} EXIT_SUCCESS;                                                                                      {\cf20 // Check errors --> if=0 (NO ERRORS) / if=1 (ERRORS)}\par
00491 \}\par
}
}
{\xe \v reconstruct_min_path\:graph_test.c}
{\xe \v graph_test.c\:reconstruct_min_path}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void reconstruct_min_path ({\b C_str}  {\i dest_nd_name}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 359 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00359                                                     \{                                                       {\cf20 // Routine to reconstruct min path}\par
00360   {\cf20 /* Body */}\par
00361   buid_shortest_path(dest_nd_name, VERBOSE);                                                                {\cf20 // Reconstruct min path to defined destination node startin' from pre-defined source node, (min path connections vect allocated/reallocated inside heap) - Y/N for verbose mode}\par
00362 \}\par
}
}
{\xe \v terminate_keyboard\:graph_test.c}
{\xe \v graph_test.c\:terminate_keyboard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void terminate_keyboard (int  {\i signal}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Static routine to manage close keyboard interrupt signal printing feedback to terminal. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i signal} \cell }{Keyboard interrupt signal\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 121 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00121                                           \{                                                                 {\cf20 // Manage program exit from keyboard ctrl+c shortcut}\par
00122   {\cf20 /* Body */}\par
00123   close_keyboard_interrupt(signal);                                                                         {\cf20 // Close SW with fbk due to keyboard interrupt detected (ctrl+c)}\par
00124 \}\par
}
}
{\xe \v test_option_choice\:graph_test.c}
{\xe \v graph_test.c\:test_option_choice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void test_option_choice ({\b Test_choice} *const  {\i choice}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Static routine to give give user the possibility to choose testing option: }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Prepared test\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Personalized test\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Close test software\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i signal} \cell }{Keyboard interrupt signal\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 197 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00197                                                          \{                                                  {\cf20 // Routine to choose testing option}\par
00198   {\cf20 /* Body */}\par
00199   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "[1]"}, {\cf22 "Prepared test (requires gnuplot)"});                                 {\cf20 // Print opt 1 fbk}\par
00200   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "[2]"}, {\cf22 "Personalized test (requires gnuplot)"});                             {\cf20 // Print opt 2 fbk}\par
00201   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "[3]"}, {\cf22 "Exit"}); fbk_nl(1);                                                  {\cf20 // Print opt 3 fbk}\par
00202   *choice = (Byte)read_term_in_int_inrange(1, 3, {\cf22 "Choose a testing option"}, {\cf22 "Error! Option"});               {\cf20 // Print opt choice fbk}\par
00203   {\cf19 switch} (*choice)\{                                                                                         {\cf20 // Testin' option switch-case}\par
00204     {\cf19 case} PREPARED:                                                                                          {\cf20 // Option [1] -> Prepared test (requires gnuplot)}\par
00205       fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Choosen option"}, {\cf22 "[1] -> Prepared test (requires gnuplot)"});           {\cf20 // Print choosen opt fbk}\par
00206       {\cf19 break};\par
00208     {\cf19 case} PERSONALIZED:                                                                                      {\cf20 // Option [2] -> Personalized test (requires gnuplot)}\par
00209       fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Choosen option"}, {\cf22 "[2] -> Personalized test (requires gnuplot)"});       {\cf20 // Print choosen opt fbk}\par
00210       {\cf19 break};\par
00212     {\cf19 case} EXIT:                                                                                              {\cf20 // Option [3] -> Exit}\par
00213       fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Choosen option"}, {\cf22 "[3] -> Exit"}); fbk_nl(1);                            {\cf20 // Print choosen opt fbk}\par
00214       Confirm answ = read_term_in_confirm({\cf22 "Are you sure you want to close test software"});                  {\cf20 // Ask confirm}\par
00215       {\cf19 switch} (answ)\{                                                                                        {\cf20 // Confirm answ switch-case}\par
00216         {\cf19 case} YES:                                                                                           {\cf20 // YES answer}\par
00217           close_fbk();                                                                                      {\cf20 // Close SW with fbk}\par
00218           {\cf19 break};\par
00220         {\cf19 case} NO:                                                                                            {\cf20 // NO answer}\par
00221           test_option_choice(choice);                                                                       {\cf20 // Go back}\par
00222           {\cf19 break};\par
00224         {\cf19 case} CANCEL:                                                                                        {\cf20 // CANCEL answer}\par
00225           test_option_choice(choice);                                                                       {\cf20 // Go back}\par
00226           {\cf19 break};\par
00228         {\cf19 default}:                                                                                            {\cf20 // Unknown answer}\par
00229           fbk_err({\cf22 "Error, bad confirmation answer"});                                                        {\cf20 // Print error fbk}\par
00230           perror({\cf22 "Bad confirmation answer, 'read_term_in_confirm()' requires 'Confirm' data-type!"});        {\cf20 // Print perror fbk}\par
00231           close_err();                                                                                      {\cf20 // Close with error fbk}\par
00232       \}\par
00233       {\cf19 break};\par
00235     {\cf19 default}:                                                                                                {\cf20 // Unknown option}\par
00236       fbk_err({\cf22 "Error, bad testing option value"});                                                           {\cf20 // Print error fbk}\par
00237       perror({\cf22 "Testing option value out of range, check 'read_term_in_int_inrange()' parameter-values!"});    {\cf20 // Print perror fbk}\par
00238       close_err();                                                                                          {\cf20 // Close with error fbk}\par
00239   \}\par
00240 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v crss_names_vect\:graph_test.c}
{\xe \v graph_test.c\:crss_names_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b C_str} crss_names_vect[]}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =   \{{\cf22 "Cross1"}, {\cf22 "Cross2"}, {\cf22 "Cross3"}, {\cf22 "Cross4"}, {\cf22 "Cross5"}, {\cf22 "Cross6"}, {\cf22 "Cross7"},\par
                              {\cf22 "Cross8"}, {\cf22 "Cross9"}, {\cf22 "Cross10"}\}\par
}
{
Definition at line 109 of file graph_test.c.}\par
}
{\xe \v strts_vect\:graph_test.c}
{\xe \v graph_test.c\:strts_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Street} strts_vect[]}}
\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\{{\cf22 "Street1"},1.1\}, \{{\cf22 "Street2"},2.2\}, \{{\cf22 "Street3"},3.3\}, \{{\cf22 "Street4"},4.4\}, \par
                              \{{\cf22 "Street5"},5.5\}, \{{\cf22 "Street6"},6.6\}, \{{\cf22 "Street7"},7.7\}, \{{\cf22 "Street8"},8.8\},\par
                              \{{\cf22 "Street9"},6.3\}, \{{\cf22 "Street10"},0.2\}, \{{\cf22 "Street11"},9.3\}, \{{\cf22 "Street12"},7.1\},\par
                              \{{\cf22 "Street13"},12.8\}\}\par
}
{
Definition at line 104 of file graph_test.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
main/graph_test.o File Reference\par \pard\plain 
{\tc\tcl2 \v main/graph_test.o}
{\xe \v main/graph_test.o}
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
makefile File Reference\par \pard\plain 
{\tc\tcl2 \v makefile}
{\xe \v makefile}
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}