{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment Dijkstra's algorithm project  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
3.0 \par
}}Dijkstra's algorithm project}
{\comment Generated by doxygen.}
{\creatim \yr2021\mo7\dy20\hr13\min47\sec28}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt Dijkstra's algorithm project}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 3.0\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Tue Jul 20 2021 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Main Page\par \pard\plain 
{\tc \v Main Page}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 {\b Graphs and Dijkstra's algorithm C code with gnuplot graphics} } \par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 {\b Main project contents:} } \par}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 {\b Main makefile commands}  ({\i for more detailed info, see {\b 'Makefile'}  section inside doxygen {\b 'Related pages'} } )} \par}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Compile commands:} {
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b make:}  command to compile and link the whole project to executable (shortcut command).\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b make all:}  same command as above, extended command.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b make run:}  command to launch executable.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b make all_run:}  command to compile/link the whole project to executable and run it.\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Doxygen commands:} {
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b make docs:}  command to open firefox in order to display doxygen html documentation.\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Abstract commands:} {
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b make abstract:}  command to open and view LaTeX exported pdf file.\par}
}
\par{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 {\b Doxygen html documentation}  - {\i to open doxygen html documentation, see {\b 'make docs'}  makefile command (firefox required)} } \par}
Html documentation of the software containing: files, functions, enums, data-types descriptions and so on.\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 {\b Abstract}  - {\i to open pdf abstract, see {\b 'make abstract'}  makefile command (a pdf viewer is required)} } \par}
Introduction and brief description of the software, particularly about Dijkstra's algorithm theoretical aspects and implementation.\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 {\b Main}  ({\i for more detailed info, see {\b 'Testing software'}  section inside doxygen {\b 'Related pages'} } )} \par}
{\b Graph test:}  main test software to create a small graph allocated inside heap and test Dijkstra's algorithm, to find minimum cost path. More in details, test main program allows to run two different typed of test on graph-library and Dijkstra's algorithm ({\b dijkstra_alg()} function inside {\b lib_graph.c}):{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Predefined test:}  test from a pre-defined source node towards a pre-defined destination node (designated by {\b SOURCE_NODE_NAME} and {\b DESTINATION_NODE_NAME} macros).\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Personalized test:}  test from a user-defined source node towards a user-defined destination node (designated by user terminal-inputs during test execution).\par}
\par{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 {\b Libraries} } \par}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Graph:}  library for low-level graphs data management and for finding minimum cost path with Dijkstra's algorithm ({\i for more detailed info, see {\b 'Graph library'}  section inside doxygen {\b 'Related pages'} }  - files {\b lib_graph.h} and {\b lib_graph.c}).\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UI:}  User-interface (terminal I/O) library to safetly manage terminal-inputs, print logo and coloured terminal-output feedbacks ({\i for more detailed info, see {\b 'UI library'}  section inside doxygen {\b 'Related pages'} }  - files {\b lib_ui.h} and {\b lib_ui.c}).\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Files:}  library to manage files through open/close and read/write operations. ({\i for more detailed info, see {\b 'Files library'}  section inside doxygen {\b 'Related pages'} }  - files {\b lib_files.h} and {\b lib_files.c}).\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Timer:}  library to manage time operations like delays ({\i for more detailed info, see {\b 'Timer library'}  section inside doxygen {\b 'Related pages'} }  - files {\b lib_timer.h} and {\b lib_timer.c}).\par}
\par{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 {\b Gnuplot}  ({\i for more detailed info, see {\b 'Gnuplot'}  section inside doxygen {\b 'Related pages'} } )} \par}
In this software, gnuplot has the main purpose of plotting graph and shortest-path data. In order to that, inside main program ({\b graph_test.c}), two gnuplot scripts will be called to load and plot manipulated data inside .dat files. The former is called immediately after the testing option choice, while the latter is called once shortest-path has been displayed and descried on terminal.\par
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Graph plotting script:}  this file ({\b graph_plot.cmd}) is called from main testing software through a system command, with the aim of graphically showing the allocated graph structure to the user. Gnuplot's script, will then print data manually inserted by the user inside graph-plotting data files: {\b archs.dat}, {\b costs.dat} and {\b nodes.dat}.\par}
\par{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Shortest path plotting script:}  this other file ({\b shortest_plot.cmd}), is also called from main testing software through a system command, with the aim of graphically showing the allocated graph structure and detected min-cost path to the user. Gnuplot's script will then print data manually inserted by the user, inside graph-plotting data files: {\b archs.dat}, {\b costs.dat} and {\b nodes.dat} (light-gray colored). In addition, print data manipulated by test software (data from {\b shortest_archs.dat}, {\b shortest_costs.dat}, {\b shortest_nodes.dat} and {\b src_dest_nodes.dat} files), using colors to highlight shortest path from specified source node to specified destination node.\par}
\par{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 {\b Project folders structure:} } \par}
\~.\par
 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b README.md}\par
 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 doc\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 abstract\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 relazione-finale-CRISTIAN-MERLI.aux\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 relazione-finale-CRISTIAN-MERLI.fdb_latexmk\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 relazione-finale-CRISTIAN-MERLI.fls\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 relazione-finale-CRISTIAN-MERLI.log\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b relazione-finale-CRISTIAN-MERLI.pdf} \par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 relazione-finale-CRISTIAN-MERLI.synctex.gz\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 relazione-finale-CRISTIAN-MERLI.tex\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 abstract.tex\par
 \'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 doxygen\par
 \'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 doxygen_config\par
 \'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 exports\par
 \'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b html} \par
 \'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 rtf\par
 \'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 src\par
 \'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 logo.png\par
 \'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 sw\par
 \~\~\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 gnuplot\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b archs.dat}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b costs.dat}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 exports\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 imgs\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 pdf\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b graph_plot.cmd}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b nodes.dat}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b shortest_archs.dat}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b shortest_costs.dat}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b shortest_nodes.dat}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b shortest_plot.cmd}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 {\b src_dest_nodes.dat}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 lib\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 files\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b lib_files.c}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b lib_files.h}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 {\b lib_files.so}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 graph\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b lib_graph.c}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b lib_graph.h}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 {\b lib_graph.so}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 timer\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b lib_timer.c}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b lib_timer.h}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 {\b lib_timer.so}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 ui\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b lib_ui.c}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b lib_ui.h}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\~\~\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 {\b lib_ui.so}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 main\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b graph_test.c}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'82\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 {\b graph_test.o}\par
 \~\~\~\~\~\~\~\~\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 {\b graph_test} \par
 \~\~\~\~\~\~\~\~\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 {\b makefile} \par
{\i 18 directories, 35 files}  \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
1 - General notes about software{\tc \v 1 - General notes about software}\par \pard\plain 
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
General notes, informations and warnings about the software.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Cristian Merli \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
16/07/2021 \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
3.0 - Completed 16/05/2021\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Important notes:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Graphical effects are managed by gnuplot (based on data manipulated by test software main program), so it is highly recommended to have it installed.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
It is possibile to compile, run and execute further actions tacking advantege of makefile, {\i for more informations see doxygen {\b 'Main page'}  or {\b 'Makefile'}  section inside {\b 'Related pages'} .}  \par}
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Important warnings:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Pay attention, arch/node names must only be max 30 chars long. To modify max names lenght, change relative macros inside '{\b lib_graph.h}' header file: {\b AR_STR_LEN} and {\b ND_STR_LEN}.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
User-interface library is now set to have an input buffer able to take max 63 chars strings + '\\0'; to modify terminal-input buffer size see {\b IN_BUFF_SIZE} macro.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Similarly, files-library is now set to have an input buffer able to take max 1023 chars strings + '\\0' (for each file line); to modify file-input buffer size see {\b FILE_IN_BUFF_SIZE} macro.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If there is need to modify graph-structe, gnuplot {\b archs.dat}, {\b costs.dat} and {\b costs.dat} files needs to be manually updated to have reliable graphical representations. \par}
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Bug:\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid No known bugs.\par
}
\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Code title:
\par}
{\tc\tcl2 \v Code title:}
Dijkstra's algorithm (contained in graph-library) test software. \par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Code details:
\par}
{\tc\tcl3 \v Code details:}
Software to test Dijkstra's algorithm function placed inside graph-library. This function has the purpose of finding the shortest path between source and destination nodes. Through this software, it is possible to run two different types of test ({\i for more info, see {\b 'Testing software'}  section inside doxygen {\b 'Related pages'} } ):{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Prepared test.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Personalized test. \par}
\par\par}
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Manual compiling operations (alternative to makefile):
\par}
{\tc\tcl3 \v Manual compiling operations (alternative to makefile):}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Aliases:} \par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
alias gccW99_o="gcc -std=c99 -O2 -Wall -Werror -Wextra -Wconversion -Wfloat-equal -pedantic-errors -o"\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
alias gccW99_c="gcc -std=c99 -O2 -Wall -Werror -Wextra -Wconversion -Wfloat-equal -pedantic-errors -c -o"\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
alias gccW99_lib="gcc -std=c99 -O2 -Wall -Werror -Wextra -Wconversion -Wfloat-equal -pedantic-errors -fpic -shared -o"\par
\par
}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Compile-commands:} \par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gccW99_lib {\b lib/graph/lib_graph.so} {\b lib/graph/lib_graph.c} \~\~--> {\i Create GRAPH dynamic library object file.} \par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gccW99_lib {\b lib/ui/lib_ui.so} {\b lib/ui/lib_ui.c} \~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~--> {\i Create UI (TERMINAL I/O) dynamic library object file.} \par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gccW99_lib {\b lib/files/lib_files.so} {\b lib/files/lib_files.c} \~\~\~\~\~\~\~\~\~\~\~\~--> {\i Create FILES dynamic library object file.} \par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gccW99_lib {\b lib/timer/lib_timer.so} {\b lib/timer/lib_timer.c} \~\~\~\~\~\~--> {\i Create TIMER dynamic library object file.} \par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gccW99_c {\b main/graph_test.o} {\b main/graph_test.c} \~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~--> {\i Create MAIN object file.} \par
\par
}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Link-command:} \par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gccW99_o graph_test {\b main/graph_test.o} {\b lib/graph/lib_graph.so} {\b lib/ui/lib_ui.so} {\b lib/files/lib_files.so} {\b lib/timer/lib_timer.so} \~\~--> {\i LINK main and dynamic libraries object files to test executable.}  \par}
}
\par\par}
\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
2 - Testing software{\tc \v 2 - Testing software}\par \pard\plain 
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Graph-library test software main code file info\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Code title:
\par}
{\tc\tcl2 \v Code title:}
\'97. \par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Code details:
\par}
{\tc\tcl3 \v Code details:}
Polynomial interpolation C code --> Newton algorithm with divided-differences to interpolate 'till 170 points, polynomial evaluation in given points and derivate calculation. \par}
\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
3 - Makefile{\tc \v 3 - Makefile}\par \pard\plain 
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Software makefile info\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Code title:
\par}
{\tc\tcl2 \v Code title:}
\'97. \par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Code details:
\par}
{\tc\tcl3 \v Code details:}
Polynomial interpolation C code --> Newton algorithm with divided-differences to interpolate 'till 170 points, polynomial evaluation in given points and derivate calculation. \par}
\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
4 - Gnuplot{\tc \v 4 - Gnuplot}\par \pard\plain 
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Info about graphical representations through gnuplot\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Code title:
\par}
{\tc\tcl2 \v Code title:}
\'97. \par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Code details:
\par}
{\tc\tcl3 \v Code details:}
Polynomial interpolation C code --> Newton algorithm with divided-differences to interpolate 'till 170 points, polynomial evaluation in given points and derivate calculation. \par}
\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
5 - Graph library{\tc \v 5 - Graph library}\par \pard\plain 
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Graph-library info\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Code title:
\par}
{\tc\tcl2 \v Code title:}
\'97. \par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Code details:
\par}
{\tc\tcl3 \v Code details:}
Polynomial interpolation C code --> Newton algorithm with divided-differences to interpolate 'till 170 points, polynomial evaluation in given points and derivate calculation. \par}
\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
6 - UI library{\tc \v 6 - UI library}\par \pard\plain 
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
User-interface-library info\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Code title:
\par}
{\tc\tcl2 \v Code title:}
\'97. \par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Code details:
\par}
{\tc\tcl3 \v Code details:}
Polynomial interpolation C code --> Newton algorithm with divided-differences to interpolate 'till 170 points, polynomial evaluation in given points and derivate calculation. \par}
\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
7 - Files library{\tc \v 7 - Files library}\par \pard\plain 
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Files-library info\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Code title:
\par}
{\tc\tcl2 \v Code title:}
\'97. \par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Code details:
\par}
{\tc\tcl3 \v Code details:}
Polynomial interpolation C code --> Newton algorithm with divided-differences to interpolate 'till 170 points, polynomial evaluation in given points and derivate calculation. \par}
\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
8 - Timer library{\tc \v 8 - Timer library}\par \pard\plain 
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Timer-library info\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Code title:
\par}
{\tc\tcl2 \v Code title:}
\'97. \par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Code details:
\par}
{\tc\tcl3 \v Code details:}
Polynomial interpolation C code --> Newton algorithm with divided-differences to interpolate 'till 170 points, polynomial evaluation in given points and derivate calculation. \par}
\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Bug List{\tc \v Bug List}\par \pard\plain 
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Page {\b 1 - General notes about software}  \par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
No known bugs.\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Index\par \pard\plain 
{\tc \v Data Structure Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Data Structures\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the data structures with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b arch} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Arch struct typedef to store arch name, arch cost and connection nodes associated to that arch (Node1 and Node2) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b connection} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Node connection, composed by connection arch and node on the other edge of the arch })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAME \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b date_time} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Date/time data-structure (yyyy/mn/dd, hh:mm:ss), defined using {\b get_date_time()} or {\b assign_date_time()} functions.\par
 Date/time exact format: {\i (yyyy) + {\b DATE_DELIM_CHR} + (mn) + {\b DATE_DELIM_CHR} + (dd) + {\b DATE_TIME_DELIM_CHR} + (hh+1) + {\b TIME_DELIM_CHR} + (mm+1) + {\b TIME_DELIM_CHR} + (ss+1)}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b dijkstra_dataset} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Dijkstra-dataset struct typedef to store informations about a specific node, in order to be able to find min-cost path with Dijkstra's algorithm and reconstruct shortest path })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b list_elem} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  List element struct typedef to store connection archs associated to a specific node })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b node} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Node struct typedef to store node name, a list of connection archs associated to that node and a Dijkstra-dataset which contains the informations about that specific node to find min-cost path with Dijkstra's algorithm and reconstruct shortest path })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b street} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Street struct typedef for graph-library test (use crosses and streets as example of archs and nodes) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b graph_test} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Graph-library test software main executable file}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b makefile} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Makefile to compile/run software, make/view doxygen documentation and view LaTeX abstract pdf}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b archs.dat} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b File containing data to plot archs inside graph using gnuplot}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b costs.dat} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b File containing data to plot arch-costs inside graph using gnuplot}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b graph_plot.cmd} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Gnuplot sctipt to plot graph structure}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b nodes.dat} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b File containing data to plot nodes inside graph using gnuplot}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b shortest_archs.dat} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Editable file containing data to plot shortest-path archs inside graph using gnuplot (green)}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b shortest_costs.dat} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Editable file containing data to plot shortest-path arch-costs inside graph using gnuplot (blue)}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b shortest_nodes.dat} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Editable file containing data to plot shortest-path nodes inside graph using gnuplot (green)}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b shortest_plot.cmd} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Gnuplot sctipt to plot graph structure with shortest-path}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gnuplot/{\b src_dest_nodes.dat} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Editable file containing data to plot shortest-path source and destination nodes inside graph using gnuplot (purple)}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/files/{\b lib_files.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Files-library code file}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/files/{\b lib_files.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Files-library header file}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/files/{\b lib_files.so} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Files-library object file}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/graph/{\b lib_graph.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Graph-library code file}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/graph/{\b lib_graph.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Graph-library header file}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/graph/{\b lib_graph.so} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Graph-library object file}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/timer/{\b lib_timer.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Timer-library code file}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/timer/{\b lib_timer.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Timer-library header file}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/timer/{\b lib_timer.so} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Timer-library object file}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/ui/{\b lib_ui.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b User-interface-library code file}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/ui/{\b lib_ui.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b User-interface-library header file}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/ui/{\b lib_ui.so} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b User-interface-library object file}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b main/{\b graph_test.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Graph-library test software main code file}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b main/{\b graph_test.o} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Graph-library test software main object file}  })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Documentation{\tc \v Data Structure Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
arch Struct Reference\par \pard\plain 
{\tc\tcl2 \v arch}
{\xe \v arch}
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Arch struct typedef to store arch name, arch cost and connection nodes associated to that arch (Node1 and Node2). }}\par
{
{\f2 #include <lib_graph.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b name} [{\b AR_STR_LEN}]\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Arch-name string, length defined through {\b AR_STR_LEN} macro. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Graph_node} {\b nd1}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Arch-connection Node1 pointer to graph-node element allocated in nodes collection vector (inside heap: {\b nodes_collect_vect}). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Real} {\b cost}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Arch-connection cost (reference value for {\b dijkstra_alg()} function to find min-cost path between specified source and destination nodes). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Graph_node} {\b nd2}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Arch-connection Node2 pointer to graph-node element allocated in nodes collection vector (inside heap: {\b nodes_collect_vect}). }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Arch struct typedef to store arch name, arch cost and connection nodes associated to that arch (Node1 and Node2). \par
}{
Definition at line 75 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v cost\:arch}
{\xe \v arch\:cost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Real} arch::cost}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Arch-connection cost (reference value for {\b dijkstra_alg()} function to find min-cost path between specified source and destination nodes). }}\par
{
Definition at line 81 of file lib_graph.h.}\par
}
{\xe \v name\:arch}
{\xe \v arch\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char arch::name[{\b AR_STR_LEN}]}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Arch-name string, length defined through {\b AR_STR_LEN} macro. }}\par
{
Definition at line 77 of file lib_graph.h.}\par
}
{\xe \v nd1\:arch}
{\xe \v arch\:nd1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Graph_node} arch::nd1}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Arch-connection Node1 pointer to graph-node element allocated in nodes collection vector (inside heap: {\b nodes_collect_vect}). }}\par
{
Definition at line 79 of file lib_graph.h.}\par
}
{\xe \v nd2\:arch}
{\xe \v arch\:nd2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Graph_node} arch::nd2}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Arch-connection Node2 pointer to graph-node element allocated in nodes collection vector (inside heap: {\b nodes_collect_vect}). }}\par
{
Definition at line 83 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/graph/{\b lib_graph.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
connection Struct Reference\par \pard\plain 
{\tc\tcl2 \v connection}
{\xe \v connection}
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Node connection, composed by connection arch and node on the other edge of the arch. }}\par
{
{\f2 #include <lib_graph.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Graph_node} {\b nd}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connection node pointer to graph-node element allocated in nodes collection vector (inside heap: {\b nodes_collect_vect}). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Graph_arch} {\b ar}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connection arch pointer to graph-arch element allocated in archs collection vector (inside heap: {\b archs_collect_vect}). }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Node connection, composed by connection arch and node on the other edge of the arch. \par
}{
Definition at line 100 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v ar\:connection}
{\xe \v connection\:ar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Graph_arch} connection::ar}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connection arch pointer to graph-arch element allocated in archs collection vector (inside heap: {\b archs_collect_vect}). }}\par
{
Definition at line 104 of file lib_graph.h.}\par
}
{\xe \v nd\:connection}
{\xe \v connection\:nd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Graph_node} connection::nd}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connection node pointer to graph-node element allocated in nodes collection vector (inside heap: {\b nodes_collect_vect}). }}\par
{
Definition at line 102 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/graph/{\b lib_graph.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
date_time Struct Reference\par \pard\plain 
{\tc\tcl2 \v date_time}
{\xe \v date_time}
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Date/time data-structure (yyyy/mn/dd, hh:mm:ss), defined using {\b get_date_time()} or {\b assign_date_time()} functions.\par
 Date/time exact format: {\i (yyyy) + {\b DATE_DELIM_CHR} + (mn) + {\b DATE_DELIM_CHR} + (dd) + {\b DATE_TIME_DELIM_CHR} + (hh+1) + {\b TIME_DELIM_CHR} + (mm+1) + {\b TIME_DELIM_CHR} + (ss+1)} . }}\par
{
{\f2 #include <lib_timer.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b yyyy}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Years value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mn}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Monts value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b dd}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Days value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b hh}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Hours value (+1). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mm}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minutes value (+1). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ss}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Seconds value (+1). }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Date/time data-structure (yyyy/mn/dd, hh:mm:ss), defined using {\b get_date_time()} or {\b assign_date_time()} functions.\par
 Date/time exact format: {\i (yyyy) + {\b DATE_DELIM_CHR} + (mn) + {\b DATE_DELIM_CHR} + (dd) + {\b DATE_TIME_DELIM_CHR} + (hh+1) + {\b TIME_DELIM_CHR} + (mm+1) + {\b TIME_DELIM_CHR} + (ss+1)} . \par
}{
Definition at line 73 of file lib_timer.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v dd\:date_time}
{\xe \v date_time\:dd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int date_time::dd}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Days value. }}\par
{
Definition at line 79 of file lib_timer.h.}\par
}
{\xe \v hh\:date_time}
{\xe \v date_time\:hh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int date_time::hh}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Hours value (+1). }}\par
{
Definition at line 81 of file lib_timer.h.}\par
}
{\xe \v mm\:date_time}
{\xe \v date_time\:mm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int date_time::mm}}
\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minutes value (+1). }}\par
{
Definition at line 83 of file lib_timer.h.}\par
}
{\xe \v mn\:date_time}
{\xe \v date_time\:mn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int date_time::mn}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Monts value. }}\par
{
Definition at line 77 of file lib_timer.h.}\par
}
{\xe \v ss\:date_time}
{\xe \v date_time\:ss}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int date_time::ss}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Seconds value (+1). }}\par
{
Definition at line 85 of file lib_timer.h.}\par
}
{\xe \v yyyy\:date_time}
{\xe \v date_time\:yyyy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int date_time::yyyy}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Years value. }}\par
{
Definition at line 75 of file lib_timer.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/timer/{\b lib_timer.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
dijkstra_dataset Struct Reference\par \pard\plain 
{\tc\tcl2 \v dijkstra_dataset}
{\xe \v dijkstra_dataset}
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Dijkstra-dataset struct typedef to store informations about a specific node, in order to be able to find min-cost path with Dijkstra's algorithm and reconstruct shortest path. }}\par
{
{\f2 #include <lib_graph.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Graph_node} {\b prev_nd}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Previous node in shortest path (pointer to a graph-node element allocated in nodes collection vector inside heap: {\b nodes_collect_vect}). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Real} {\b min_path_cost}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Shortest-path cost to reach that specific node, from source node specified during {\b dijkstra_alg()} function call (path can be reconstructed backwards using {\b prev_nd} by calling {\b buid_shortest_path()} function). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Byte} {\b an_flg}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Node flag to mark it as already analyzed when processed by {\b dijkstra_alg()} function. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Dijkstra-dataset struct typedef to store informations about a specific node, in order to be able to find min-cost path with Dijkstra's algorithm and reconstruct shortest path. \par
}{
Definition at line 90 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v an_flg\:dijkstra_dataset}
{\xe \v dijkstra_dataset\:an_flg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Byte} dijkstra_dataset::an_flg}}
\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Node flag to mark it as already analyzed when processed by {\b dijkstra_alg()} function. }}\par
{
Definition at line 96 of file lib_graph.h.}\par
}
{\xe \v min_path_cost\:dijkstra_dataset}
{\xe \v dijkstra_dataset\:min_path_cost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Real} dijkstra_dataset::min_path_cost}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Shortest-path cost to reach that specific node, from source node specified during {\b dijkstra_alg()} function call (path can be reconstructed backwards using {\b prev_nd} by calling {\b buid_shortest_path()} function). }}\par
{
Definition at line 94 of file lib_graph.h.}\par
}
{\xe \v prev_nd\:dijkstra_dataset}
{\xe \v dijkstra_dataset\:prev_nd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Graph_node} dijkstra_dataset::prev_nd}}
\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Previous node in shortest path (pointer to a graph-node element allocated in nodes collection vector inside heap: {\b nodes_collect_vect}). }}\par
{
Definition at line 92 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/graph/{\b lib_graph.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
list_elem Struct Reference\par \pard\plain 
{\tc\tcl2 \v list_elem}
{\xe \v list_elem}
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  List element struct typedef to store connection archs associated to a specific node. }}\par
{
{\f2 #include <lib_graph.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b arch} * {\b ar}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Node-connection arch pointer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b list_elem} * {\b nxt}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Next list element pointer (next arch in node archs list). }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  List element struct typedef to store connection archs associated to a specific node. \par
}{
Definition at line 51 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v ar\:list_elem}
{\xe \v list_elem\:ar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b arch}* list_elem::ar}}
\par
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Node-connection arch pointer. }}\par
{
Definition at line 53 of file lib_graph.h.}\par
}
{\xe \v nxt\:list_elem}
{\xe \v list_elem\:nxt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b list_elem}* list_elem::nxt}}
\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Next list element pointer (next arch in node archs list). }}\par
{
Definition at line 55 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/graph/{\b lib_graph.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
node Struct Reference\par \pard\plain 
{\tc\tcl2 \v node}
{\xe \v node}
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Node struct typedef to store node name, a list of connection archs associated to that node and a Dijkstra-dataset which contains the informations about that specific node to find min-cost path with Dijkstra's algorithm and reconstruct shortest path. }}\par
{
{\f2 #include <lib_graph.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b name} [{\b ND_STR_LEN}]\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Node-name string, length defined through {\b ND_STR_LEN} macro. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b List} {\b archs_lst}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Node-connection archs list head pointer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dijkstra_dataset} * {\b dd}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dijkstra-dataset pointer (set of informations to be able to find and reconstruct min-cost path, allocated inside a dynamic-memory vector: {\b dijk_dataset_vect}). }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Node struct typedef to store node name, a list of connection archs associated to that node and a Dijkstra-dataset which contains the informations about that specific node to find min-cost path with Dijkstra's algorithm and reconstruct shortest path. \par
}{
Definition at line 62 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v archs_lst\:node}
{\xe \v node\:archs_lst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b List} node::archs_lst}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Node-connection archs list head pointer. }}\par
{
Definition at line 66 of file lib_graph.h.}\par
}
{\xe \v dd\:node}
{\xe \v node\:dd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b dijkstra_dataset}* node::dd}}
\par
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dijkstra-dataset pointer (set of informations to be able to find and reconstruct min-cost path, allocated inside a dynamic-memory vector: {\b dijk_dataset_vect}). }}\par
{
Definition at line 68 of file lib_graph.h.}\par
}
{\xe \v name\:node}
{\xe \v node\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char node::name[{\b ND_STR_LEN}]}}
\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Node-name string, length defined through {\b ND_STR_LEN} macro. }}\par
{
Definition at line 64 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/graph/{\b lib_graph.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
street Struct Reference\par \pard\plain 
{\tc\tcl2 \v street}
{\xe \v street}
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Street struct typedef for graph-library test (use crosses and streets as example of archs and nodes). }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b C_char} {\b name} [{\b AR_STR_LEN}]\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Street name, string length defined through {\b AR_STR_LEN} macro. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b C_real} {\b length}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Street length (arch cost). }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Street struct typedef for graph-library test (use crosses and streets as example of archs and nodes). \par
}{
Definition at line 182 of file graph_test.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v length\:street}
{\xe \v street\:length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b C_real} street::length}}
\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Street length (arch cost). }}\par
{
Definition at line 186 of file graph_test.c.}\par
}
{\xe \v name\:street}
{\xe \v street\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b C_char} street::name[{\b AR_STR_LEN}]}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Street name, string length defined through {\b AR_STR_LEN} macro. }}\par
{
Definition at line 184 of file graph_test.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
main/{\b graph_test.c}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/cristian/Comune/Coding/Project/README.md File Reference\par \pard\plain 
{\tc\tcl2 \v /home/cristian/Comune/Coding/Project/README.md}
{\xe \v /home/cristian/Comune/Coding/Project/README.md}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/archs.dat File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/archs.dat}
{\xe \v gnuplot/archs.dat}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b File containing data to plot archs inside graph using gnuplot}  }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b File containing data to plot archs inside graph using gnuplot}  \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i More info in {\b 'Gnuplot'}  section inside doxygen {\b 'Related pages'} .}  \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/costs.dat File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/costs.dat}
{\xe \v gnuplot/costs.dat}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b File containing data to plot arch-costs inside graph using gnuplot}  }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b File containing data to plot arch-costs inside graph using gnuplot}  \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i More info in {\b 'Gnuplot'}  section inside doxygen {\b 'Related pages'} .}  \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/graph_plot.cmd File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/graph_plot.cmd}
{\xe \v gnuplot/graph_plot.cmd}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Gnuplot sctipt to plot graph structure}  }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Gnuplot sctipt to plot graph structure}  \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i More info in {\b 'Gnuplot'}  section inside doxygen {\b 'Related pages'} .}  \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/nodes.dat File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/nodes.dat}
{\xe \v gnuplot/nodes.dat}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b File containing data to plot nodes inside graph using gnuplot}  }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b File containing data to plot nodes inside graph using gnuplot}  \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i More info in {\b 'Gnuplot'}  section inside doxygen {\b 'Related pages'} .}  \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/shortest_archs.dat File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/shortest_archs.dat}
{\xe \v gnuplot/shortest_archs.dat}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Editable file containing data to plot shortest-path archs inside graph using gnuplot (green)}  }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Editable file containing data to plot shortest-path archs inside graph using gnuplot (green)}  \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i More info in {\b 'Gnuplot'}  section inside doxygen {\b 'Related pages'} .}  \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/shortest_costs.dat File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/shortest_costs.dat}
{\xe \v gnuplot/shortest_costs.dat}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Editable file containing data to plot shortest-path arch-costs inside graph using gnuplot (blue)}  }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Editable file containing data to plot shortest-path arch-costs inside graph using gnuplot (blue)}  \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i More info in {\b 'Gnuplot'}  section inside doxygen {\b 'Related pages'} .}  \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/shortest_nodes.dat File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/shortest_nodes.dat}
{\xe \v gnuplot/shortest_nodes.dat}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Editable file containing data to plot shortest-path nodes inside graph using gnuplot (green)}  }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Editable file containing data to plot shortest-path nodes inside graph using gnuplot (green)}  \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i More info in {\b 'Gnuplot'}  section inside doxygen {\b 'Related pages'} .}  \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/shortest_plot.cmd File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/shortest_plot.cmd}
{\xe \v gnuplot/shortest_plot.cmd}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Gnuplot sctipt to plot graph structure with shortest-path}  }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Gnuplot sctipt to plot graph structure with shortest-path}  \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i More info in {\b 'Gnuplot'}  section inside doxygen {\b 'Related pages'} .}  \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gnuplot/src_dest_nodes.dat File Reference\par \pard\plain 
{\tc\tcl2 \v gnuplot/src_dest_nodes.dat}
{\xe \v gnuplot/src_dest_nodes.dat}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Editable file containing data to plot shortest-path source and destination nodes inside graph using gnuplot (purple)}  }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Editable file containing data to plot shortest-path source and destination nodes inside graph using gnuplot (purple)}  \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i More info in {\b 'Gnuplot'}  section inside doxygen {\b 'Related pages'} .}  \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
graph_test File Reference\par \pard\plain 
{\tc\tcl2 \v graph_test}
{\xe \v graph_test}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Graph-library test software main executable file}  }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Graph-library test software main executable file}  \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Executable file generated from {\b graph_test.c} during compiling operations.}  \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/files/lib_files.c File Reference\par \pard\plain 
{\tc\tcl2 \v lib/files/lib_files.c}
{\xe \v lib/files/lib_files.c}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Files-library code file}  }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "lib_files.h"}\par
{\f2 #include "../ui/lib_ui.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Fl} {\b open_file} (const char *const filename, const char *const mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_int_on_file} ({\b Fl} file, const int num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_str_on_file} ({\b Fl} file, const char *const str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_sep_on_file} ({\b Fl} file, const char sep)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_nl_on_file} ({\b Fl} file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_tab_on_file} ({\b Fl} file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b read_from_file} ({\b Fl} file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b get_substr_line_from_file} ({\b Fl} file, const char *const tgt_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b get_line_str_from_file} ({\b Fl} file, const int tgt_str_line_num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_file} ({\b Fl} file)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b file_in_buff} [{\b FILE_IN_BUFF_SIZE}] = ""\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  File-input buffer string variabile (size defined with {\b FILE_IN_BUFF_SIZE} macro), mainly used by fgets() function in file-reading operations. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Files-library code file}  \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i More info in {\b 'Files library'}  section inside doxygen {\b 'Related pages'} .}  \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v close_file\:lib_files.c}
{\xe \v lib_files.c\:close_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_file ({\b Fl}  {\i file})}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to close opened file.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i file} \cell }{File pointer on which to apply closing operation.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 240 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00240                         \{                                                                                   {\cf20 // Function to close file}\par
00241   {\cf20 /* Body */}\par
00242   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00243     C_int res = fclose(file);                                                                               {\cf20 // Close file}\par
00244     {\cf19 if} (res == EOF)\{                                                                                        {\cf20 // Check file close operation result}\par
00245       fbk_err({\cf22 "Ops! Encountered error during file close operation"});                                        {\cf20 // Print error fbk}\par
00246       perror({\cf22 "File close operation failed!"});                                                               {\cf20 // Print perror fbk}\par
00247     \}\par
00248   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00249     fbk_err({\cf22 "Ops! Null-file found during file-close operation"});                                            {\cf20 // Print error fbk}\par
00250     perror({\cf22 "File close operation failed!"});                                                                 {\cf20 // Print perror fbk}\par
00251   \}\par
00252 \}\par
}
}
{\xe \v get_line_str_from_file\:lib_files.c}
{\xe \v lib_files.c\:get_line_str_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* get_line_str_from_file ({\b Fl}  {\i file}, const int  {\i tgt_str_line_num})}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to read lines in file until target-string line number, to give back line content.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i file} \cell }{File pointer on which to apply reading operation. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i tgt_str_line_num} \cell }{Target string line number inside the file.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Return specified target-string line number content (string). \par
}}}{
Definition at line 216 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00216                                                                  \{                                          {\cf20 // Function to get line-string from file (by target-string line number, returns NULL for no-match found or error)}\par
00217   {\cf20 /* Body */}\par
00218   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00219     {\cf18 int} line_num = 0;                                                                                       {\cf20 // Line number counter}\par
00220     {\cf19 while} ( fgets(file_in_buff, FILE_IN_BUFF_SIZE, file) != NULL )\{                                         {\cf20 // In case of file found, scan lines 'till null line (last one)}\par
00221       ++line_num;                                                                                           {\cf20 // Line number val upd}\par
00222       {\cf19 if} (line_num == tgt_str_line_num)                                                                     {\cf20 // Scroll 'till target-string line number}\par
00223         {\cf19 return} file_in_buff;                                                                                {\cf20 // Return current line content as str}\par
00224     \}\par
00225   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00226     fbk_err({\cf22 "Ops! Null-file found during line-string returning operation (by line number)"});                {\cf20 // Print error fbk}\par
00227     perror({\cf22 "File line-string returning operation (by line number) failed!"});                                {\cf20 // Print perror fbk}\par
00228   \}\par
00229   {\cf19 return} NULL;                                                                                              {\cf20 // Return NULL for no-match found or error}\par
00230 \}\par
}
}
{\xe \v get_substr_line_from_file\:lib_files.c}
{\xe \v lib_files.c\:get_substr_line_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int get_substr_line_from_file ({\b Fl}  {\i file}, const char *const  {\i tgt_str})}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to read lines in file, looking for target-string (or sub-string) line number.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i file} \cell }{File pointer on which to apply reading operation. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i tgt_str} \cell }{Target string (or sub-string) to find inside file, with the aim of detecting its line number.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Return specified target-string line number. \par
}}}{
Definition at line 191 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00191                                                                  \{                                          {\cf20 // Function to get sub-string line number from file (by target-string, returns -1 for no-match found or error)}\par
00192   {\cf20 /* Body */}\par
00193   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00194     {\cf18 int} line_num = 0;                                                                                       {\cf20 // Line number counter}\par
00195     {\cf19 while} ( fgets(file_in_buff, FILE_IN_BUFF_SIZE, file) != NULL )\{                                         {\cf20 // In case of file found, scan lines 'till null line (last one)}\par
00196       ++line_num;                                                                                           {\cf20 // Line number val upd}\par
00197       {\cf19 if} (strstr(file_in_buff, tgt_str) != NULL)                                                            {\cf20 // Check if substring is in current line}\par
00198         {\cf19 return} line_num;                                                                                    {\cf20 // Return current line-number}\par
00199     \}\par
00200   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00201     fbk_err({\cf22 "Ops! Null-file found during target-substring line number id operation"});                       {\cf20 // Print error fbk}\par
00202     perror({\cf22 "File target-substring line number id operation failed!"});                                       {\cf20 // Print perror fbk}\par
00203   \}\par
00204   {\cf19 return} -1;                                                                                                {\cf20 // Return -1 for no-match found or error}\par
00205 \}\par
}
}
{\xe \v open_file\:lib_files.c}
{\xe \v lib_files.c\:open_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Fl} open_file (const char *const  {\i filename}, const char *const  {\i mode})}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to open file by-name in specified mode.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i filename} \cell }{File name/path string of the to open. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i mode} \cell }{File opening mode:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
"w" = Write (clear file or create if not existing).\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
"r" = Read only.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
"a" = Append (do not clear file, add text in write only, create if file doesn't exist).\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
"r+" = Read/write (only if file exists).\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
"w+" = Read/write (create file if not existing).\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
"a+" = Read/write/append (create file if not existing).\par}
\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Return opened file pointer, NULL in case file-opening operation failed. \par
}}}{
Definition at line 35 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00035                                                                 \{                                           {\cf20 // Function to open file}\par
00036   {\cf20 /* Body */}\par
00037   FILE *file;                                                                                               {\cf20 // Define file obj pointer}\par
00038   file = fopen(filename, mode);                                                                             {\cf20 // Open defined file in specified mode}\par
00039   {\cf19 if} (file == NULL)\{                                                                                        {\cf20 // Check open file operation result}\par
00040     fbk_err({\cf22 "Ops! Encountered error during file open operation"});                                           {\cf20 // Print error fbk}\par
00041     perror({\cf22 "File open operation failed!"});                                                                  {\cf20 // Print perror fbk}\par
00042   \}\par
00043   {\cf19 return} file;                                                                                              {\cf20 // Return file pointer}\par
00044 \}\par
}
}
{\xe \v read_from_file\:lib_files.c}
{\xe \v lib_files.c\:read_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void read_from_file ({\b Fl}  {\i file})}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to read lines in file, printing them on terminal as feedback.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i file} \cell }{File pointer on which to apply reading operation.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 167 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00167                             \{                                                                               {\cf20 // Function to read from file}\par
00168   {\cf20 /* Body */}\par
00169   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00170     fbk_nl(1);                                                                                              {\cf20 // New line fbk}\par
00171     {\cf18 int} line_num = 0;                                                                                       {\cf20 // Line number counter}\par
00172     {\cf19 while} ( fgets(file_in_buff, FILE_IN_BUFF_SIZE, file) != NULL )\{                                         {\cf20 // In case of file found, scan lines 'till null line (last one)}\par
00173       ++line_num;                                                                                           {\cf20 // Line number val upd}\par
00174       printf({\cf22 "%s%d)\\t%s%s"}, BU, line_num, OG, file_in_buff);                                                {\cf20 // Print line number and val fbk}\par
00175     \}\par
00176   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00177     fbk_err({\cf22 "Ops! Null-file found during file-read operation"});                                             {\cf20 // Print error fbk}\par
00178     perror({\cf22 "File read operation failed!"});                                                                  {\cf20 // Print perror fbk}\par
00179   \}\par
00180 \}\par
}
}
{\xe \v write_int_on_file\:lib_files.c}
{\xe \v lib_files.c\:write_int_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_int_on_file ({\b Fl}  {\i file}, const int  {\i num})}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to write integer on file.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i file} \cell }{File pointer on which to apply writing operation. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i num} \cell }{Integer value to write on file.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 55 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00055                                               \{                                                             {\cf20 // Function to write int on file}\par
00056   {\cf20 /* Body */}\par
00057   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00058     C_int res = fprintf(file, {\cf22 "%d"}, num);                                                                   {\cf20 // Insert number in file}\par
00059     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00060       fbk_err({\cf22 "Ops! Encountered error during int value file write operation"});                              {\cf20 // Print error fbk}\par
00061       perror({\cf22 "File write operation of int value, failed!"});                                                 {\cf20 // Print perror fbk}\par
00062     \}\par
00063   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00064     fbk_err({\cf22 "Ops! Null-file found during int value file write-operation"});                                  {\cf20 // Print error fbk}\par
00065     perror({\cf22 "File write operation of int value, failed!"});                                                   {\cf20 // Print perror fbk}\par
00066   \}\par
00067 \}\par
}
}
{\xe \v write_nl_on_file\:lib_files.c}
{\xe \v lib_files.c\:write_nl_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_nl_on_file ({\b Fl}  {\i file})}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to write new-line on file.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i file} \cell }{File pointer on which to apply writing operation.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 123 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00123                               \{                                                                             {\cf20 // Function to write new line on file}\par
00124   {\cf20 /* Body */}\par
00125   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00126     C_int res = fprintf(file, {\cf22 "\\n"});                                                                        {\cf20 // Insert new line in file}\par
00127     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00128       fbk_err({\cf22 "Ops! Encountered error during new line file write operation"});                               {\cf20 // Print error fbk}\par
00129       perror({\cf22 "File write operation of new line failed!"});                                                   {\cf20 // Print perror fbk}\par
00130     \}\par
00131   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00132     fbk_err({\cf22 "Ops! Null-file found during new line file-write operation"});                                   {\cf20 // Print error fbk}\par
00133     perror({\cf22 "File write operation of new line failed!"});                                                     {\cf20 // Print perror fbk}\par
00134   \}\par
00135 \}\par
}
}
{\xe \v write_sep_on_file\:lib_files.c}
{\xe \v lib_files.c\:write_sep_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_sep_on_file ({\b Fl}  {\i file}, const char  {\i sep})}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to write separator-char on file.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i file} \cell }{File pointer on which to apply writing operation. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i sep} \cell }{Separator char to write on file.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 101 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00101                                                \{                                                            {\cf20 // Function to write separator on file}\par
00102   {\cf20 /* Body */}\par
00103   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00104     C_int res = fprintf(file, {\cf22 "%c"}, sep);                                                                   {\cf20 // Insert separator in file}\par
00105     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00106       fbk_err({\cf22 "Ops! Encountered error during separator char file write operation"});                         {\cf20 // Print error fbk}\par
00107       perror({\cf22 "File write operation of separator char failed!"});                                             {\cf20 // Print perror fbk}\par
00108     \}\par
00109   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00110     fbk_err({\cf22 "Ops! Null-file found during separator char file-write operation"});                             {\cf20 // Print error fbk}\par
00111     perror({\cf22 "File write operation of separator char failed!"});                                               {\cf20 // Print perror fbk}\par
00112   \}\par
00113 \}\par
}
}
{\xe \v write_str_on_file\:lib_files.c}
{\xe \v lib_files.c\:write_str_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_str_on_file ({\b Fl}  {\i file}, const char *const  {\i str})}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to write string on file.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i file} \cell }{File pointer on which to apply writing operation. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i str} \cell }{String value to write on file.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 78 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00078                                                       \{                                                     {\cf20 // Function to write string on file}\par
00079   {\cf20 /* Body */}\par
00080   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00081     C_int res = fprintf(file, {\cf22 "%s"}, str);                                                                   {\cf20 // Insert string in file}\par
00082     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00083       fbk_err({\cf22 "Ops! Encountered error during string file write operation"});                                 {\cf20 // Print error fbk}\par
00084       perror({\cf22 "File write operation of string failed!"});                                                     {\cf20 // Print perror fbk}\par
00085     \}\par
00086   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00087     fbk_err({\cf22 "Ops! Null-file found during string file write-operation"});                                     {\cf20 // Print error fbk}\par
00088     perror({\cf22 "File write operation of string failed!"});                                                       {\cf20 // Print perror fbk}\par
00089   \}\par
00090 \}\par
}
}
{\xe \v write_tab_on_file\:lib_files.c}
{\xe \v lib_files.c\:write_tab_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_tab_on_file ({\b Fl}  {\i file})}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to write tab on file.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i file} \cell }{File pointer on which to apply writing operation.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 145 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00145                                \{                                                                            {\cf20 // Function to write tab on file}\par
00146   {\cf20 /* Body */}\par
00147   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00148     C_int res = fprintf(file, {\cf22 "\\t"});                                                                        {\cf20 // Insert tab in file}\par
00149     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00150       fbk_err({\cf22 "Ops! Encountered error during tab file write operation"});                                    {\cf20 // Print error fbk}\par
00151       perror({\cf22 "File write operation of tab failed!"});                                                        {\cf20 // Print perror fbk}\par
00152     \}\par
00153   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00154     fbk_err({\cf22 "Ops! Null-file found during tab file-write operation"});                                        {\cf20 // Print error fbk}\par
00155     perror({\cf22 "File write operation of tab failed!"});                                                          {\cf20 // Print perror fbk}\par
00156   \}\par
00157 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v file_in_buff\:lib_files.c}
{\xe \v lib_files.c\:file_in_buff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char file_in_buff[{\b FILE_IN_BUFF_SIZE}] = ""}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  File-input buffer string variabile (size defined with {\b FILE_IN_BUFF_SIZE} macro), mainly used by fgets() function in file-reading operations. }}\par
{
Definition at line 17 of file lib_files.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/files/lib_files.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/files/lib_files.h}
{\xe \v lib/files/lib_files.h}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Files-library header file}  }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FILE_IN_BUFF_SIZE}\~ 1024\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Max file-input strings length in chars {\i (1023 + '\\0')} , mainly used by fgets() function in file-reading operations. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef FILE * {\b Fl}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  FILE* alias (Fl). }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Fl} {\b open_file} (const char *const filename, const char *const mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_int_on_file} ({\b Fl} file, const int num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_str_on_file} ({\b Fl} file, const char *const str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_sep_on_file} ({\b Fl} file, const char sep)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_nl_on_file} ({\b Fl} file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_tab_on_file} ({\b Fl} file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b read_from_file} ({\b Fl} file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b get_substr_line_from_file} ({\b Fl} file, const char *const tgt_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b get_line_str_from_file} ({\b Fl} file, const int tgt_str_line_num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_file} ({\b Fl} file)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b file_in_buff} [{\b FILE_IN_BUFF_SIZE}]\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  File-input buffer string variabile (size defined with {\b FILE_IN_BUFF_SIZE} macro), mainly used by fgets() function in file-reading operations. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Files-library header file}  \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Library header file of {\b lib_files.c}.}  \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v FILE_IN_BUFF_SIZE\:lib_files.h}
{\xe \v lib_files.h\:FILE_IN_BUFF_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FILE_IN_BUFF_SIZE\~ 1024}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Max file-input strings length in chars {\i (1023 + '\\0')} , mainly used by fgets() function in file-reading operations. }}\par
{
Definition at line 37 of file lib_files.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v Fl\:lib_files.h}
{\xe \v lib_files.h\:Fl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef FILE* {\b Fl}}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  FILE* alias (Fl). }}\par
{
Definition at line 42 of file lib_files.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v close_file\:lib_files.h}
{\xe \v lib_files.h\:close_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_file ({\b Fl}  {\i file})}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to close opened file.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i file} \cell }{File pointer on which to apply closing operation.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 240 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00240                         \{                                                                                   {\cf20 // Function to close file}\par
00241   {\cf20 /* Body */}\par
00242   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00243     C_int res = fclose(file);                                                                               {\cf20 // Close file}\par
00244     {\cf19 if} (res == EOF)\{                                                                                        {\cf20 // Check file close operation result}\par
00245       fbk_err({\cf22 "Ops! Encountered error during file close operation"});                                        {\cf20 // Print error fbk}\par
00246       perror({\cf22 "File close operation failed!"});                                                               {\cf20 // Print perror fbk}\par
00247     \}\par
00248   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00249     fbk_err({\cf22 "Ops! Null-file found during file-close operation"});                                            {\cf20 // Print error fbk}\par
00250     perror({\cf22 "File close operation failed!"});                                                                 {\cf20 // Print perror fbk}\par
00251   \}\par
00252 \}\par
}
}
{\xe \v get_line_str_from_file\:lib_files.h}
{\xe \v lib_files.h\:get_line_str_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* get_line_str_from_file ({\b Fl}  {\i file}, const int  {\i tgt_str_line_num})}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to read lines in file until target-string line number, to give back line content.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i file} \cell }{File pointer on which to apply reading operation. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i tgt_str_line_num} \cell }{Target string line number inside the file.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Return specified target-string line number content (string). \par
}}}{
Definition at line 216 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00216                                                                  \{                                          {\cf20 // Function to get line-string from file (by target-string line number, returns NULL for no-match found or error)}\par
00217   {\cf20 /* Body */}\par
00218   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00219     {\cf18 int} line_num = 0;                                                                                       {\cf20 // Line number counter}\par
00220     {\cf19 while} ( fgets(file_in_buff, FILE_IN_BUFF_SIZE, file) != NULL )\{                                         {\cf20 // In case of file found, scan lines 'till null line (last one)}\par
00221       ++line_num;                                                                                           {\cf20 // Line number val upd}\par
00222       {\cf19 if} (line_num == tgt_str_line_num)                                                                     {\cf20 // Scroll 'till target-string line number}\par
00223         {\cf19 return} file_in_buff;                                                                                {\cf20 // Return current line content as str}\par
00224     \}\par
00225   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00226     fbk_err({\cf22 "Ops! Null-file found during line-string returning operation (by line number)"});                {\cf20 // Print error fbk}\par
00227     perror({\cf22 "File line-string returning operation (by line number) failed!"});                                {\cf20 // Print perror fbk}\par
00228   \}\par
00229   {\cf19 return} NULL;                                                                                              {\cf20 // Return NULL for no-match found or error}\par
00230 \}\par
}
}
{\xe \v get_substr_line_from_file\:lib_files.h}
{\xe \v lib_files.h\:get_substr_line_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int get_substr_line_from_file ({\b Fl}  {\i file}, const char *const  {\i tgt_str})}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to read lines in file, looking for target-string (or sub-string) line number.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i file} \cell }{File pointer on which to apply reading operation. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i tgt_str} \cell }{Target string (or sub-string) to find inside file, with the aim of detecting its line number.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Return specified target-string line number. \par
}}}{
Definition at line 191 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00191                                                                  \{                                          {\cf20 // Function to get sub-string line number from file (by target-string, returns -1 for no-match found or error)}\par
00192   {\cf20 /* Body */}\par
00193   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00194     {\cf18 int} line_num = 0;                                                                                       {\cf20 // Line number counter}\par
00195     {\cf19 while} ( fgets(file_in_buff, FILE_IN_BUFF_SIZE, file) != NULL )\{                                         {\cf20 // In case of file found, scan lines 'till null line (last one)}\par
00196       ++line_num;                                                                                           {\cf20 // Line number val upd}\par
00197       {\cf19 if} (strstr(file_in_buff, tgt_str) != NULL)                                                            {\cf20 // Check if substring is in current line}\par
00198         {\cf19 return} line_num;                                                                                    {\cf20 // Return current line-number}\par
00199     \}\par
00200   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00201     fbk_err({\cf22 "Ops! Null-file found during target-substring line number id operation"});                       {\cf20 // Print error fbk}\par
00202     perror({\cf22 "File target-substring line number id operation failed!"});                                       {\cf20 // Print perror fbk}\par
00203   \}\par
00204   {\cf19 return} -1;                                                                                                {\cf20 // Return -1 for no-match found or error}\par
00205 \}\par
}
}
{\xe \v open_file\:lib_files.h}
{\xe \v lib_files.h\:open_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Fl} open_file (const char *const  {\i filename}, const char *const  {\i mode})}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to open file by-name in specified mode.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i filename} \cell }{File name/path string of the to open. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i mode} \cell }{File opening mode:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
"w" = Write (clear file or create if not existing).\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
"r" = Read only.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
"a" = Append (do not clear file, add text in write only, create if file doesn't exist).\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
"r+" = Read/write (only if file exists).\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
"w+" = Read/write (create file if not existing).\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
"a+" = Read/write/append (create file if not existing).\par}
\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Return opened file pointer, NULL in case file-opening operation failed. \par
}}}{
Definition at line 35 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00035                                                                 \{                                           {\cf20 // Function to open file}\par
00036   {\cf20 /* Body */}\par
00037   FILE *file;                                                                                               {\cf20 // Define file obj pointer}\par
00038   file = fopen(filename, mode);                                                                             {\cf20 // Open defined file in specified mode}\par
00039   {\cf19 if} (file == NULL)\{                                                                                        {\cf20 // Check open file operation result}\par
00040     fbk_err({\cf22 "Ops! Encountered error during file open operation"});                                           {\cf20 // Print error fbk}\par
00041     perror({\cf22 "File open operation failed!"});                                                                  {\cf20 // Print perror fbk}\par
00042   \}\par
00043   {\cf19 return} file;                                                                                              {\cf20 // Return file pointer}\par
00044 \}\par
}
}
{\xe \v read_from_file\:lib_files.h}
{\xe \v lib_files.h\:read_from_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void read_from_file ({\b Fl}  {\i file})}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to read lines in file, printing them on terminal as feedback.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i file} \cell }{File pointer on which to apply reading operation.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 167 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00167                             \{                                                                               {\cf20 // Function to read from file}\par
00168   {\cf20 /* Body */}\par
00169   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00170     fbk_nl(1);                                                                                              {\cf20 // New line fbk}\par
00171     {\cf18 int} line_num = 0;                                                                                       {\cf20 // Line number counter}\par
00172     {\cf19 while} ( fgets(file_in_buff, FILE_IN_BUFF_SIZE, file) != NULL )\{                                         {\cf20 // In case of file found, scan lines 'till null line (last one)}\par
00173       ++line_num;                                                                                           {\cf20 // Line number val upd}\par
00174       printf({\cf22 "%s%d)\\t%s%s"}, BU, line_num, OG, file_in_buff);                                                {\cf20 // Print line number and val fbk}\par
00175     \}\par
00176   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00177     fbk_err({\cf22 "Ops! Null-file found during file-read operation"});                                             {\cf20 // Print error fbk}\par
00178     perror({\cf22 "File read operation failed!"});                                                                  {\cf20 // Print perror fbk}\par
00179   \}\par
00180 \}\par
}
}
{\xe \v write_int_on_file\:lib_files.h}
{\xe \v lib_files.h\:write_int_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_int_on_file ({\b Fl}  {\i file}, const int  {\i num})}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to write integer on file.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i file} \cell }{File pointer on which to apply writing operation. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i num} \cell }{Integer value to write on file.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 55 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00055                                               \{                                                             {\cf20 // Function to write int on file}\par
00056   {\cf20 /* Body */}\par
00057   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00058     C_int res = fprintf(file, {\cf22 "%d"}, num);                                                                   {\cf20 // Insert number in file}\par
00059     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00060       fbk_err({\cf22 "Ops! Encountered error during int value file write operation"});                              {\cf20 // Print error fbk}\par
00061       perror({\cf22 "File write operation of int value, failed!"});                                                 {\cf20 // Print perror fbk}\par
00062     \}\par
00063   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00064     fbk_err({\cf22 "Ops! Null-file found during int value file write-operation"});                                  {\cf20 // Print error fbk}\par
00065     perror({\cf22 "File write operation of int value, failed!"});                                                   {\cf20 // Print perror fbk}\par
00066   \}\par
00067 \}\par
}
}
{\xe \v write_nl_on_file\:lib_files.h}
{\xe \v lib_files.h\:write_nl_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_nl_on_file ({\b Fl}  {\i file})}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to write new-line on file.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i file} \cell }{File pointer on which to apply writing operation.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 123 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00123                               \{                                                                             {\cf20 // Function to write new line on file}\par
00124   {\cf20 /* Body */}\par
00125   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00126     C_int res = fprintf(file, {\cf22 "\\n"});                                                                        {\cf20 // Insert new line in file}\par
00127     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00128       fbk_err({\cf22 "Ops! Encountered error during new line file write operation"});                               {\cf20 // Print error fbk}\par
00129       perror({\cf22 "File write operation of new line failed!"});                                                   {\cf20 // Print perror fbk}\par
00130     \}\par
00131   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00132     fbk_err({\cf22 "Ops! Null-file found during new line file-write operation"});                                   {\cf20 // Print error fbk}\par
00133     perror({\cf22 "File write operation of new line failed!"});                                                     {\cf20 // Print perror fbk}\par
00134   \}\par
00135 \}\par
}
}
{\xe \v write_sep_on_file\:lib_files.h}
{\xe \v lib_files.h\:write_sep_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_sep_on_file ({\b Fl}  {\i file}, const char  {\i sep})}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to write separator-char on file.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i file} \cell }{File pointer on which to apply writing operation. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i sep} \cell }{Separator char to write on file.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 101 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00101                                                \{                                                            {\cf20 // Function to write separator on file}\par
00102   {\cf20 /* Body */}\par
00103   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00104     C_int res = fprintf(file, {\cf22 "%c"}, sep);                                                                   {\cf20 // Insert separator in file}\par
00105     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00106       fbk_err({\cf22 "Ops! Encountered error during separator char file write operation"});                         {\cf20 // Print error fbk}\par
00107       perror({\cf22 "File write operation of separator char failed!"});                                             {\cf20 // Print perror fbk}\par
00108     \}\par
00109   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00110     fbk_err({\cf22 "Ops! Null-file found during separator char file-write operation"});                             {\cf20 // Print error fbk}\par
00111     perror({\cf22 "File write operation of separator char failed!"});                                               {\cf20 // Print perror fbk}\par
00112   \}\par
00113 \}\par
}
}
{\xe \v write_str_on_file\:lib_files.h}
{\xe \v lib_files.h\:write_str_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_str_on_file ({\b Fl}  {\i file}, const char *const  {\i str})}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to write string on file.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i file} \cell }{File pointer on which to apply writing operation. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i str} \cell }{String value to write on file.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 78 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00078                                                       \{                                                     {\cf20 // Function to write string on file}\par
00079   {\cf20 /* Body */}\par
00080   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00081     C_int res = fprintf(file, {\cf22 "%s"}, str);                                                                   {\cf20 // Insert string in file}\par
00082     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00083       fbk_err({\cf22 "Ops! Encountered error during string file write operation"});                                 {\cf20 // Print error fbk}\par
00084       perror({\cf22 "File write operation of string failed!"});                                                     {\cf20 // Print perror fbk}\par
00085     \}\par
00086   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00087     fbk_err({\cf22 "Ops! Null-file found during string file write-operation"});                                     {\cf20 // Print error fbk}\par
00088     perror({\cf22 "File write operation of string failed!"});                                                       {\cf20 // Print perror fbk}\par
00089   \}\par
00090 \}\par
}
}
{\xe \v write_tab_on_file\:lib_files.h}
{\xe \v lib_files.h\:write_tab_on_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void write_tab_on_file ({\b Fl}  {\i file})}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to write tab on file.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i file} \cell }{File pointer on which to apply writing operation.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 145 of file lib_files.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00145                                \{                                                                            {\cf20 // Function to write tab on file}\par
00146   {\cf20 /* Body */}\par
00147   {\cf19 if} (file != NULL)\{                                                                                        {\cf20 // Check file obj not null}\par
00148     C_int res = fprintf(file, {\cf22 "\\t"});                                                                        {\cf20 // Insert tab in file}\par
00149     {\cf19 if} (res < 1)\{                                                                                           {\cf20 // Check file write operation result}\par
00150       fbk_err({\cf22 "Ops! Encountered error during tab file write operation"});                                    {\cf20 // Print error fbk}\par
00151       perror({\cf22 "File write operation of tab failed!"});                                                        {\cf20 // Print perror fbk}\par
00152     \}\par
00153   \} {\cf19 else} \{                                                                                                  {\cf20 // If file obj is null}\par
00154     fbk_err({\cf22 "Ops! Null-file found during tab file-write operation"});                                        {\cf20 // Print error fbk}\par
00155     perror({\cf22 "File write operation of tab failed!"});                                                          {\cf20 // Print perror fbk}\par
00156   \}\par
00157 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v file_in_buff\:lib_files.h}
{\xe \v lib_files.h\:file_in_buff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char file_in_buff[{\b FILE_IN_BUFF_SIZE}]}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  File-input buffer string variabile (size defined with {\b FILE_IN_BUFF_SIZE} macro), mainly used by fgets() function in file-reading operations. }}\par
{
Definition at line 17 of file lib_files.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/files/lib_files.so File Reference\par \pard\plain 
{\tc\tcl2 \v lib/files/lib_files.so}
{\xe \v lib/files/lib_files.so}
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Files-library object file}  }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Files-library object file}  \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Library object file generated from {\b lib_files.c} during compiling operations.}  \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/graph/lib_graph.c File Reference\par \pard\plain 
{\tc\tcl2 \v lib/graph/lib_graph.c}
{\xe \v lib/graph/lib_graph.c}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Graph-library code file}  }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "lib_graph.h"}\par
{\f2 #include <limits.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b iaddr} ({\b C_int} i, {\b C_int} j, {\b C_int} lda)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b List_elem} * {\b allocate_new_list_elems} ({\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b add_elem_at_list_head} ({\b List} *list, {\b List_elem} *const el_to_add)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b add_elem_at_list_pos} ({\b List} *list, {\b List_elem} *const el_to_add, {\b C_int} pos)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b add_elem_at_list_tail} ({\b List} *list, {\b List_elem} *const el_to_add)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b free_list_elems} ({\b List} *list_head, {\b Verbose_mode} v_mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b allocate_new_arch} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b allocate_new_node} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b allocate_new_dijk_dataset_vect} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b Connection} * {\b allocate_new_nd_conn_vect} ({\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b reallocate_new_archs} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b reallocate_new_nodes} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b reallocate_dijk_dataset_vect} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b reallocate_nd_conn_vect} ({\b Connection} **nd_conn_vect, {\b C_int} size)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b Connection} * {\b not_an_node_conn} ({\b Node} *nd, int *const vect_size)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b print_min_paths} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b print_shortest_path} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b idx_by_name} ({\b Obj_type} object_type, {\b C_str} object_name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add_new_arch} ({\b C_str} name, {\b C_real} cost)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add_new_node} ({\b C_str} name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b connect_node_arch} ({\b C_str} ar_name, {\b C_str} nd_name, {\b Node_pos_in_arch} nd_pos, {\b Arch_pos_typ} ar_pos,...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dijkstra_alg} ({\b C_str} src_nd_name, {\b Verbose_mode} v_mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b buid_shortest_path} ({\b C_str} dest_nd_name, {\b Verbose_mode} v_mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b free_graph} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Real} {\b _REAL_MAX_} = __DBL_MAX__\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Constant variabile to indicate max real value, simulating +\u8734? in {\b dijkstra_alg()} function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ars_collect_size} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Archs collection vector size (size of {\b archs_collect_vect}). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b nds_collect_size} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Nodes collection vector size (size of {\b nodes_collect_vect}). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b min_pth_conn_vect_size} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Shortest-path connections vector size (size of {\b min_path_conn_vect}). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Arch} * {\b archs_collect_vect} = NULL\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Archs collection dynamic-memory vector (pointer to first vector memory cell allocated inside heap). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Node} * {\b nodes_collect_vect} = NULL\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Nodes collection dynamic-memory vector (pointer to first vector memory cell allocated inside heap). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Connection} * {\b min_path_conn_vect} = NULL\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Shortest-path connections dynamic-memory vector (pointer to first vector memory cell allocated inside heap). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b src_node_idx} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Library-variable description:}  Source node index, selected by-name using {\b idx_by_name()} function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b dest_node_idx} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Library-variable description:}  Destination node index, selected by-name using {\b idx_by_name()} function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Dijkstra_dataset} * {\b dijk_dataset_vect} = NULL\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Library-variable description:}  Dynamic-memory vector pointer containing a set of informations to be able to find and reconstruct min-cost path, later assigned to each node in {\b dijkstra_alg()} function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Byte} {\b realloc_flg} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Library-variable description:}  Reallocation flag to choose between callocs or reallocs in {\b dijkstra_alg()} and {\b buid_shortest_path()} functions {\i (0 = {\b dijkstra_alg()} not-called / 1 = {\b dijkstra_alg()} called / 2 = {\b dijkstra_alg()} called and {\b buid_shortest_path()} called)} . }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Graph-library code file}  \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i More info in {\b 'Graph library'}  section inside doxygen {\b 'Related pages'} .}  \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v add_elem_at_list_head\:lib_graph.c}
{\xe \v lib_graph.c\:add_elem_at_list_head}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void add_elem_at_list_head ({\b List} *  {\i list}, {\b List_elem} *const  {\i el_to_add}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Function to add a new list-element at list-head position.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i list} \cell }{List pointer (list-head pointer of pointer). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i el_to_add} \cell }{Pointer to list-element to add.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 95 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00095                                                                          \{                                  {\cf20 // Function to add a new element in list (head position)}\par
00096   {\cf20 /* Body */}\par
00097   {\cf19 if} (el_to_add != NULL)\{                                                                                   {\cf20 // Check element to add not null}\par
00098     List tmp_el_head = *list;                                                                               {\cf20 // Copy the old list head addr in tmp var}\par
00099     el_to_add->nxt = NULL;                                                                                  {\cf20 // Set new element as list tail (in case it's the only element in list - head&tail, otherwise connect it to the old head element)}\par
00100     *list = el_to_add;                                                                                      {\cf20 // Set list head addr equal to new elment addr}\par
00101     el_to_add->nxt = tmp_el_head;                                                                           {\cf20 // Reconnect the new element to the list}\par
00102   \} {\cf19 else} \{                                                                                                  {\cf20 // If specified position is less (or equal) than one}\par
00103     fbk_nl(1);  fbk_err({\cf22 "Error, element to add in list must be not null"});                                  {\cf20 // Print error fbk}\par
00104   \}\par
00105 \}\par
}
}
{\xe \v add_elem_at_list_pos\:lib_graph.c}
{\xe \v lib_graph.c\:add_elem_at_list_pos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void add_elem_at_list_pos ({\b List} *  {\i list}, {\b List_elem} *const  {\i el_to_add}, {\b C_int}  {\i pos}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Function to add a new list-element at list-specific position.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i list} \cell }{List pointer (list-head pointer of pointer). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i el_to_add} \cell }{Pointer to list-element to add. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i pos} \cell }{Position number in which to add the new list-element inside given list (non-zero index)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 117 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00117                                                                                    \{                        {\cf20 // Function to add a new element at a specific position of the list (non-zero index)}\par
00118   {\cf20 /* Body */}\par
00119   {\cf19 if} (pos >= 1 && el_to_add != NULL)\{                                                                       {\cf20 // Check specified postion greater (or equal) than one and element to add not null}\par
00120     {\cf19 if} (pos == 1 || *list == NULL)                                                                          {\cf20 // If specified position is equal to one or list is null (empty list)}\par
00121       add_elem_at_list_head(list, el_to_add);                                                               {\cf20 // Add element in list (head position)}\par
00122     {\cf19 else} \{                                                                                                  {\cf20 // Else if specified position is greater than one or list ain't null (list not empty)}\par
00123       List tmp_list = *list;                                                                                {\cf20 // Copy old list in tmp var}\par
00124       {\cf19 for} ({\cf18 int} idx = 1; idx < pos-1 && tmp_list->nxt != NULL; tmp_list = tmp_list->nxt, ++idx);             {\cf20 // Scroll list 'till specified position reached, or tail if position > elements in list}\par
00125       el_to_add->nxt = tmp_list->nxt;                                                                       {\cf20 // Once target position is reached, set new element connection equal to target position element connection}\par
00126       tmp_list->nxt = el_to_add;                                                                            {\cf20 // Set target position element connection equal to new element}\par
00127     \}\par
00128   \} {\cf19 else} \{                                                                                                  {\cf20 // If specified position is less (or equal) than one}\par
00129     fbk_nl(1);                                                                                              {\cf20 // New line fbk}\par
00130     fbk_err({\cf22 "Error, position in list must be greater than one (non-zero index), and element not null"});     {\cf20 // Print error fbk}\par
00131   \}\par
00132 \}\par
}
}
{\xe \v add_elem_at_list_tail\:lib_graph.c}
{\xe \v lib_graph.c\:add_elem_at_list_tail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void add_elem_at_list_tail ({\b List} *  {\i list}, {\b List_elem} *const  {\i el_to_add}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Function to add a new list-element at list-tail position.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i list} \cell }{List pointer (list-head pointer of pointer). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i el_to_add} \cell }{Pointer to list-element to add.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 143 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00143                                                                          \{                                  {\cf20 // Function to add a new element in list (tail position)}\par
00144   {\cf20 /* Body */}\par
00145   {\cf19 if} (el_to_add != NULL)\{                                                                                   {\cf20 // Check element to add not null}\par
00146     {\cf19 if} (*list != NULL)\{                                                                                     {\cf20 // If objects list has been already initialized}\par
00147       List tmp_list = *list;                                                                                {\cf20 // Copy old list in tmp var}\par
00148       {\cf19 for} (; tmp_list->nxt != NULL; tmp_list = tmp_list->nxt);                                              {\cf20 // Scroll the whole list 'till list tail, to find last element}\par
00149       el_to_add->nxt = NULL;                                                                                {\cf20 // Set new element as list tail}\par
00150       tmp_list->nxt = el_to_add;                                                                            {\cf20 // Cotnnect last element to the new element to add}\par
00151     \} {\cf19 else}                                                                                                  {\cf20 // Else if objects list ain't been already initialized}\par
00152       add_elem_at_list_head(list, el_to_add);                                                               {\cf20 // Add element in list (head position)}\par
00153   \} {\cf19 else} \{                                                                                                  {\cf20 // If specified position is less (or equal) than one}\par
00154     fbk_nl(1);  fbk_err({\cf22 "Error, element to add in list must be not null"});                                  {\cf20 // Print error fbk}\par
00155   \}\par
00156 \}\par
}
}
{\xe \v add_new_arch\:lib_graph.c}
{\xe \v lib_graph.c\:add_new_arch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void add_new_arch ({\b C_str}  {\i name}, {\b C_real}  {\i cost})}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to add a new arch inside {\b archs_collect_vect} (archs collection vector allocated inside heap).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i name} \cell }{New arch name. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i cost} \cell }{New arch cost value.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 489 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00489                                           \{                                                                 {\cf20 // Function to add new graph arch (arch allocated inside heap)}\par
00490   {\cf20 /* Body */}\par
00491   fbk_nl(1);  fbk_gn_pu({\cf22 "Adding new graph arch..."});                                                        {\cf20 // Adding new graph arch fbk}\par
00492   {\cf19 if} (cost > 0.0)\{                                                                                          {\cf20 // If cost is positive}\par
00493     {\cf19 if} (archs_collect_vect == NULL)                                                                         {\cf20 // Check arches collection vector, if null}\par
00494       allocate_new_arch();                                                                                  {\cf20 // Allocate a new graph arch inside arches collection vector (vect calloc)}\par
00495     {\cf19 else}                                                                                                    {\cf20 // Else if not null}\par
00496       reallocate_new_archs();                                                                               {\cf20 // Allocate a new graph arch inside arches collection vector (vect realloc)}\par
00497     {\cf19 if} (strlen(name) > 0 && strlen(name) < AR_STR_LEN)\{                                                     {\cf20 // Check arch name length consistency, if ok}\par
00498       strcpy(archs_collect_vect[ars_collect_size-1].name, name);  fbk_nl(1);                                {\cf20 // Copy name inside arch name var}\par
00499     \} {\cf19 else} \{                                                                                                {\cf20 // Else if arch name length consistency ain't ok}\par
00500       fbk_err({\cf22 "Error, invalid arch name size! Overriding arch name with arch number in collection"});        {\cf20 // Print error fbk}\par
00501       {\cf18 char} name_ovrd[AR_STR_LEN];                                                                           {\cf20 // Define new name to override input name}\par
00502       sprintf(name_ovrd, {\cf22 "%d"}, ars_collect_size);                                                           {\cf20 // Define override-name as arch number in arches collection vect}\par
00503       strcpy(archs_collect_vect[ars_collect_size-1].name, name_ovrd);                                       {\cf20 // Copy override-name inside arch name var}\par
00504     \}\par
00505     archs_collect_vect[ars_collect_size-1].cost = cost;                                                     {\cf20 // Define arch cost}\par
00506     archs_collect_vect[ars_collect_size-1].nd1 = NULL;                                                      {\cf20 // Set node1 connection to NULL}\par
00507     archs_collect_vect[ars_collect_size-1].nd2 = NULL;                                                      {\cf20 // Set node2 connection to NULL}\par
00508     fbk_gn_lbu_ye_str({\cf22 "New arch name"}, archs_collect_vect[ars_collect_size-1].name);                        {\cf20 // New graph arch name fbk}\par
00509     fbk_nl(1);  fbk_gn_lbu_ye_real({\cf22 "New arch cost"}, archs_collect_vect[ars_collect_size-1].cost);           {\cf20 // New graph arch cost fbk}\par
00510     fbk_nl(1);  fbk_gn_cy({\cf22 "New graph arch correctly added!\\n"});                                             {\cf20 // New graph arch correctly added fbk}\par
00511   \} {\cf19 else} \{                                                                                                  {\cf20 // Else if cost ain't positive}\par
00512     fbk_err({\cf22 "Ops! Encountered error during graph data management"});                                         {\cf20 // Error fbk}\par
00513     perror({\cf22 "Found error during arch object creation, its cost must be strictly positive!"});                 {\cf20 // Print perror fbk}\par
00514     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00515     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00516   \}\par
00517 \}\par
}
}
{\xe \v add_new_node\:lib_graph.c}
{\xe \v lib_graph.c\:add_new_node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void add_new_node ({\b C_str}  {\i name})}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to add a new node inside {\b nodes_collect_vect} (nodes collection vector allocated inside heap).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i name} \cell }{New node name.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 527 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00527                              \{                                                                              {\cf20 // Function to add new graph node (node allocated inside heap)}\par
00528   {\cf20 /* Body */}\par
00529   fbk_nl(1);  fbk_gn_pu({\cf22 "Adding new graph node..."});                                                        {\cf20 // Adding new graph node fbk}\par
00530   {\cf19 if} (nodes_collect_vect == NULL)                                                                           {\cf20 // Check nodes collection vector, if null}\par
00531     allocate_new_node();                                                                                    {\cf20 // Allocate a new graph node inside nodes collection vector (vect calloc)}\par
00532   {\cf19 else}                                                                                                      {\cf20 // Else if not null}\par
00533     reallocate_new_nodes();                                                                                 {\cf20 // Allocate a new graph node inside nodes collection vector (vect realloc)}\par
00534   {\cf19 if} (strlen(name) > 0 && strlen(name) < ND_STR_LEN)\{                                                       {\cf20 // Check node name length consistency, if ok}\par
00535     strcpy(nodes_collect_vect[nds_collect_size-1].name, name);  fbk_nl(1);                                  {\cf20 // Copy name inside node name var}\par
00536   \} {\cf19 else} \{                                                                                                  {\cf20 // Else if node name length consistency ain't ok}\par
00537     fbk_err({\cf22 "Error, invalid node name size! Overriding arch name with node number in collection"});          {\cf20 // Print error fbk}\par
00538     {\cf18 char} name_ovrd[ND_STR_LEN];                                                                             {\cf20 // Define new name to override input name}\par
00539     sprintf(name_ovrd, {\cf22 "%d"}, nds_collect_size);                                                             {\cf20 // Define override-name as node number in arches collection vect}\par
00540     strcpy(nodes_collect_vect[nds_collect_size-1].name, name_ovrd);                                         {\cf20 // Copy override-name inside node name var}\par
00541   \}\par
00542   nodes_collect_vect[nds_collect_size-1].archs_lst = NULL;                                                  {\cf20 // Set node arches list to NULL}\par
00543   nodes_collect_vect[nds_collect_size-1].dd = NULL;                                                         {\cf20 // Set node Dijkstra-dataset to NULL}\par
00544   fbk_gn_lbu_ye_str({\cf22 "New node name"}, nodes_collect_vect[nds_collect_size-1].name);                          {\cf20 // New graph arch name fbk}\par
00545   fbk_nl(1);  fbk_gn_cy({\cf22 "New graph node correctly added!\\n"});                                               {\cf20 // New graph node correctly added fbk}\par
00546 \}\par
}
}
{\xe \v allocate_new_arch\:lib_graph.c}
{\xe \v lib_graph.c\:allocate_new_arch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void allocate_new_arch (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Function to allocate a new graph-arch element in {\b archs_collect_vect} (inside heap, using calloc() function to initialize archs collection vector).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 189 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00189                                \{                                                                            {\cf20 // Function to allocate a new graph arch element}\par
00190   {\cf20 /* Body */}\par
00191   ars_collect_size = 0;                                                                                     {\cf20 // Make sure to have arches collection vect size set to zero}\par
00192   archs_collect_vect = calloc(1, {\cf17 sizeof}(Arch));                                                             {\cf20 // Tmp graph arch ptr creation to point at first allocated memo cell inside heap}\par
00193   {\cf19 if} (archs_collect_vect == NULL)\{                                                                          {\cf20 // Check calloc funct output to detect dynamic memory allocation errors}\par
00194     fbk_err({\cf22 "Ops! Encountered error during graph data management"});                                         {\cf20 // Error fbk}\par
00195     perror({\cf22 "Found error during graph arch dynamic memory allocation with calloc!"});                         {\cf20 // Print perror fbk}\par
00196     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00197     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00198   \} {\cf19 else}                                                                                                    {\cf20 // In case of dyn memo allocation OK}\par
00199     ++ars_collect_size;                                                                                     {\cf20 // Upd arches collection vect size}\par
00200 \}\par
}
}
{\xe \v allocate_new_dijk_dataset_vect\:lib_graph.c}
{\xe \v lib_graph.c\:allocate_new_dijk_dataset_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void allocate_new_dijk_dataset_vect (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Function to allocate Dijkstra's dataset vector inside heap, using calloc() function ({\b dijk_dataset_vect} initialization with the same size of {\b nodes_collect_vect}: {\b nds_collect_size}). Function called during {\b dijkstra_alg()}, to store Dijkstra's algorithm informations about each node in graph (each vector memory cell, will be associated to each {\b dijkstra_dataset} pointer inside every single {\b node} element).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 228 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00228                                             \{                                                               {\cf20 // Function to allocate Dijkstra-dataset vector}\par
00229   {\cf20 /* Body */}\par
00230   dijk_dataset_vect = calloc(({\cf18 size_t})nds_collect_size, {\cf17 sizeof}(Dijkstra_dataset));                           {\cf20 // Dijkstra-dataset vect ptr creation to point at first allocated memo cell inside heap}\par
00231   {\cf19 if} (dijk_dataset_vect == NULL || nds_collect_size == 0)\{                                                  {\cf20 // Check calloc funct output to detect dynamic memory allocation errors}\par
00232     fbk_err({\cf22 "Ops! Encountered error during graph data management"});                                         {\cf20 // Error fbk}\par
00233     perror({\cf22 "Found error during Dijkstra-dataset vector dynamic memory allocation with calloc!"});            {\cf20 // Print perror fbk}\par
00234     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00235     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00236   \}\par
00237 \}\par
}
}
{\xe \v allocate_new_list_elems\:lib_graph.c}
{\xe \v lib_graph.c\:allocate_new_list_elems}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b List_elem}* allocate_new_list_elems ({\b C_int}  {\i num}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Function to allocate defined number of new list elements inside heap.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i num} \cell }{Number of new list elements to allocate inside heap.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Allocated list elements pointer (address of the first one). \par
}}}{
Definition at line 74 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00074                                                     \{                                                       {\cf20 // Function to allocate new list elements (single/vect)}\par
00075   {\cf20 /* Body */}\par
00076   List_elem* tmp_list_elems = calloc(({\cf18 size_t})num, {\cf17 sizeof}(List_elem));                                       {\cf20 // Tmp list element ptr creation to point at first allocated memo cell inside heap}\par
00077   {\cf19 if} (tmp_list_elems == NULL || num == 0)\{                                                                  {\cf20 // Check calloc funct output to detect dynamic memory allocation errors}\par
00078     fbk_err({\cf22 "Ops! Encountered error during lists data management"});                                         {\cf20 // Error fbk}\par
00079     perror({\cf22 "Found error during list elements dynamic memory allocation with calloc!"});                      {\cf20 // Print perror fbk}\par
00080     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00081     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00082   \}\par
00083   {\cf19 return} tmp_list_elems;                                                                                    {\cf20 // Return tmp list elements, firtst allocated memo cell inside heap (pointer)}\par
00084 \}\par
}
}
{\xe \v allocate_new_nd_conn_vect\:lib_graph.c}
{\xe \v lib_graph.c\:allocate_new_nd_conn_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b Connection}* allocate_new_nd_conn_vect ({\b C_int}  {\i num}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Function to allocate a new node-connections vector inside heap, using calloc() function. The purpose of this vector is to contain informations about node's connection: connection arch and node on the other edge of the arch. Function used to reconstrunct min-cost path inside {\b buid_shortest_path()} and to analyze adjacent vertices in {\b dijkstra_alg()}, more precisely in {\b not_an_node_conn()} to find not-already analized connections.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i num} \cell }{Number of node-connections to allocate inside heap (vector size).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Connection pointer to the first memory cell allocated inside heap. \par
}}}{
Definition at line 249 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00249                                                        \{                                                    {\cf20 // Function to allocate new node connections vector}\par
00250   {\cf20 /* Body */}\par
00251   Connection* tmp_nd_conn_ptr = calloc(({\cf18 size_t})num, {\cf17 sizeof}(Connection));                                    {\cf20 // Tmp node connection ptr creation to point at first allocated memo cell inside heap}\par
00252   {\cf19 if} (tmp_nd_conn_ptr == NULL || num == 0)\{                                                                 {\cf20 // Check calloc funct output to detect dynamic memory allocation errors}\par
00253     fbk_err({\cf22 "Ops! Encountered error during graph data management"});                                         {\cf20 // Error fbk}\par
00254     perror({\cf22 "Found error during node connections vector dynamic memory allocation with calloc!"});            {\cf20 // Print perror fbk}\par
00255     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00256     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00257   \}\par
00258   {\cf19 return} tmp_nd_conn_ptr;                                                                                   {\cf20 // Return tmp node connection ptr, firtst allocated memo cell inside heap (pointer)}\par
00259 \}\par
}
}
{\xe \v allocate_new_node\:lib_graph.c}
{\xe \v lib_graph.c\:allocate_new_node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void allocate_new_node (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Function to allocate a new graph-node element in {\b nodes_collect_vect} (inside heap, using calloc() function to initialize nodes collection vector).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 208 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00208                                \{                                                                            {\cf20 // Function to allocate a new graph node element}\par
00209   {\cf20 /* Body */}\par
00210   nds_collect_size = 0;                                                                                     {\cf20 // Make sure to have nodes collection vect size set to zero}\par
00211   nodes_collect_vect = calloc(1, {\cf17 sizeof}(Node));                                                             {\cf20 // Tmp graph node ptr creation to point at first allocated memo cell inside heap}\par
00212   {\cf19 if} (nodes_collect_vect == NULL)\{                                                                          {\cf20 // Check calloc funct output to detect dynamic memory allocation errors}\par
00213     fbk_err({\cf22 "Ops! Encountered error during graph data management"});                                         {\cf20 // Error fbk}\par
00214     perror({\cf22 "Found error during graph node dynamic memory allocation with calloc!"});                         {\cf20 // Print perror fbk}\par
00215     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00216     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00217   \} {\cf19 else}                                                                                                    {\cf20 // In case of dyn memo allocation OK}\par
00218     ++nds_collect_size;                                                                                     {\cf20 // Upd nodes collection vect size}\par
00219 \}\par
}
}
{\xe \v buid_shortest_path\:lib_graph.c}
{\xe \v lib_graph.c\:buid_shortest_path}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void buid_shortest_path ({\b C_str}  {\i dest_nd_name}, {\b Verbose_mode}  {\i v_mode})}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
This function must be called once {\b dijkstra_alg()} has been executed at least one time, to initialize and allocate key parameters like Dijkstra-dataset, contained in {\b dijk_dataset_vect}. The aim of this function is to reconstruct shortest path towards specified destination node, from pre-defined source node (defined in last {\b dijkstra_alg()} function call). To do that, the function re-creates the shortest path backwards from destination to source node, and then converts it in forward path. Once shortest-foward path has been correctly built, it's printed by calling {\b print_shortest_path()} function, if advanced verbose mode has been enabled (setting 'v_mode' parameter to 'Y'). Destination node is selected by-name, looking for corresponding index inside {\b nodes_collect_vect} through {\b idx_by_name()} function. This routine, similarly to {\b dijkstra_alg()}, is also able to detect special cases like unreachble nodes and node equal to specified source node. The main reason of splitting shortest path detection in two functions: {\b dijkstra_alg()} and {\b buid_shortest_path()}, consists in being able to reconstruct multiple shortest paths towards different locations, executing Dijkstra's algorithm only one time (if source node is the same). So after calling {\b dijkstra_alg()}, it is possible to call {\b buid_shortest_path()} more times to reconstruct more shortest-paths from the same source node, towards different locations without re-executing Dijkstra's algorithm.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i dest_nd_name} \cell }{Destination node name. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i v_mode} \cell }{Advanced verbose mode (Y/N).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 712 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00712                                                                 \{                                           {\cf20 // Reconstruct shortest path to specified destination node from source node (pre-defined in Dijkstra's algorithm, min path connections vect allocated/reallocated inside heap) - Y/N for verbose mode}\par
00713   {\cf20 /* Body */}\par
00714   fbk_nl(1);  fbk_gn_pu({\cf22 "Building min cost path from pre-defined source to specified destination..."});      {\cf20 // Print reconstructin' shortest path from pre-defined source to specified destination fbk}\par
00715   {\cf19 if} (realloc_flg != 0)\{                                                                                    {\cf20 // If Dijkstra's algorithm has already been called at least once}\par
00716     {\cf20 // Print info fbks}\par
00717     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "--> Source node name"}, nodes_collect_vect[src_node_idx].name);           {\cf20 // Print src-nd name fbk}\par
00718     {\cf18 int} dest_nd_num = idx_by_name(ND, dest_nd_name);                                                        {\cf20 // Get destination node idx by-name}\par
00719     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "--> Destination node name"}, dest_nd_name);                               {\cf20 // Print dest-nd name fbk}\par
00720     {\cf19 if} (dest_nd_num >= 0)\{                                                                                  {\cf20 // Check error conditions ok}\par
00721       dest_node_idx = dest_nd_num;                                                                          {\cf20 // Set/upd destination node idx lib-var val}\par
00722       {\cf19 if} (nodes_collect_vect[dest_nd_num].dd->min_path_cost < _REAL_MAX_ && dest_nd_num != src_node_idx)\{   {\cf20 // If destination node is reachble from pre-defined source node}\par
00723         fbk_nl(1);                                                                                          {\cf20 // Print new-line fbk}\par
00724         fbk_gn_lbu_ye_real({\cf22 "Min path cost to node"}, nodes_collect_vect[dest_nd_num].dd->min_path_cost);     {\cf20 // Print min path cost to reach destination node from pre-defined source node fbk}\par
00725       \} {\cf19 else} {\cf19 if} (dest_nd_num == src_node_idx)\{                                                              {\cf20 // Else if destination node memo addr corresponds to the source node memo addr}\par
00726         fbk_nl(1);                                                                                          {\cf20 // Print new-line fbk}\par
00727         fbk_gn_lbu_ye_str({\cf22 "Min path cost to node"}, {\cf22 "Destination corresponds to pre-defined source node!"});  {\cf20 // Print destination node correspondin' to the pre-defined source node fbk}\par
00728       \} {\cf19 else} \{                                                                                              {\cf20 // Else if destination node is unreachble from pre-defined source node}\par
00729         fbk_nl(1);                                                                                          {\cf20 // Print new-line fbk}\par
00730         fbk_gn_lbu_ye_str({\cf22 "Min path cost to node"}, {\cf22 "Destination unreachble from pre-defined source node!"}); {\cf20 // Print destination node unreachble fbk}\par
00731       \}\par
00732       {\cf20 // Find min-cost path archs & nodes goin' backward from destination to source node}\par
00733       Graph_node tmp_nd = &nodes_collect_vect[dest_nd_num];                                                 {\cf20 // Init tmp node var to reconstruct min-cost path backwards}\par
00734       List_elem* tmpl = NULL;                                                                               {\cf20 // Def tmp list ptr var (for archs) to reconstruct min-cost path backwards}\par
00735       {\cf19 if} (min_pth_conn_vect_size != 0)                                                                      {\cf20 // If min-cost paths vector size ain't zero}\par
00736         min_pth_conn_vect_size = 0;                                                                         {\cf20 // Make it zero}\par
00737       {\cf19 while} (tmp_nd != NULL)\{                                                                               {\cf20 // Scroll min-cost path backwars 'till src node}\par
00738         {\cf19 if} (realloc_flg == 0)\{                                                                              {\cf20 // If realloc flag ain't been set}\par
00739           min_path_conn_vect = allocate_new_nd_conn_vect(++min_pth_conn_vect_size);                         {\cf20 // Allocate (inside heap) a new min path connections vector}\par
00740           ++realloc_flg;                                                                                    {\cf20 // And then upd realloc flag val to use reallocs instead of callocs 'till "free_graph()" funct call}\par
00741         \} {\cf19 else}                                                                                              {\cf20 // Else if realloc flag has already been set}\par
00742           reallocate_nd_conn_vect(&min_path_conn_vect, ++min_pth_conn_vect_size);                           {\cf20 // Reallocate (inside heap) the min path connections vector}\par
00743         tmpl = tmp_nd->archs_lst;                                                                           {\cf20 // Init tmp archs list ptr var}\par
00744         {\cf19 for} (; tmpl != NULL; tmpl = tmpl->nxt)\{                                                             {\cf20 // Scroll min-cost parh node connection archs list to find min-cost path connection arch}\par
00745           {\cf19 if} ((tmp_nd == tmpl->ar->nd1 && tmpl->ar->nd2 == tmp_nd->dd->prev_nd) ||\par
00746               (tmp_nd == tmpl->ar->nd2 && tmpl->ar->nd1 == tmp_nd->dd->prev_nd))\{                           {\cf20 // Min-cost path connection arch detectin' cond}\par
00747             (min_path_conn_vect+iaddr(V, min_pth_conn_vect_size-1, min_pth_conn_vect_size))->ar = tmpl->ar; {\cf20 // Save arch ptr val inside min path connections vector (min-path connection arch)}\par
00748           \}\par
00749         \}\par
00750         (min_path_conn_vect+iaddr(V, min_pth_conn_vect_size-1, min_pth_conn_vect_size))->nd = tmp_nd;       {\cf20 // Save node ptr val inside min path connections vector (min-path connection node)}\par
00751         tmp_nd = tmp_nd->dd->prev_nd;                                                                       {\cf20 // Upd tmp node var to reconstruct min-cost path backwards}\par
00752       \}\par
00753       {\cf20 // Swap elements to obtain shortest path (backward-to-forward path conversion)}\par
00754       Connection tmp_conn;                                                                                  {\cf20 // Tmp connection var to swap connections}\par
00755       {\cf19 for} ({\cf18 int} i = 0; i < min_pth_conn_vect_size/2; ++i)\{                                                   {\cf20 // Half min path connections vector scrollin' FOR cycle}\par
00756         tmp_conn = min_path_conn_vect[i];                                                                   {\cf20 // Define tmp var to swap connections}\par
00757         min_path_conn_vect[i] = min_path_conn_vect[min_pth_conn_vect_size-1-i];                             {\cf20 // Swap-step1}\par
00758         min_path_conn_vect[min_pth_conn_vect_size-i-1] = tmp_conn;                                          {\cf20 // Swap-step2}\par
00759       \}\par
00760       {\cf20 // Print shortest path from pre-defined source node to specified destination node}\par
00761       {\cf19 if} (v_mode == Y)                                                                                      {\cf20 // If verbose mode is enabled, print fbks}\par
00762         print_shortest_path();                                                                              {\cf20 // Print shortest path funct call}\par
00763       fbk_nl(1);  fbk_gn_cy({\cf22 "Destination node min cost path correctly identified!\\n"});                      {\cf20 // Print destination node min cost path correctly identified fbk}\par
00764     \} {\cf19 else}                                                                                                  {\cf20 // If error conditions ain't ok}\par
00765       fbk_err({\cf22 "Error, not able to find destination node min cost path with Dijkstra's algorithm"});          {\cf20 // Print error fbk}\par
00766   \} {\cf19 else}                                                                                                    {\cf20 // Else if Dijkstra's algorithm ain't been called}\par
00767     fbk_err({\cf22 "Error, min path can be reconstructed only after having called Dijkstra's algorithm!"});         {\cf20 // Print error fbk}\par
00768 \}\par
}
}
{\xe \v connect_node_arch\:lib_graph.c}
{\xe \v lib_graph.c\:connect_node_arch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void connect_node_arch ({\b C_str}  {\i ar_name}, {\b C_str}  {\i nd_name}, {\b Node_pos_in_arch}  {\i nd_pos}, {\b Arch_pos_typ}  {\i ar_pos},   {\i ...})}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to create bidirectional connection between specified arch and node in defined positions, using {\b node_pos_in_arch} and {\b arch_pos_typ} enums. Arch and node are selected by-name, looking for corresponding index inside {\b archs_collect_vect} and {\b nodes_collect_vect} through {\b idx_by_name()} function.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ar_name} \cell }{Arch name to connect. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i nd_name} \cell }{Node name to connect. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i nd_pos} \cell }{Node position in arch. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ar_pos} \cell }{Acrch position in node connection-archs list. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i lst_pos} \cell }{{\b (optional parameter)} , required when 'ar_pos' parameter is equal to {\b LIST_POS} (specify list position if specific list position adding mode has been selected).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 561 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00561                                                                                                        \{    {\cf20 // Function to connect arch-node in graph (new arch list element allocated inside heap, opt param --> arch pos in arches list, non-zero index)}\par
00562   {\cf20 /* Body */}\par
00563   fbk_nl(1);  fbk_gn_pu({\cf22 "Creating bidirectional connection between node and arch..."});                      {\cf20 // Creatin' bidirectional connection between node and arch}\par
00564   {\cf18 int} ar_num = idx_by_name(AR, ar_name);                                                                    {\cf20 // Get arch idx by-name}\par
00565   {\cf18 int} nd_num = idx_by_name(ND, nd_name);                                                                    {\cf20 // Get node idx by-name}\par
00566   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Working on node"}, nd_name);                                                {\cf20 // Print node name fbk}\par
00567   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Working on arch"}, ar_name);                                                {\cf20 // Print arch name fbk}\par
00568   {\cf18 int} lst_pos = 0;                                                                                          {\cf20 // List position in which arch must be placed in node conn. arches list}\par
00569   {\cf20 // Function optional parameters management}\par
00570   {\cf19 if} (ar_pos == LIST_POS)\{                                                                                  {\cf20 // If selected arch position type in list is specific position, read list position optional parameter}\par
00571     va_list args_lst;                                                                                       {\cf20 // Function optional parameters list int}\par
00572     va_start(args_lst, ar_pos);                                                                             {\cf20 // Define optional params list startin' point}\par
00573     lst_pos = va_arg(args_lst, {\cf18 int});                                                                        {\cf20 // Read the first optional parameter in funct opt params list (= define list position)}\par
00574   \}\par
00575   {\cf19 if} (nd_num >= 0 && ar_num >= 0 && ((ar_pos == LIST_POS && lst_pos >= 1) || ar_pos != LIST_POS))\{          {\cf20 // Check error conditions ok}\par
00576     {\cf20 // Assign node to arch}\par
00577     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Connecting node to"}, node_pos_in_arch_str[nd_pos]);                      {\cf20 // Connectin' node to arch fbk}\par
00578     {\cf19 switch} (nd_pos)\{                                                                                        {\cf20 // Node assignin' position in arch switch-case (where to assign node in arch)}\par
00579       {\cf19 case} ARCH_ND1:                                                                                        {\cf20 // Case: assign node to arch node1 position}\par
00580         archs_collect_vect[ar_num].nd1 = &nodes_collect_vect[nd_num];                                       {\cf20 // Assign node to arch node1 pos}\par
00581         {\cf19 break};\par
00583       {\cf19 case} ARCH_ND2:                                                                                        {\cf20 // Case: assign node to arch node2 position}\par
00584         archs_collect_vect[ar_num].nd2 = &nodes_collect_vect[nd_num];                                       {\cf20 // Assign node to arch node2 pos}\par
00585         {\cf19 break};\par
00587       {\cf19 default}:                                                                                              {\cf20 // Unknown case}\par
00588         fbk_err({\cf22 "Error, bad parameter value! A function got an unexpected patameter value"});                {\cf20 // Print error fbk}\par
00589         perror({\cf22 "Wrong \\"nd_pos\\" parameter value passsed to \\"connect_node_arch\\" function!"});              {\cf20 // Print perror fbk}\par
00590         {\cf19 break};\par
00591     \}\par
00592     {\cf20 // Assign arch to node}\par
00593     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Connecting arch to node connection archs"}, arch_pos_typ_str[ar_pos]);    {\cf20 // Connectin' node to arch fbk}\par
00594     List_elem* tmp_el = allocate_new_list_elems(1);                                                         {\cf20 // Tmp list element ptr creation}\par
00595     tmp_el->ar = &archs_collect_vect[ar_num];                                                               {\cf20 // Tmp list element ptr def with input arch memo cell addr}\par
00596     {\cf19 switch} (ar_pos)\{                                                                                        {\cf20 // Arch assignin' position type in node arches list switch-case (where to assign arch in node arches connections list) switch-case}\par
00597       {\cf19 case} LIST_HEAD:                                                                                       {\cf20 // Case: assign arch to node arches connections list (head position)}\par
00598         add_elem_at_list_head(&nodes_collect_vect[nd_num].archs_lst, tmp_el);                               {\cf20 // Assign arch (in tmp list element) to the specified node conn. arches list (head position)}\par
00599         {\cf19 break};\par
00601       {\cf19 case} LIST_POS:                                                                                        {\cf20 // Case: assign arch to node arches connections list (specific position, pos from optional funct param)}\par
00602         fbk_nl(1);  fbk_gn_lbu_ye_int({\cf22 "Specific list position number"}, lst_pos);                            {\cf20 // Specific list position num fbk}\par
00603         add_elem_at_list_pos(&nodes_collect_vect[nd_num].archs_lst, tmp_el, lst_pos);                       {\cf20 // Assign arch (in tmp list element) to the specified node conn. arches list (specific position, non-zero index)}\par
00604         {\cf19 break};\par
00606       {\cf19 case} LIST_TAIL:                                                                                       {\cf20 // Case: assign arch to node arches connections list (tail position)}\par
00607         add_elem_at_list_tail(&nodes_collect_vect[nd_num].archs_lst, tmp_el);                               {\cf20 // Assign arch (in tmp list element) to the specified node conn. arches list (tail position)}\par
00608         {\cf19 break};\par
00610       {\cf19 default}:                                                                                              {\cf20 // Unknown case}\par
00611         fbk_err({\cf22 "Error, bad parameter value! A function got an unexpected patameter value"});                {\cf20 // Print error fbk}\par
00612         perror({\cf22 "Wrong \\"ar_pos\\" parameter value passsed to \\"connect_node_arch\\" function!"});              {\cf20 // Print perror fbk}\par
00613         {\cf19 break};\par
00614     \}\par
00615     fbk_nl(1);  fbk_gn_cy({\cf22 "Bidirectional node-arch connetion correctly created!\\n"});                        {\cf20 // Bidirectional node-arch connection correctly created fbk}\par
00616   \} {\cf19 else} \{                                                                                                  {\cf20 // If error conditions ain't ok}\par
00617     fbk_err({\cf22 "Error, not able to create arch-node connection! Connection not created"});                      {\cf20 // Print error fbk}\par
00618     {\cf19 if} (ar_pos == LIST_POS && lst_pos < 1)                                                                  {\cf20 // List pos err detect cond}\par
00619       fbk_err({\cf22 "Error casued by specific list position flag enabled and invalid position value"});            {\cf20 // Print error fbk}\par
00620   \}\par
00621 \}\par
}
}
{\xe \v dijkstra_alg\:lib_graph.c}
{\xe \v lib_graph.c\:dijkstra_alg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dijkstra_alg ({\b C_str}  {\i src_nd_name}, {\b Verbose_mode}  {\i v_mode})}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to apply Dijkstra's algorithm from specified source node, to find min-cost path towards each oder node in graph, working on Dijkstra-dataset info pointers inside each node data-structure (but allocated inside heap with {\b dijk_dataset_vect}). In this way, Dijkstra-dataset memory inside heap is allocated only if, and when needed; in addition, {\b buid_shortest_path()} function can be called multiple times, reconstructing different shortest-paths starting from pre-defined source node (defined in last {\b dijkstra_alg()} function call) without continuously calling Dijstra's algorithm. Source node is selected by-name, looking for corresponding index inside {\b nodes_collect_vect} through {\b idx_by_name()} function. In addition, if advanced verbose mode has been enabled (setting 'v_mode' parameter to 'Y'), {\b print_min_paths()} sub-routine is called to print further informations. Dijkstra's algorithm is also able to detect special cases such as unreachble nodes and node equal to specified source node.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i src_nd_name} \cell }{Source node name. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i v_mode} \cell }{Advanced verbose mode (Y/N).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 637 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00637                                                          \{                                                  {\cf20 // Dijkstra's alg to find min graph-path btwn source and each destination node (Dijkstra-dataset vect allocated/reallocated inside heap) - Y/N for verbose mode}\par
00638   {\cf20 /* Body */}\par
00639   fbk_nl(1);  fbk_gn_pu({\cf22 "Looking for min path costs from specified source with Dijkstra's algorithm..."});   {\cf20 // Print lookin' 4 shortest path btwn spec src and each dest nd fbk}\par
00640   {\cf18 int} src_nd_num = idx_by_name(ND, src_nd_name);                                                            {\cf20 // Get source node idx by-name}\par
00641   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Source node name"}, src_nd_name);                                           {\cf20 // Print source node name}\par
00642   {\cf19 if} (src_nd_num >= 0)\{                                                                                     {\cf20 // Check error conditions ok}\par
00643     {\cf20 // Algorithm inits}\par
00644     {\cf18 int} min_cost_idx = 0;                                                                                   {\cf20 // Min cost node idx in dataset var init}\par
00645     Real min_cost_val = 0.0;                                                                                {\cf20 // Min cost node val in dataset var init}\par
00646     {\cf18 int} nan_nd_conn_vect_size = 0;                                                                          {\cf20 // Node (non-analyzed) connections vector size var to store selected node non-analyzed connections init}\par
00647     Real new_cost = 0.0;                                                                                    {\cf20 // New cost var init}\par
00648     Connection* nan_nd_conn_vect = NULL;                                                                    {\cf20 // Node (non-analyzed) connections vector ptr var decl}\par
00649     {\cf19 if} (realloc_flg == 0)\{                                                                                  {\cf20 // If realloc flag ain't set}\par
00650       allocate_new_dijk_dataset_vect();                                                                     {\cf20 // Dijkstra-dataset vect init (vector allocated inside heap)}\par
00651       ++realloc_flg;                                                                                        {\cf20 // Set realloc flg}\par
00652     \} {\cf19 else}                                                                                                  {\cf20 // Else if realloc flag has been set}\par
00653       reallocate_dijk_dataset_vect();                                                                       {\cf20 // Dijkstra-dataset vect realloc (vector reallocated inside heap)}\par
00654     {\cf19 for} ({\cf18 int} i = 0; i < nds_collect_size; ++i)\{                                                             {\cf20 // Inits FOR cycle}\par
00655       nodes_collect_vect[i].dd = &dijk_dataset_vect[i];                                                     {\cf20 // Define and init nodes Dijkstra-datasets}\par
00656       nodes_collect_vect[i].dd->prev_nd = NULL;                                                             {\cf20 // Node dataset prev node init}\par
00657       nodes_collect_vect[i].dd->an_flg = 0;                                                                 {\cf20 // Node dataset analyzed flag val preset (as not analyzed)}\par
00658       {\cf19 if} (i != src_nd_num)                                                                                  {\cf20 // If node is different from source node}\par
00659         nodes_collect_vect[i].dd->min_path_cost = _REAL_MAX_;                                               {\cf20 // Init unknown min costs from source node (preset val --> +inf)}\par
00660       {\cf19 else}                                                                                                  {\cf20 // Else if node ain't different from source node}\par
00661         nodes_collect_vect[i].dd->min_path_cost = 0;                                                        {\cf20 // Init source-to-source cost (preset val --> zero)}\par
00662     \}\par
00663     src_node_idx = src_nd_num;                                                                              {\cf20 // Set/upd source node idx lib-var val}\par
00664     {\cf20 // Algorithm loop}\par
00665     {\cf19 for} ({\cf18 int} j = 0; j < nds_collect_size-1; ++j)\{                                                           {\cf20 // Main algo loop}\par
00666       {\cf20 // Select node with min-cost path}\par
00667       min_cost_val = _REAL_MAX_;                                                                            {\cf20 // Min cost node val in dataset upd}\par
00668       {\cf19 for} ({\cf18 int} k = 0; k < nds_collect_size; ++k)\{                                                           {\cf20 // Scroll the entire nodes collection 2 detect min cost path node}\par
00669         {\cf19 if} (nodes_collect_vect[k].dd->an_flg == 0 &&\par
00670             nodes_collect_vect[k].dd->min_path_cost < min_cost_val)\{                                        {\cf20 // Min cost path node detectin' cond (min val and node not alredy analized)}\par
00671           min_cost_val = nodes_collect_vect[k].dd->min_path_cost;                                           {\cf20 // If detectin' cond is met, upd min cost node val}\par
00672           min_cost_idx = k;                                                                                 {\cf20 // And upd min cost node idx}\par
00673         \}\par
00674       \}\par
00675       ++nodes_collect_vect[min_cost_idx].dd->an_flg;                                                        {\cf20 // Mark selected node as alredy analized b4 processin' it}\par
00676       {\cf20 // Find non-analyzed connections of selected node}\par
00677       nan_nd_conn_vect_size = 0;                                                                            {\cf20 // Node (non-analyzed) connections vector size var to store selected node non-analyzed connections (rst)}\par
00678       nan_nd_conn_vect = not_an_node_conn(&nodes_collect_vect[min_cost_idx], &nan_nd_conn_vect_size);       {\cf20 // Define selected node non-analyzed connections vect (vector allocated inside heap)}\par
00679       {\cf19 for} ({\cf18 int} l = 0; l < nan_nd_conn_vect_size; ++l)\{                                                      {\cf20 // Scroll selected node non-analyzed connections vect}\par
00680         new_cost = nodes_collect_vect[min_cost_idx].dd->min_path_cost+nan_nd_conn_vect[l].ar->cost;         {\cf20 // New cost val upd}\par
00681         {\cf20 // Upd min path cost and previous node in shortest path}\par
00682         {\cf19 if} (new_cost < nan_nd_conn_vect[l].nd->dd->min_path_cost)\{                                          {\cf20 // In case new cost val is less than min cost val}\par
00683           nan_nd_conn_vect[l].nd->dd->min_path_cost = new_cost;                                             {\cf20 // Upd min cost val}\par
00684           nan_nd_conn_vect[l].nd->dd->prev_nd = &nodes_collect_vect[min_cost_idx];                          {\cf20 // Upd previous min path node}\par
00685         \}\par
00686       \}\par
00687       {\cf19 if} (nan_nd_conn_vect != NULL)                                                                         {\cf20 // If node non-analyzed connections vector was correctly defined}\par
00688         free(nan_nd_conn_vect);                                                                             {\cf20 // Free node non-analyzed connections vector allocated inside heap}\par
00689     \}\par
00690     {\cf20 // Print each min path cost to reach every single accessible node from specified source-node}\par
00691     {\cf19 if} (v_mode == Y)                                                                                        {\cf20 // If verbose mode is enabled, print fbks}\par
00692       print_min_paths();                                                                                    {\cf20 // Print min paths funct call}\par
00693     fbk_nl(1);  fbk_gn_cy({\cf22 "Min path costs correctly found!\\n"});                                             {\cf20 // Print min path costs correctly found fbk}\par
00694   \} {\cf19 else}                                                                                                    {\cf20 // If error conditions ain't ok}\par
00695     fbk_err({\cf22 "Error, not able to find min path costs with Dijkstra's algorithm"});                            {\cf20 // Print error fbk}\par
00696 \}\par
}
}
{\xe \v free_graph\:lib_graph.c}
{\xe \v lib_graph.c\:free_graph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void free_graph ()}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to deallocate graph-structure and clear all allocated memory inside heap.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 776 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00776                  \{                                                                                          {\cf20 // Function to free graph allocated memory inside heap}\par
00777   {\cf20 /* Body */}\par
00778   fbk_nl(1);  fbk_gn_pu({\cf22 "Clearing the whole graph structure..."});                                           {\cf20 // Clearing the whole graph from heap fbk}\par
00779   {\cf19 for} ({\cf18 int} i = 0; i < nds_collect_size; ++i)                                                                {\cf20 // Graph nodes scrollin' FOR cycle}\par
00780     {\cf19 if} (nodes_collect_vect[i].archs_lst != NULL)\{                                                           {\cf20 // If node arches list ain't null}\par
00781       free_list_elems(&nodes_collect_vect[i].archs_lst, N);                                                 {\cf20 // Free graph arches list elems associated to each graph node - NO --> without verbose mode}\par
00782       nodes_collect_vect[i].archs_lst = NULL;                                                               {\cf20 // Set node arches list to null}\par
00783     \}\par
00784   {\cf19 if} (archs_collect_vect != NULL)\{                                                                          {\cf20 // If arches collection vector needs to be cleared from heap}\par
00785     free(archs_collect_vect);                                                                               {\cf20 // Free arches collection vector allocated memo inside heap}\par
00786     archs_collect_vect = NULL;                                                                              {\cf20 // Set arches collection vector to null}\par
00787   \}\par
00788   {\cf19 if} (nodes_collect_vect != NULL)\{                                                                          {\cf20 // If nodes collection vector needs to be cleared from heap}\par
00789     free(nodes_collect_vect);                                                                               {\cf20 // Free nodes collection vector allocated memo inside heap}\par
00790     nodes_collect_vect = NULL;                                                                              {\cf20 // Set nodes collection vector to null}\par
00791   \}\par
00792   {\cf19 if} (dijk_dataset_vect != NULL)\{                                                                           {\cf20 // If Dijkstra-dataset vector needs to be cleared from heap}\par
00793     free(dijk_dataset_vect);                                                                                {\cf20 // Free Dijkstra-dataset vector allocated memo inside heap}\par
00794     dijk_dataset_vect = NULL;                                                                               {\cf20 // Set Dijkstra-dataset vector to null}\par
00795   \}\par
00796   {\cf19 if} (min_path_conn_vect != NULL)\{                                                                          {\cf20 // If min path connections vector needs to be cleared from heap}\par
00797     free(min_path_conn_vect);                                                                               {\cf20 // Free min path connections vector allocated memo inside heap}\par
00798     min_path_conn_vect = NULL;                                                                              {\cf20 // Set min path connections vector to null}\par
00799   \}\par
00800   ars_collect_size = 0;                                                                                     {\cf20 // Set graph arches number back to zero}\par
00801   nds_collect_size = 0;                                                                                     {\cf20 // Set graph nodes number back to zero}\par
00802   min_pth_conn_vect_size = 0;                                                                               {\cf20 // Set min path connections vector size back to zero}\par
00803   realloc_flg = 0;                                                                                          {\cf20 // Realloc flag rst}\par
00804   fbk_nl(1);  fbk_gn_cy({\cf22 "Graph structure correctly erased!\\n"});                                             {\cf20 // Graph structure correctly created erased from heap fbk}\par
00805 \}\par
}
}
{\xe \v free_list_elems\:lib_graph.c}
{\xe \v lib_graph.c\:free_list_elems}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void free_list_elems ({\b List} *  {\i list_head}, {\b Verbose_mode}  {\i v_mode}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Function to clear an entire list (or sub-list) from heap, starting from list/sublist-head element position.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i list_head} \cell }{List/sublist-head pointer (pointer of pointer) from which deallocating list elements until list-tail. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i v_mode} \cell }{Advanced verbose mode (Y/N).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 167 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00167                                                                  \{                                          {\cf20 // Function to free allocated elements inside heap, startin' from specified list (or sub-list) head, 'till list (or sub-list) tail - Y/N for verbose mode}\par
00168   {\cf20 /* Body */}\par
00169   List tmp_list_head = *list_head;                                                                          {\cf20 // Tmp var to clear allocated memo inside heap (list element)}\par
00170   List tmp_nxt_el = *list_head;                                                                             {\cf20 // Tmp var to store next element in list memo inside heap}\par
00171   {\cf19 for} ({\cf18 int} i = 0; tmp_list_head != NULL; tmp_list_head = tmp_nxt_el, ++i)\{                                  {\cf20 // List (or sub-list) scrollin' FOR cycle to clear heap allocated memo}\par
00172     {\cf19 if} (tmp_list_head != NULL)\{                                                                             {\cf20 // If allocated element ain't null}\par
00173       {\cf19 if} (v_mode == Y)\{                                                                                     {\cf20 // If verbose mode is enabled, print fbk}\par
00174         fbk_nl(1);  fbk_gn_lbu_ye_int({\cf22 "Removing allocated list element from heap, element number"}, i+1);    {\cf20 // Print removing element from heap fbk}\par
00175       \}\par
00176       tmp_nxt_el = tmp_list_head->nxt;                                                                      {\cf20 // Updn ext element in list var}\par
00177       free(tmp_list_head);                                                                                  {\cf20 // Clear allocated elements}\par
00178     \}\par
00179   \}\par
00180   *list_head = NULL;                                                                                        {\cf20 // Set elements list (or sub-list) head to null}\par
00181 \}\par
}
}
{\xe \v iaddr\:lib_graph.c}
{\xe \v lib_graph.c\:iaddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int iaddr ({\b C_int}  {\i i}, {\b C_int}  {\i j}, {\b C_int}  {\i lda}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Function to manage vectors, arrays and pointers addressing (treat all as 1d array = vector), defined using {\b vect_coords} enum.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i i} \cell }{Line number (starting from 0 since C is a zero-index language). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i j} \cell }{Column number (starting from 0 since C is a zero-index language). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i lda} \cell }{Leading-dimension (Max number of columns for each matrix line, since the C languace follows line-indexing to allocate memory cells for matrix).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Vector/pointer index number {\i (-1 = error)} . \par
}}}{
Definition at line 53 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00053                                              \{                                                              {\cf20 // Arrays/vectors memo addressing}\par
00054   {\cf20 /* Body */}\par
00055   {\cf19 if} (i >= 0 && j >= 0 && lda >= 0)                                                                         {\cf20 // Check params ok}\par
00056     {\cf19 return} (i*lda)+j;                                                                                       {\cf20 // Return index number}\par
00057   {\cf19 else} \{                                                                                                    {\cf20 // If params ain't ok}\par
00058     fbk_err({\cf22 "Ops! Encountered error during arrays data management"});                                        {\cf20 // Error fbk}\par
00059     perror({\cf22 "Found error during array-elements access with 'iaddr' function! Parameters must be positive!"}); {\cf20 // Print perror fbk}\par
00060     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00061     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00062     {\cf19 return} -1;                                                                                              {\cf20 // Random return to avoid compile-errors}\par
00063   \}\par
00064 \}\par
}
}
{\xe \v idx_by_name\:lib_graph.c}
{\xe \v lib_graph.c\:idx_by_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int idx_by_name ({\b Obj_type}  {\i object_type}, {\b C_str}  {\i object_name})}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to get object (arch or node) vector index by name (inside {\b archs_collect_vect} or {\b nodes_collect_vect}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i object_type} \cell }{Object type, defined through {\b obj_type} enum-typedef value. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i object_name} \cell }{Object name string (target name).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Object (ARCH/NODE) vector index by name {\i (Special cases: -1 = No match found / -2 = Error)} . \par
}}}{
Definition at line 453 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00453                                                         \{                                                   {\cf20 // Function to get object (arch/node) vector index by name (-1 = No match found / -2 = Error)}\par
00454   {\cf20 /* Body */}\par
00455   {\cf18 int} match_found = -1;                                                                                     {\cf20 // Match found idx (-1 = No match found / -2 = Error)}\par
00456   {\cf19 switch} (object_type)\{                                                                                     {\cf20 // Object type switch-case}\par
00457     {\cf19 case} AR:                                                                                                {\cf20 // Object type = arch}\par
00458       {\cf19 for} ({\cf18 int} i = 0; i < ars_collect_size; ++i)                                                            {\cf20 // Search match by-name in arches collection vector}\par
00459         {\cf19 if} (strcmp(object_name, archs_collect_vect[i].name) == 0)                                           {\cf20 // Match detecting condition}\par
00460           match_found = i;                                                                                  {\cf20 // Retun match idx in vect}\par
00461       {\cf19 break};\par
00463     {\cf19 case} ND:                                                                                                {\cf20 // Object type = node}\par
00464       {\cf19 for} ({\cf18 int} j = 0; j < nds_collect_size; ++j)                                                            {\cf20 // Search match by-name in nodes collection vector}\par
00465         {\cf19 if} (strcmp(object_name, nodes_collect_vect[j].name) == 0)                                           {\cf20 // Match detecting condition}\par
00466           match_found = j;                                                                                  {\cf20 // Retun match idx in vect}\par
00467       {\cf19 break};\par
00469     {\cf19 default}:                                                                                                {\cf20 // Unknown object type}\par
00470       fbk_err({\cf22 "Error, bad parameter value! A function got an unexpected patameter value"});                  {\cf20 // Print error fbk}\par
00471       perror({\cf22 "Wrong \\"object_type\\" parameter value passsed to \\"idx_by_name\\" function!"});                 {\cf20 // Print perror fbk}\par
00472       --match_found;                                                                                        {\cf20 // Decrease match found val to indicate error}\par
00473       {\cf19 break};\par
00474   \}\par
00475   {\cf19 if} (match_found == -1)                                                                                    {\cf20 // No march found cond}\par
00476     fbk_err({\cf22 "Error, no match found! Specified name probably wrong or not present in collection"});           {\cf20 // Print err fbk}\par
00477   {\cf19 return} match_found;                                                                                       {\cf20 // Return val}\par
00478 \}\par
}
}
{\xe \v not_an_node_conn\:lib_graph.c}
{\xe \v lib_graph.c\:not_an_node_conn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b Connection}* not_an_node_conn ({\b Node} *  {\i nd}, int *const  {\i vect_size}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Function to obtain a vector of non-analyzed node's connections associated to a specific node (vector allocated/reallocated inside heap using {\b allocate_new_nd_conn_vect()} and {\b reallocate_nd_conn_vect()} functions). This particular sub-routine is called by {\b dijkstra_alg()} in order to anlyze graph data, with the aim of finding min-cost paths towards each node inside {\b nodes_collect_vect}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i nd} \cell }{Graph's node from which to analyze not-already analyzed adjacent connections (node pointer). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i vect_size} \cell }{Size of non-analyzed node connections dynamic-memory vector.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Connection pointer to non-analyzed node connections dynamic-memory vector. \par
}}}{
Definition at line 347 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00347                                                                    \{                                        {\cf20 // Function to get a vector of non-analyzed connections associated to a specific node (vector allocated inside heap)}\par
00348   {\cf20 /* Body */}\par
00349   List_elem* tmp_el = nd->archs_lst;                                                                        {\cf20 // Define tmp list elem ptr var (to scroll arches inside node conn. arches list)}\par
00350   Connection* nan_nd_conn_vect = NULL;                                                                      {\cf20 // Vector of non-analyzed connections associated to a specific node}\par
00351   *vect_size = 0;                                                                                           {\cf20 // Number of non-analyzed connections associated to a specific node (rst)}\par
00352   {\cf19 for} (; tmp_el != NULL; tmp_el = tmp_el->nxt)\{                                                             {\cf20 // Scroll node conn. arches list, upd num of non-analyzed connections associated to a specific node, resize node connections vect inside heap and define vector elements}\par
00353     {\cf19 if} ((nd == tmp_el->ar->nd1 && tmp_el->ar->nd2->dd->an_flg == 0) ||\par
00354         (nd == tmp_el->ar->nd2 && tmp_el->ar->nd1->dd->an_flg == 0))\{                                       {\cf20 // Add node non-analyzed connection only if the destination node ain't been already analyzed}\par
00355       {\cf19 if} (*vect_size == 0)                                                                                  {\cf20 // If it's the first iteration, allocate vector of non-analyzed connections associated to a specific node}\par
00356         nan_nd_conn_vect = allocate_new_nd_conn_vect(*vect_size+1);                                         {\cf20 // Init node non-analyzed connections vect inside heap}\par
00357       {\cf19 else}                                                                                                  {\cf20 // If it's not the first iteration, reallocate vector of non-analyzed connections associated to a specific node (resize)}\par
00358         reallocate_nd_conn_vect(&nan_nd_conn_vect, *vect_size+1);                                           {\cf20 // Resize node non-analyzed connections vect inside heap}\par
00359       {\cf19 if} (nd == tmp_el->ar->nd1)                                                                            {\cf20 // If specified node memo addr corresponds to the arch conn. node1, assign arch conn. node2 in newly allocated element inside vect}\par
00360         (nan_nd_conn_vect+iaddr(V, *vect_size, *vect_size+1))->nd = tmp_el->ar->nd2;                        {\cf20 // Define elements of node (non-analyzed) connections vect inside heap (connection node)}\par
00361       {\cf19 else}                                                                                                  {\cf20 // If specified node memo addr doesn't correspond to the arch conn. node1, assign arch conn. node1 in newly allocated element inside vect}\par
00362         (nan_nd_conn_vect+iaddr(V, *vect_size, *vect_size+1))->nd = tmp_el->ar->nd1;                        {\cf20 // Define elements of node (non-analyzed) connections vect inside heap (connection node)}\par
00363       (nan_nd_conn_vect+iaddr(V, *vect_size, *vect_size+1))->ar = tmp_el->ar;                               {\cf20 // Define elements of node (non-analyzed) connections vect inside heap (connection arch)}\par
00364       ++*vect_size;                                                                                         {\cf20 // Vector of non-analyzed connections associated to a specific node size val upd}\par
00365     \}\par
00366   \}\par
00367   {\cf19 return} nan_nd_conn_vect;                                                                                  {\cf20 // Return vector of non-analyzed connections associated to a specific node}\par
00368 \}\par
}
}
{\xe \v print_min_paths\:lib_graph.c}
{\xe \v lib_graph.c\:print_min_paths}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void print_min_paths (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Function called from {\b dijkstra_alg()}, to print min-path costs from source node specified in last Dijkstra's algorithm execution, towards each other node in {\b nodes_collect_vect}. In case a destination node is unreachble or it corresponds to the pre-defined source node, print dedicated terminal-output feedbacks (special cases management).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 377 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00377                              \{                                                                              {\cf20 // Function to print each min path cost to reach every single accessible node from specified source-node}\par
00378   {\cf20 /* Body */}\par
00379   {\cf19 for} ({\cf18 int} m = 0; m < nds_collect_size; ++m)\{                                                               {\cf20 // Min path costs printin' FOR cycle}\par
00380     fbk_nl(1);  fbk_separator(SEP_CHR, GN);                                                                 {\cf20 // Print separator fbk}\par
00381     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "--> Node name"}, nodes_collect_vect[m].name);                             {\cf20 // Print node name fbk}\par
00382     {\cf19 if} (nodes_collect_vect[m].dd->min_path_cost < _REAL_MAX_ &&\par
00383         &nodes_collect_vect[m] != &nodes_collect_vect[src_node_idx])\{                                       {\cf20 // If node is reachble from specified source node}\par
00384       fbk_nl(1); fbk_gn_lbu_ye_real({\cf22 "Min path cost to node"}, nodes_collect_vect[m].dd->min_path_cost);      {\cf20 // Print min path cost to reach that node from specified source-node fbk}\par
00385     \} {\cf19 else} \{                                                                                                {\cf20 // Else if node is unreachble from specified source node}\par
00386       {\cf19 if} (&nodes_collect_vect[m] == &nodes_collect_vect[src_node_idx])\{                                     {\cf20 // Else if node memo addr corresponds to the source node memo addr}\par
00387         fbk_nl(1);                                                                                          {\cf20 // Print new-line fbk}\par
00388         fbk_gn_lbu_ye_str({\cf22 "Min path cost to node"}, {\cf22 "This node is the specified source node!"});              {\cf20 // Print node correspondin' to the specified source node fbk}\par
00389       \} {\cf19 else} \{                                                                                              {\cf20 // Else if node is unreachble from specified source node}\par
00390         fbk_nl(1);                                                                                          {\cf20 // Print new-line fbk}\par
00391         fbk_gn_lbu_ye_str({\cf22 "Min path cost to node"}, {\cf22 "Node unreachble from specified source node!"});          {\cf20 // Print node unreachble fbk}\par
00392       \}\par
00393     \}\par
00394   \}\par
00395   fbk_nl(1);  fbk_separator(SEP_CHR, GN);                                                                   {\cf20 // Print separator fbk}\par
00396 \}\par
}
}
{\xe \v print_shortest_path\:lib_graph.c}
{\xe \v lib_graph.c\:print_shortest_path}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void print_shortest_path (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Function called from {\b buid_shortest_path()}, to print min-path cost from source node specified in last Dijkstra's algorithm execution, towards specified destination node (defined during build shortest-path function call). In case the destination node is unreachble or it corresponds to the pre-defined source node, print a dedicated terminal-output feedback (special cases management). Print shortest path informations such as the number of nodes and archs between source and destination nodes, shortest-path cost and describe route from source to destination with time-delay prints {\i (delay time in milliseconds, defined using {\b PRINT_DLY_MS} macro)} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 406 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00406                                  \{                                                                          {\cf20 // Print shortest path from pre-defined source node to specified destination node}\par
00407   {\cf20 /* Body */}\par
00408   {\cf19 if} (min_pth_conn_vect_size >= 2)\{                                                                         {\cf20 // If destination node is reachble and it's different from source node}\par
00409     fbk_nl(1);                                                                                              {\cf20 // New line fbk}\par
00410     fbk_gn_lbu_ye_int({\cf22 "Number of nodes between source and destination node"}, min_pth_conn_vect_size-2);     {\cf20 // Print num of nodes btwn source and destination node fbk}\par
00411     fbk_nl(1);                                                                                              {\cf20 // New line fbk}\par
00412     fbk_gn_lbu_ye_int({\cf22 "Number of arches between source and destination node"}, min_pth_conn_vect_size-1);    {\cf20 // Print num of archs btwn source and destination node fbk}\par
00413     fbk_nl(1);  fbk_separator(SHORT_PTH_SEP_CHR, LGN);                                                      {\cf20 // Print separator fbk}\par
00414     fbk_nl(1);  fbk_gn_pu({\cf22 "Showing shortest path between specified source and destination nodes:"});         {\cf20 // Showin' shortest path fbk}\par
00415     delay(PRINT_DLY_MS);                                                                                    {\cf20 // Wait dly time}\par
00416     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Status"}, {\cf22 "STARTING"});                                                    {\cf20 // Print startin' from source node fbk}\par
00417     delay(PRINT_DLY_MS);                                                                                    {\cf20 // Wait dly time}\par
00418     fbk_nl(1);                                                                                              {\cf20 // New line fbk}\par
00419     fbk_gn_lbu_ye_str({\cf22 "Source-node name"}, min_path_conn_vect[0].nd->name);                                  {\cf20 // Source node name fbk}\par
00420     delay(PRINT_DLY_MS);                                                                                    {\cf20 // Wait dly time}\par
00421     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Path-arch name"}, min_path_conn_vect[1].ar->name);                        {\cf20 // Path arch name fbk}\par
00422     fbk_tabs(1);  fbk_gn_lbu_ye_real({\cf22 "Arch cost"}, min_path_conn_vect[1].ar->cost);                          {\cf20 // Path arch cost fbk}\par
00423     delay(PRINT_DLY_MS);                                                                                    {\cf20 // Wait dly time}\par
00424     {\cf19 for} ({\cf18 int} i = 1; i < min_pth_conn_vect_size-1; ++i)\{                                                     {\cf20 // Min path scrollin' and printin' FOR cycle (btwn src and dest nodes)}\par
00425       fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Path-node name"}, min_path_conn_vect[i].nd->name);                      {\cf20 // Path node name fbk}\par
00426       delay(PRINT_DLY_MS);                                                                                  {\cf20 // Wait dly time}\par
00427       fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Path-arch name"}, min_path_conn_vect[i+1].ar->name);                    {\cf20 // Path arch name fbk}\par
00428       fbk_tabs(1);  fbk_gn_lbu_ye_real({\cf22 "Arch cost"}, min_path_conn_vect[i+1].ar->cost);                      {\cf20 // Path arch cost fbk}\par
00429       delay(PRINT_DLY_MS);                                                                                  {\cf20 // Wait dly time}\par
00430     \}\par
00431     fbk_nl(1);                                                                                              {\cf20 // New line fbk}\par
00432     fbk_gn_lbu_ye_str({\cf22 "Destination-node name"}, min_path_conn_vect[min_pth_conn_vect_size-1].nd->name);      {\cf20 // Destination node name fbk}\par
00433     delay(PRINT_DLY_MS);                                                                                    {\cf20 // Wait dly time}\par
00434     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Status"}, {\cf22 "ARRIVED"});                                                     {\cf20 // Print arrived to destination node fbk}\par
00435     fbk_nl(1);  fbk_separator(SHORT_PTH_SEP_CHR, LGN);                                                      {\cf20 // Print separator fbk}\par
00436     delay(PRINT_DLY_MS);                                                                                    {\cf20 // Wait dly time}\par
00437   \} {\cf19 else} \{                                                                                                  {\cf20 // Else if destination node is unreachble or it's equal to source node}\par
00438     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Number of nodes between source and destination node"}, {\cf22 "-"});              {\cf20 // Print no nodes btwn src and dest nodes}\par
00439     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Path-node name"}, {\cf22 "-"});                                                   {\cf20 // Print no archs btwn src and dest nodes}\par
00440   \}\par
00441 \}\par
}
}
{\xe \v reallocate_dijk_dataset_vect\:lib_graph.c}
{\xe \v lib_graph.c\:reallocate_dijk_dataset_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void reallocate_dijk_dataset_vect (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Function to reallocate Dijkstra's dataset vector inside heap, using calloc() function ({\b dijk_dataset_vect} resize using the same size of {\b nodes_collect_vect}: {\b nds_collect_size}). Function called during {\b dijkstra_alg()}, to store Dijkstra's algorithm informations about each node in graph (each vector memory cell, will be associated to each {\b dijkstra_dataset} pointer inside every single {\b node} element).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 304 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00304                                           \{                                                                 {\cf20 // Function to reallocate Dijkstra-dataset vector (resize)}\par
00305   {\cf20 /* Body */}\par
00306   dijk_dataset_vect = realloc(dijk_dataset_vect, ({\cf18 size_t})nds_collect_size*{\cf17 sizeof}(Dijkstra_dataset));        {\cf20 // Dijkstra-dataset vect ptr addr upd to make sure it points at first reallocated memo cell inside heap}\par
00307   {\cf19 if} (dijk_dataset_vect == NULL || nds_collect_size == 0)\{                                                  {\cf20 // Check realloc funct output to detect dynamic memory allocation errors}\par
00308     fbk_err({\cf22 "Ops! Encountered error during graph data management"});                                         {\cf20 // Error fbk}\par
00309     perror({\cf22 "Found error during Dijkstra-dataset vector dynamic memory reallocation with realloc!"});         {\cf20 // Print perror fbk}\par
00310     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00311     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00312   \}\par
00313 \}\par
}
}
{\xe \v reallocate_nd_conn_vect\:lib_graph.c}
{\xe \v lib_graph.c\:reallocate_nd_conn_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void reallocate_nd_conn_vect ({\b Connection} **  {\i nd_conn_vect}, {\b C_int}  {\i size}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Function to reallocate a node-connections vector inside heap, using realloc() function. The purpose of this vector is to contain informations about node's connection: connection arch and node on the other edge of the arch. Function used to reconstrunct min-cost path inside {\b buid_shortest_path()} and to analyze adjacent vertices in {\b dijkstra_alg()}, more precisely in {\b not_an_node_conn()} to find not-already analized connections.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i nd_conn_vect} \cell }{Node connection vector (pointer of pointer) to resize. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i size} \cell }{Number of node-connections to reallocate inside heap (vector resize).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 326 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00326                                                                           \{                                 {\cf20 // Function to reallocate node connections vector (resize)}\par
00327   {\cf20 /* Body */}\par
00328   *nd_conn_vect = realloc(*nd_conn_vect, ({\cf18 size_t})size*{\cf17 sizeof}(Connection));                                  {\cf20 // Node connections vect ptr addr upd to make sure it points at first reallocated memo cell inside heap}\par
00329   {\cf19 if} (*nd_conn_vect == NULL || size == 0)\{                                                                  {\cf20 // Check realloc funct output to detect dynamic memory allocation errors}\par
00330     fbk_err({\cf22 "Ops! Encountered error during graph data management"});                                         {\cf20 // Error fbk}\par
00331     perror({\cf22 "Found error during node connections vector dynamic memory reallocation with realloc!"});         {\cf20 // Print perror fbk}\par
00332     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00333     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00334   \}\par
00335 \}\par
}
}
{\xe \v reallocate_new_archs\:lib_graph.c}
{\xe \v lib_graph.c\:reallocate_new_archs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void reallocate_new_archs (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Function to allocate a new graph-arch element in {\b archs_collect_vect} (inside heap, using realloc() function to resize archs collection vector).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 267 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00267                                   \{                                                                         {\cf20 // Function to reallocate new graph arches (single/vect)}\par
00268   {\cf20 /* Body */}\par
00269   archs_collect_vect = realloc(archs_collect_vect, ({\cf18 size_t})(ars_collect_size+1)*{\cf17 sizeof}(Arch));              {\cf20 // Tmp graph arch ptr creation to point at first allocated memo cell inside heap}\par
00270   {\cf19 if} (archs_collect_vect == NULL)\{                                                                          {\cf20 // Check realloc funct output to detect dynamic memory allocation errors}\par
00271     fbk_err({\cf22 "Ops! Encountered error during graph data management"});                                         {\cf20 // Error fbk}\par
00272     perror({\cf22 "Found error during graph arches dynamic memory reallocation with realloc!"});                    {\cf20 // Print perror fbk}\par
00273     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00274     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00275   \} {\cf19 else}                                                                                                    {\cf20 // In case of dyn memo reallocation OK}\par
00276     ++ars_collect_size;                                                                                     {\cf20 // Upd arches collection vect size}\par
00277 \}\par
}
}
{\xe \v reallocate_new_nodes\:lib_graph.c}
{\xe \v lib_graph.c\:reallocate_new_nodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void reallocate_new_nodes (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Function to allocate a new graph-node element in {\b nodes_collect_vect} (inside heap, using realloc() function to resize nodes collection vector).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 285 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00285                                   \{                                                                         {\cf20 // Function to reallocate new graph nodes (single/vect)}\par
00286   {\cf20 /* Body */}\par
00287   nodes_collect_vect = realloc(nodes_collect_vect, ({\cf18 size_t})(nds_collect_size+1)*{\cf17 sizeof}(Node));              {\cf20 // Tmp graph node ptr creation to point at first allocated memo cell inside heap}\par
00288   {\cf19 if} (nodes_collect_vect == NULL)\{                                                                          {\cf20 // Check realloc funct output to detect dynamic memory allocation errors}\par
00289     fbk_err({\cf22 "Ops! Encountered error during graph data management"});                                         {\cf20 // Error fbk}\par
00290     perror({\cf22 "Found error during graph nodes dynamic memory reallocation with realloc!"});                     {\cf20 // print Perror fbk}\par
00291     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00292     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00293   \} {\cf19 else}                                                                                                    {\cf20 // In case of dyn memo reallocation OK}\par
00294     ++nds_collect_size;                                                                                     {\cf20 // Upd nodes collection vect size}\par
00295 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v _REAL_MAX_\:lib_graph.c}
{\xe \v lib_graph.c\:_REAL_MAX_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Real} _REAL_MAX_ = __DBL_MAX__}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Constant variabile to indicate max real value, simulating +\u8734? in {\b dijkstra_alg()} function. }}\par
{
Definition at line 17 of file lib_graph.c.}\par
}
{\xe \v archs_collect_vect\:lib_graph.c}
{\xe \v lib_graph.c\:archs_collect_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Arch}* archs_collect_vect = NULL}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Archs collection dynamic-memory vector (pointer to first vector memory cell allocated inside heap). }}\par
{
Definition at line 25 of file lib_graph.c.}\par
}
{\xe \v ars_collect_size\:lib_graph.c}
{\xe \v lib_graph.c\:ars_collect_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ars_collect_size = 0}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Archs collection vector size (size of {\b archs_collect_vect}). }}\par
{
Definition at line 19 of file lib_graph.c.}\par
}
{\xe \v dest_node_idx\:lib_graph.c}
{\xe \v lib_graph.c\:dest_node_idx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int dest_node_idx = 0}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Library-variable description:}  Destination node index, selected by-name using {\b idx_by_name()} function. }}\par
{
Definition at line 36 of file lib_graph.c.}\par
}
{\xe \v dijk_dataset_vect\:lib_graph.c}
{\xe \v lib_graph.c\:dijk_dataset_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Dijkstra_dataset}* dijk_dataset_vect = NULL}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Library-variable description:}  Dynamic-memory vector pointer containing a set of informations to be able to find and reconstruct min-cost path, later assigned to each node in {\b dijkstra_alg()} function. }}\par
{
Definition at line 38 of file lib_graph.c.}\par
}
{\xe \v min_path_conn_vect\:lib_graph.c}
{\xe \v lib_graph.c\:min_path_conn_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Connection}* min_path_conn_vect = NULL}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Shortest-path connections dynamic-memory vector (pointer to first vector memory cell allocated inside heap). }}\par
{
Definition at line 29 of file lib_graph.c.}\par
}
{\xe \v min_pth_conn_vect_size\:lib_graph.c}
{\xe \v lib_graph.c\:min_pth_conn_vect_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int min_pth_conn_vect_size = 0}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Shortest-path connections vector size (size of {\b min_path_conn_vect}). }}\par
{
Definition at line 23 of file lib_graph.c.}\par
}
{\xe \v nds_collect_size\:lib_graph.c}
{\xe \v lib_graph.c\:nds_collect_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int nds_collect_size = 0}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Nodes collection vector size (size of {\b nodes_collect_vect}). }}\par
{
Definition at line 21 of file lib_graph.c.}\par
}
{\xe \v nodes_collect_vect\:lib_graph.c}
{\xe \v lib_graph.c\:nodes_collect_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Node}* nodes_collect_vect = NULL}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Nodes collection dynamic-memory vector (pointer to first vector memory cell allocated inside heap). }}\par
{
Definition at line 27 of file lib_graph.c.}\par
}
{\xe \v realloc_flg\:lib_graph.c}
{\xe \v lib_graph.c\:realloc_flg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Byte} realloc_flg = 0}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Library-variable description:}  Reallocation flag to choose between callocs or reallocs in {\b dijkstra_alg()} and {\b buid_shortest_path()} functions {\i (0 = {\b dijkstra_alg()} not-called / 1 = {\b dijkstra_alg()} called / 2 = {\b dijkstra_alg()} called and {\b buid_shortest_path()} called)} . }}\par
{
Definition at line 40 of file lib_graph.c.}\par
}
{\xe \v src_node_idx\:lib_graph.c}
{\xe \v lib_graph.c\:src_node_idx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int src_node_idx = 0}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Library-variable description:}  Source node index, selected by-name using {\b idx_by_name()} function. }}\par
{
Definition at line 34 of file lib_graph.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/graph/lib_graph.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/graph/lib_graph.h}
{\xe \v lib/graph/lib_graph.h}
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Graph-library header file}  }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../ui/lib_ui.h"}\par
{\f2 #include "../timer/lib_timer.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b list_elem}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  List element struct typedef to store connection archs associated to a specific node. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b node}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Node struct typedef to store node name, a list of connection archs associated to that node and a Dijkstra-dataset which contains the informations about that specific node to find min-cost path with Dijkstra's algorithm and reconstruct shortest path. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b arch}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Arch struct typedef to store arch name, arch cost and connection nodes associated to that arch (Node1 and Node2). }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dijkstra_dataset}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Dijkstra-dataset struct typedef to store informations about a specific node, in order to be able to find min-cost path with Dijkstra's algorithm and reconstruct shortest path. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b connection}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Node connection, composed by connection arch and node on the other edge of the arch. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ND_STR_LEN}\~ 31\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Max node-names length in chars {\i (30 + '\\0')} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AR_STR_LEN}\~ 31\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Max arch-names length in chars {\i (30 + '\\0')} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SEP_CHR}\~ '-'\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Char used to create separator lines by library in output feedbacks. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHORT_PTH_SEP_CHR}\~ '*'\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Char used to create separator lines by library in shortest-path output feedbacks. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PRINT_DLY_MS}\~ 500\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Printing delay during shortest-path description in milliseconds. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b list_elem} {\b List_elem}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  List element struct typedef to store connection archs associated to a specific node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b List_elem} * {\b List}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  List pointer typedef to point at list-head element pointer in node archs list (inside heap). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b node} {\b Node}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Node struct typedef to store node name, a list of connection archs associated to that node and a Dijkstra-dataset which contains the informations about that specific node to find min-cost path with Dijkstra's algorithm and reconstruct shortest path. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b Node} * {\b Graph_node}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  Node pointer typedef to point at a specific graph-node allocated in nodes collection vector (inside heap: {\b nodes_collect_vect}). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b arch} {\b Arch}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Arch struct typedef to store arch name, arch cost and connection nodes associated to that arch (Node1 and Node2). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b Arch} * {\b Graph_arch}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  Arch pointer typedef to point at a specific graph-arch allocated in archs collection vector (inside heap: {\b archs_collect_vect}). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b dijkstra_dataset} {\b Dijkstra_dataset}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Dijkstra-dataset struct typedef to store informations about a specific node, in order to be able to find min-cost path with Dijkstra's algorithm and reconstruct shortest path. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b connection} {\b Connection}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Node connection, composed by connection arch and node on the other edge of the arch. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b vect_coords} {\b Vect_coords}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Coordinates enum, indexes for {\b iaddr()} function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b verbose_mode} {\b Verbose_mode}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Advanced verbose mode (Y/N) for {\b dijkstra_alg()} and {\b buid_shortest_path()} functions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b obj_type} {\b Obj_type}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Object type (ARCH/NODE) for {\b idx_by_name()} function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b node_pos_in_arch} {\b Node_pos_in_arch}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Node position type for {\b connect_node_arch()} function (position in which connecting node to arch). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b arch_pos_typ} {\b Arch_pos_typ}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Arch position type for {\b connect_node_arch()} function (position in which connecting arch to node in archs list). }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b vect_coords} \{ {\b V}, 
{\b V2}, 
{\b V3}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Coordinates enum, indexes for {\b iaddr()} function. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b verbose_mode} \{ {\b Y}, 
{\b N}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Advanced verbose mode (Y/N) for {\b dijkstra_alg()} and {\b buid_shortest_path()} functions. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b obj_type} \{ {\b AR}, 
{\b ND}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Object type (ARCH/NODE) for {\b idx_by_name()} function. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b node_pos_in_arch} \{ {\b ARCH_ND1}, 
{\b ARCH_ND2}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Node position type for {\b connect_node_arch()} function (position in which connecting node to arch). }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b arch_pos_typ} \{ {\b LIST_HEAD}, 
{\b LIST_POS}, 
{\b LIST_TAIL}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Arch position type for {\b connect_node_arch()} function (position in which connecting arch to node in archs list). }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b idx_by_name} ({\b Obj_type} object_type, {\b C_str} object_name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add_new_arch} ({\b C_str} name, {\b C_real} cost)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add_new_node} ({\b C_str} name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b connect_node_arch} ({\b C_str} ar_name, {\b C_str} nd_name, {\b Node_pos_in_arch} nd_pos, {\b Arch_pos_typ} ar_pos,...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dijkstra_alg} ({\b C_str} src_nd_name, {\b Verbose_mode} v_mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b buid_shortest_path} ({\b C_str} dest_nd_name, {\b Verbose_mode} v_mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b free_graph} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b C_str} {\b node_pos_in_arch_str} [] = \{"ARCH NODE1 POSITION", "ARCH NODE2 POSITION"\}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Global-variable description:}  Node position in arch strings vector, associated with {\b node_pos_in_arch} enum to print position as string in terminal-output. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b C_str} {\b arch_pos_typ_str} [] = \{"LIST HEAD POSITION", "LIST SPECIFIC POSITION", "LIST TAIL POSITION"\}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Global-variable description:}  Arch position in node strings vector, associated with {\b arch_pos_typ} enum to print position as string in terminal-output. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Real} {\b _REAL_MAX}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Constant variabile to indicate max real value, simulating +\u8734? in {\b dijkstra_alg()} function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ars_collect_size}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Archs collection vector size (size of {\b archs_collect_vect}). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b nds_collect_size}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Nodes collection vector size (size of {\b nodes_collect_vect}). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b min_pth_conn_vect_size}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Shortest-path connections vector size (size of {\b min_path_conn_vect}). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Arch} * {\b archs_collect_vect}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Archs collection dynamic-memory vector (pointer to first vector memory cell allocated inside heap). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Node} * {\b nodes_collect_vect}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Nodes collection dynamic-memory vector (pointer to first vector memory cell allocated inside heap). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Connection} * {\b min_path_conn_vect}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Shortest-path connections dynamic-memory vector (pointer to first vector memory cell allocated inside heap). }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Graph-library header file}  \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Library header file of {\b lib_graph.c}.}  \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v AR_STR_LEN\:lib_graph.h}
{\xe \v lib_graph.h\:AR_STR_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AR_STR_LEN\~ 31}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Max arch-names length in chars {\i (30 + '\\0')} . }}\par
{
Definition at line 40 of file lib_graph.h.}\par
}
{\xe \v ND_STR_LEN\:lib_graph.h}
{\xe \v lib_graph.h\:ND_STR_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ND_STR_LEN\~ 31}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Max node-names length in chars {\i (30 + '\\0')} . }}\par
{
Definition at line 38 of file lib_graph.h.}\par
}
{\xe \v PRINT_DLY_MS\:lib_graph.h}
{\xe \v lib_graph.h\:PRINT_DLY_MS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PRINT_DLY_MS\~ 500}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Printing delay during shortest-path description in milliseconds. }}\par
{
Definition at line 46 of file lib_graph.h.}\par
}
{\xe \v SEP_CHR\:lib_graph.h}
{\xe \v lib_graph.h\:SEP_CHR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SEP_CHR\~ '-'}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Char used to create separator lines by library in output feedbacks. }}\par
{
Definition at line 42 of file lib_graph.h.}\par
}
{\xe \v SHORT_PTH_SEP_CHR\:lib_graph.h}
{\xe \v lib_graph.h\:SHORT_PTH_SEP_CHR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHORT_PTH_SEP_CHR\~ '*'}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Char used to create separator lines by library in shortest-path output feedbacks. }}\par
{
Definition at line 44 of file lib_graph.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v Arch\:lib_graph.h}
{\xe \v lib_graph.h\:Arch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b arch} {\b Arch}}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Arch struct typedef to store arch name, arch cost and connection nodes associated to that arch (Node1 and Node2). }}\par
}
{\xe \v Arch_pos_typ\:lib_graph.h}
{\xe \v lib_graph.h\:Arch_pos_typ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b arch_pos_typ} {\b Arch_pos_typ}}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Arch position type for {\b connect_node_arch()} function (position in which connecting arch to node in archs list). }}\par
}
{\xe \v Connection\:lib_graph.h}
{\xe \v lib_graph.h\:Connection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b connection} {\b Connection}}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Node connection, composed by connection arch and node on the other edge of the arch. }}\par
}
{\xe \v Dijkstra_dataset\:lib_graph.h}
{\xe \v lib_graph.h\:Dijkstra_dataset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b dijkstra_dataset} {\b Dijkstra_dataset}}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Dijkstra-dataset struct typedef to store informations about a specific node, in order to be able to find min-cost path with Dijkstra's algorithm and reconstruct shortest path. }}\par
}
{\xe \v Graph_arch\:lib_graph.h}
{\xe \v lib_graph.h\:Graph_arch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b Arch}* {\b Graph_arch}}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  Arch pointer typedef to point at a specific graph-arch allocated in archs collection vector (inside heap: {\b archs_collect_vect}). }}\par
{
Definition at line 87 of file lib_graph.h.}\par
}
{\xe \v Graph_node\:lib_graph.h}
{\xe \v lib_graph.h\:Graph_node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b Node}* {\b Graph_node}}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  Node pointer typedef to point at a specific graph-node allocated in nodes collection vector (inside heap: {\b nodes_collect_vect}). }}\par
{
Definition at line 72 of file lib_graph.h.}\par
}
{\xe \v List\:lib_graph.h}
{\xe \v lib_graph.h\:List}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b List_elem}* {\b List}}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  List pointer typedef to point at list-head element pointer in node archs list (inside heap). }}\par
{
Definition at line 59 of file lib_graph.h.}\par
}
{\xe \v List_elem\:lib_graph.h}
{\xe \v lib_graph.h\:List_elem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b list_elem} {\b List_elem}}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  List element struct typedef to store connection archs associated to a specific node. }}\par
}
{\xe \v Node\:lib_graph.h}
{\xe \v lib_graph.h\:Node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b node} {\b Node}}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Node struct typedef to store node name, a list of connection archs associated to that node and a Dijkstra-dataset which contains the informations about that specific node to find min-cost path with Dijkstra's algorithm and reconstruct shortest path. }}\par
}
{\xe \v Node_pos_in_arch\:lib_graph.h}
{\xe \v lib_graph.h\:Node_pos_in_arch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b node_pos_in_arch} {\b Node_pos_in_arch}}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Node position type for {\b connect_node_arch()} function (position in which connecting node to arch). }}\par
}
{\xe \v Obj_type\:lib_graph.h}
{\xe \v lib_graph.h\:Obj_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b obj_type} {\b Obj_type}}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Object type (ARCH/NODE) for {\b idx_by_name()} function. }}\par
}
{\xe \v Vect_coords\:lib_graph.h}
{\xe \v lib_graph.h\:Vect_coords}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b vect_coords} {\b Vect_coords}}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Coordinates enum, indexes for {\b iaddr()} function. }}\par
}
{\xe \v Verbose_mode\:lib_graph.h}
{\xe \v lib_graph.h\:Verbose_mode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b verbose_mode} {\b Verbose_mode}}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Advanced verbose mode (Y/N) for {\b dijkstra_alg()} and {\b buid_shortest_path()} functions. }}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v arch_pos_typ\:lib_graph.h}
{\xe \v lib_graph.h\:arch_pos_typ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b arch_pos_typ}}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Arch position type for {\b connect_node_arch()} function (position in which connecting arch to node in archs list). }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v LIST_HEAD\:lib_graph.h}
{\xe \v lib_graph.h\:LIST_HEAD}
{\qr LIST_HEAD{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect arch to node, adding it in head position of node connection-archs list. \par
}\cell }{\row }
{\xe \v LIST_POS\:lib_graph.h}
{\xe \v lib_graph.h\:LIST_POS}
{\qr LIST_POS{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect arch to node, adding it in specific position of node connection-archs list. \par
}\cell }{\row }
{\xe \v LIST_TAIL\:lib_graph.h}
{\xe \v lib_graph.h\:LIST_TAIL}
{\qr LIST_TAIL{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect arch to node, adding it in tail position of node connection-archs list. \par
}\cell }{\row }
}
{
Definition at line 158 of file lib_graph.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00158 \{LIST_HEAD, LIST_POS, LIST_TAIL\} Arch_pos_typ;                                    {\cf20 // Position type to add arch in node arches connections list enum typedef}\par
}
}
{\xe \v node_pos_in_arch\:lib_graph.h}
{\xe \v lib_graph.h\:node_pos_in_arch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b node_pos_in_arch}}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Node position type for {\b connect_node_arch()} function (position in which connecting node to arch). }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v ARCH_ND1\:lib_graph.h}
{\xe \v lib_graph.h\:ARCH_ND1}
{\qr ARCH_ND1{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect node in Node1 position of the arch. \par
}\cell }{\row }
{\xe \v ARCH_ND2\:lib_graph.h}
{\xe \v lib_graph.h\:ARCH_ND2}
{\qr ARCH_ND2{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect node in Node2 position of the arch. \par
}\cell }{\row }
}
{
Definition at line 145 of file lib_graph.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00145 \{ARCH_ND1, ARCH_ND2\} Node_pos_in_arch;                                  {\cf20 // Node position in arch enum typedef}\par
}
}
{\xe \v obj_type\:lib_graph.h}
{\xe \v lib_graph.h\:obj_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b obj_type}}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Object type (ARCH/NODE) for {\b idx_by_name()} function. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v AR\:lib_graph.h}
{\xe \v lib_graph.h\:AR}
{\qr AR{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Graph-arch object type. \par
}\cell }{\row }
{\xe \v ND\:lib_graph.h}
{\xe \v lib_graph.h\:ND}
{\qr ND{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Graph-node object type. \par
}\cell }{\row }
}
{
Definition at line 136 of file lib_graph.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00136 \{AR, ND\} Obj_type;                                                              {\cf20 // Object type enum typedef (arch/node)}\par
}
}
{\xe \v vect_coords\:lib_graph.h}
{\xe \v lib_graph.h\:vect_coords}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b vect_coords}}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Coordinates enum, indexes for {\b iaddr()} function. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v V\:lib_graph.h}
{\xe \v lib_graph.h\:V}
{\qr V{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vectors addressing. \par
}\cell }{\row }
{\xe \v V2\:lib_graph.h}
{\xe \v lib_graph.h\:V2}
{\qr V2{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
2d-matrix addressing (composed by 2 vectors). \par
}\cell }{\row }
{\xe \v V3\:lib_graph.h}
{\xe \v lib_graph.h\:V3}
{\qr V3{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
3d-matrix addressing (composed by 3 vectors). \par
}\cell }{\row }
}
{
Definition at line 118 of file lib_graph.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00118 \{V, V2, V3\} Vect_coords;                                                     {\cf20 // Matrix/vectors enum typedef}\par
}
}
{\xe \v verbose_mode\:lib_graph.h}
{\xe \v lib_graph.h\:verbose_mode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b verbose_mode}}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Advanced verbose mode (Y/N) for {\b dijkstra_alg()} and {\b buid_shortest_path()} functions. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Y\:lib_graph.h}
{\xe \v lib_graph.h\:Y}
{\qr Y{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
YES, enable advanced verbose mode. \par
}\cell }{\row }
{\xe \v N\:lib_graph.h}
{\xe \v lib_graph.h\:N}
{\qr N{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
NO, do not enable advanced verbose mode. \par
}\cell }{\row }
}
{
Definition at line 127 of file lib_graph.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00127 \{Y, N\} Verbose_mode;                                                        {\cf20 // Verbose mode enum typedef}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v add_new_arch\:lib_graph.h}
{\xe \v lib_graph.h\:add_new_arch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void add_new_arch ({\b C_str}  {\i name}, {\b C_real}  {\i cost})}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to add a new arch inside {\b archs_collect_vect} (archs collection vector allocated inside heap).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i name} \cell }{New arch name. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i cost} \cell }{New arch cost value.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 489 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00489                                           \{                                                                 {\cf20 // Function to add new graph arch (arch allocated inside heap)}\par
00490   {\cf20 /* Body */}\par
00491   fbk_nl(1);  fbk_gn_pu({\cf22 "Adding new graph arch..."});                                                        {\cf20 // Adding new graph arch fbk}\par
00492   {\cf19 if} (cost > 0.0)\{                                                                                          {\cf20 // If cost is positive}\par
00493     {\cf19 if} (archs_collect_vect == NULL)                                                                         {\cf20 // Check arches collection vector, if null}\par
00494       allocate_new_arch();                                                                                  {\cf20 // Allocate a new graph arch inside arches collection vector (vect calloc)}\par
00495     {\cf19 else}                                                                                                    {\cf20 // Else if not null}\par
00496       reallocate_new_archs();                                                                               {\cf20 // Allocate a new graph arch inside arches collection vector (vect realloc)}\par
00497     {\cf19 if} (strlen(name) > 0 && strlen(name) < AR_STR_LEN)\{                                                     {\cf20 // Check arch name length consistency, if ok}\par
00498       strcpy(archs_collect_vect[ars_collect_size-1].name, name);  fbk_nl(1);                                {\cf20 // Copy name inside arch name var}\par
00499     \} {\cf19 else} \{                                                                                                {\cf20 // Else if arch name length consistency ain't ok}\par
00500       fbk_err({\cf22 "Error, invalid arch name size! Overriding arch name with arch number in collection"});        {\cf20 // Print error fbk}\par
00501       {\cf18 char} name_ovrd[AR_STR_LEN];                                                                           {\cf20 // Define new name to override input name}\par
00502       sprintf(name_ovrd, {\cf22 "%d"}, ars_collect_size);                                                           {\cf20 // Define override-name as arch number in arches collection vect}\par
00503       strcpy(archs_collect_vect[ars_collect_size-1].name, name_ovrd);                                       {\cf20 // Copy override-name inside arch name var}\par
00504     \}\par
00505     archs_collect_vect[ars_collect_size-1].cost = cost;                                                     {\cf20 // Define arch cost}\par
00506     archs_collect_vect[ars_collect_size-1].nd1 = NULL;                                                      {\cf20 // Set node1 connection to NULL}\par
00507     archs_collect_vect[ars_collect_size-1].nd2 = NULL;                                                      {\cf20 // Set node2 connection to NULL}\par
00508     fbk_gn_lbu_ye_str({\cf22 "New arch name"}, archs_collect_vect[ars_collect_size-1].name);                        {\cf20 // New graph arch name fbk}\par
00509     fbk_nl(1);  fbk_gn_lbu_ye_real({\cf22 "New arch cost"}, archs_collect_vect[ars_collect_size-1].cost);           {\cf20 // New graph arch cost fbk}\par
00510     fbk_nl(1);  fbk_gn_cy({\cf22 "New graph arch correctly added!\\n"});                                             {\cf20 // New graph arch correctly added fbk}\par
00511   \} {\cf19 else} \{                                                                                                  {\cf20 // Else if cost ain't positive}\par
00512     fbk_err({\cf22 "Ops! Encountered error during graph data management"});                                         {\cf20 // Error fbk}\par
00513     perror({\cf22 "Found error during arch object creation, its cost must be strictly positive!"});                 {\cf20 // Print perror fbk}\par
00514     free_graph();                                                                                           {\cf20 // Free graph structure b4 closin' sw}\par
00515     close_err();                                                                                            {\cf20 // Close software with error function call}\par
00516   \}\par
00517 \}\par
}
}
{\xe \v add_new_node\:lib_graph.h}
{\xe \v lib_graph.h\:add_new_node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void add_new_node ({\b C_str}  {\i name})}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to add a new node inside {\b nodes_collect_vect} (nodes collection vector allocated inside heap).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i name} \cell }{New node name.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 527 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00527                              \{                                                                              {\cf20 // Function to add new graph node (node allocated inside heap)}\par
00528   {\cf20 /* Body */}\par
00529   fbk_nl(1);  fbk_gn_pu({\cf22 "Adding new graph node..."});                                                        {\cf20 // Adding new graph node fbk}\par
00530   {\cf19 if} (nodes_collect_vect == NULL)                                                                           {\cf20 // Check nodes collection vector, if null}\par
00531     allocate_new_node();                                                                                    {\cf20 // Allocate a new graph node inside nodes collection vector (vect calloc)}\par
00532   {\cf19 else}                                                                                                      {\cf20 // Else if not null}\par
00533     reallocate_new_nodes();                                                                                 {\cf20 // Allocate a new graph node inside nodes collection vector (vect realloc)}\par
00534   {\cf19 if} (strlen(name) > 0 && strlen(name) < ND_STR_LEN)\{                                                       {\cf20 // Check node name length consistency, if ok}\par
00535     strcpy(nodes_collect_vect[nds_collect_size-1].name, name);  fbk_nl(1);                                  {\cf20 // Copy name inside node name var}\par
00536   \} {\cf19 else} \{                                                                                                  {\cf20 // Else if node name length consistency ain't ok}\par
00537     fbk_err({\cf22 "Error, invalid node name size! Overriding arch name with node number in collection"});          {\cf20 // Print error fbk}\par
00538     {\cf18 char} name_ovrd[ND_STR_LEN];                                                                             {\cf20 // Define new name to override input name}\par
00539     sprintf(name_ovrd, {\cf22 "%d"}, nds_collect_size);                                                             {\cf20 // Define override-name as node number in arches collection vect}\par
00540     strcpy(nodes_collect_vect[nds_collect_size-1].name, name_ovrd);                                         {\cf20 // Copy override-name inside node name var}\par
00541   \}\par
00542   nodes_collect_vect[nds_collect_size-1].archs_lst = NULL;                                                  {\cf20 // Set node arches list to NULL}\par
00543   nodes_collect_vect[nds_collect_size-1].dd = NULL;                                                         {\cf20 // Set node Dijkstra-dataset to NULL}\par
00544   fbk_gn_lbu_ye_str({\cf22 "New node name"}, nodes_collect_vect[nds_collect_size-1].name);                          {\cf20 // New graph arch name fbk}\par
00545   fbk_nl(1);  fbk_gn_cy({\cf22 "New graph node correctly added!\\n"});                                               {\cf20 // New graph node correctly added fbk}\par
00546 \}\par
}
}
{\xe \v buid_shortest_path\:lib_graph.h}
{\xe \v lib_graph.h\:buid_shortest_path}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void buid_shortest_path ({\b C_str}  {\i dest_nd_name}, {\b Verbose_mode}  {\i v_mode})}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
This function must be called once {\b dijkstra_alg()} has been executed at least one time, to initialize and allocate key parameters like Dijkstra-dataset, contained in {\b dijk_dataset_vect}. The aim of this function is to reconstruct shortest path towards specified destination node, from pre-defined source node (defined in last {\b dijkstra_alg()} function call). To do that, the function re-creates the shortest path backwards from destination to source node, and then converts it in forward path. Once shortest-foward path has been correctly built, it's printed by calling {\b print_shortest_path()} function, if advanced verbose mode has been enabled (setting 'v_mode' parameter to 'Y'). Destination node is selected by-name, looking for corresponding index inside {\b nodes_collect_vect} through {\b idx_by_name()} function. This routine, similarly to {\b dijkstra_alg()}, is also able to detect special cases like unreachble nodes and node equal to specified source node. The main reason of splitting shortest path detection in two functions: {\b dijkstra_alg()} and {\b buid_shortest_path()}, consists in being able to reconstruct multiple shortest paths towards different locations, executing Dijkstra's algorithm only one time (if source node is the same). So after calling {\b dijkstra_alg()}, it is possible to call {\b buid_shortest_path()} more times to reconstruct more shortest-paths from the same source node, towards different locations without re-executing Dijkstra's algorithm.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i dest_nd_name} \cell }{Destination node name. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i v_mode} \cell }{Advanced verbose mode (Y/N).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 712 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00712                                                                 \{                                           {\cf20 // Reconstruct shortest path to specified destination node from source node (pre-defined in Dijkstra's algorithm, min path connections vect allocated/reallocated inside heap) - Y/N for verbose mode}\par
00713   {\cf20 /* Body */}\par
00714   fbk_nl(1);  fbk_gn_pu({\cf22 "Building min cost path from pre-defined source to specified destination..."});      {\cf20 // Print reconstructin' shortest path from pre-defined source to specified destination fbk}\par
00715   {\cf19 if} (realloc_flg != 0)\{                                                                                    {\cf20 // If Dijkstra's algorithm has already been called at least once}\par
00716     {\cf20 // Print info fbks}\par
00717     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "--> Source node name"}, nodes_collect_vect[src_node_idx].name);           {\cf20 // Print src-nd name fbk}\par
00718     {\cf18 int} dest_nd_num = idx_by_name(ND, dest_nd_name);                                                        {\cf20 // Get destination node idx by-name}\par
00719     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "--> Destination node name"}, dest_nd_name);                               {\cf20 // Print dest-nd name fbk}\par
00720     {\cf19 if} (dest_nd_num >= 0)\{                                                                                  {\cf20 // Check error conditions ok}\par
00721       dest_node_idx = dest_nd_num;                                                                          {\cf20 // Set/upd destination node idx lib-var val}\par
00722       {\cf19 if} (nodes_collect_vect[dest_nd_num].dd->min_path_cost < _REAL_MAX_ && dest_nd_num != src_node_idx)\{   {\cf20 // If destination node is reachble from pre-defined source node}\par
00723         fbk_nl(1);                                                                                          {\cf20 // Print new-line fbk}\par
00724         fbk_gn_lbu_ye_real({\cf22 "Min path cost to node"}, nodes_collect_vect[dest_nd_num].dd->min_path_cost);     {\cf20 // Print min path cost to reach destination node from pre-defined source node fbk}\par
00725       \} {\cf19 else} {\cf19 if} (dest_nd_num == src_node_idx)\{                                                              {\cf20 // Else if destination node memo addr corresponds to the source node memo addr}\par
00726         fbk_nl(1);                                                                                          {\cf20 // Print new-line fbk}\par
00727         fbk_gn_lbu_ye_str({\cf22 "Min path cost to node"}, {\cf22 "Destination corresponds to pre-defined source node!"});  {\cf20 // Print destination node correspondin' to the pre-defined source node fbk}\par
00728       \} {\cf19 else} \{                                                                                              {\cf20 // Else if destination node is unreachble from pre-defined source node}\par
00729         fbk_nl(1);                                                                                          {\cf20 // Print new-line fbk}\par
00730         fbk_gn_lbu_ye_str({\cf22 "Min path cost to node"}, {\cf22 "Destination unreachble from pre-defined source node!"}); {\cf20 // Print destination node unreachble fbk}\par
00731       \}\par
00732       {\cf20 // Find min-cost path archs & nodes goin' backward from destination to source node}\par
00733       Graph_node tmp_nd = &nodes_collect_vect[dest_nd_num];                                                 {\cf20 // Init tmp node var to reconstruct min-cost path backwards}\par
00734       List_elem* tmpl = NULL;                                                                               {\cf20 // Def tmp list ptr var (for archs) to reconstruct min-cost path backwards}\par
00735       {\cf19 if} (min_pth_conn_vect_size != 0)                                                                      {\cf20 // If min-cost paths vector size ain't zero}\par
00736         min_pth_conn_vect_size = 0;                                                                         {\cf20 // Make it zero}\par
00737       {\cf19 while} (tmp_nd != NULL)\{                                                                               {\cf20 // Scroll min-cost path backwars 'till src node}\par
00738         {\cf19 if} (realloc_flg == 0)\{                                                                              {\cf20 // If realloc flag ain't been set}\par
00739           min_path_conn_vect = allocate_new_nd_conn_vect(++min_pth_conn_vect_size);                         {\cf20 // Allocate (inside heap) a new min path connections vector}\par
00740           ++realloc_flg;                                                                                    {\cf20 // And then upd realloc flag val to use reallocs instead of callocs 'till "free_graph()" funct call}\par
00741         \} {\cf19 else}                                                                                              {\cf20 // Else if realloc flag has already been set}\par
00742           reallocate_nd_conn_vect(&min_path_conn_vect, ++min_pth_conn_vect_size);                           {\cf20 // Reallocate (inside heap) the min path connections vector}\par
00743         tmpl = tmp_nd->archs_lst;                                                                           {\cf20 // Init tmp archs list ptr var}\par
00744         {\cf19 for} (; tmpl != NULL; tmpl = tmpl->nxt)\{                                                             {\cf20 // Scroll min-cost parh node connection archs list to find min-cost path connection arch}\par
00745           {\cf19 if} ((tmp_nd == tmpl->ar->nd1 && tmpl->ar->nd2 == tmp_nd->dd->prev_nd) ||\par
00746               (tmp_nd == tmpl->ar->nd2 && tmpl->ar->nd1 == tmp_nd->dd->prev_nd))\{                           {\cf20 // Min-cost path connection arch detectin' cond}\par
00747             (min_path_conn_vect+iaddr(V, min_pth_conn_vect_size-1, min_pth_conn_vect_size))->ar = tmpl->ar; {\cf20 // Save arch ptr val inside min path connections vector (min-path connection arch)}\par
00748           \}\par
00749         \}\par
00750         (min_path_conn_vect+iaddr(V, min_pth_conn_vect_size-1, min_pth_conn_vect_size))->nd = tmp_nd;       {\cf20 // Save node ptr val inside min path connections vector (min-path connection node)}\par
00751         tmp_nd = tmp_nd->dd->prev_nd;                                                                       {\cf20 // Upd tmp node var to reconstruct min-cost path backwards}\par
00752       \}\par
00753       {\cf20 // Swap elements to obtain shortest path (backward-to-forward path conversion)}\par
00754       Connection tmp_conn;                                                                                  {\cf20 // Tmp connection var to swap connections}\par
00755       {\cf19 for} ({\cf18 int} i = 0; i < min_pth_conn_vect_size/2; ++i)\{                                                   {\cf20 // Half min path connections vector scrollin' FOR cycle}\par
00756         tmp_conn = min_path_conn_vect[i];                                                                   {\cf20 // Define tmp var to swap connections}\par
00757         min_path_conn_vect[i] = min_path_conn_vect[min_pth_conn_vect_size-1-i];                             {\cf20 // Swap-step1}\par
00758         min_path_conn_vect[min_pth_conn_vect_size-i-1] = tmp_conn;                                          {\cf20 // Swap-step2}\par
00759       \}\par
00760       {\cf20 // Print shortest path from pre-defined source node to specified destination node}\par
00761       {\cf19 if} (v_mode == Y)                                                                                      {\cf20 // If verbose mode is enabled, print fbks}\par
00762         print_shortest_path();                                                                              {\cf20 // Print shortest path funct call}\par
00763       fbk_nl(1);  fbk_gn_cy({\cf22 "Destination node min cost path correctly identified!\\n"});                      {\cf20 // Print destination node min cost path correctly identified fbk}\par
00764     \} {\cf19 else}                                                                                                  {\cf20 // If error conditions ain't ok}\par
00765       fbk_err({\cf22 "Error, not able to find destination node min cost path with Dijkstra's algorithm"});          {\cf20 // Print error fbk}\par
00766   \} {\cf19 else}                                                                                                    {\cf20 // Else if Dijkstra's algorithm ain't been called}\par
00767     fbk_err({\cf22 "Error, min path can be reconstructed only after having called Dijkstra's algorithm!"});         {\cf20 // Print error fbk}\par
00768 \}\par
}
}
{\xe \v connect_node_arch\:lib_graph.h}
{\xe \v lib_graph.h\:connect_node_arch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void connect_node_arch ({\b C_str}  {\i ar_name}, {\b C_str}  {\i nd_name}, {\b Node_pos_in_arch}  {\i nd_pos}, {\b Arch_pos_typ}  {\i ar_pos},   {\i ...})}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to create bidirectional connection between specified arch and node in defined positions, using {\b node_pos_in_arch} and {\b arch_pos_typ} enums. Arch and node are selected by-name, looking for corresponding index inside {\b archs_collect_vect} and {\b nodes_collect_vect} through {\b idx_by_name()} function.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ar_name} \cell }{Arch name to connect. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i nd_name} \cell }{Node name to connect. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i nd_pos} \cell }{Node position in arch. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ar_pos} \cell }{Acrch position in node connection-archs list. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i lst_pos} \cell }{{\b (optional parameter)} , required when 'ar_pos' parameter is equal to {\b LIST_POS} (specify list position if specific list position adding mode has been selected).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 561 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00561                                                                                                        \{    {\cf20 // Function to connect arch-node in graph (new arch list element allocated inside heap, opt param --> arch pos in arches list, non-zero index)}\par
00562   {\cf20 /* Body */}\par
00563   fbk_nl(1);  fbk_gn_pu({\cf22 "Creating bidirectional connection between node and arch..."});                      {\cf20 // Creatin' bidirectional connection between node and arch}\par
00564   {\cf18 int} ar_num = idx_by_name(AR, ar_name);                                                                    {\cf20 // Get arch idx by-name}\par
00565   {\cf18 int} nd_num = idx_by_name(ND, nd_name);                                                                    {\cf20 // Get node idx by-name}\par
00566   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Working on node"}, nd_name);                                                {\cf20 // Print node name fbk}\par
00567   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Working on arch"}, ar_name);                                                {\cf20 // Print arch name fbk}\par
00568   {\cf18 int} lst_pos = 0;                                                                                          {\cf20 // List position in which arch must be placed in node conn. arches list}\par
00569   {\cf20 // Function optional parameters management}\par
00570   {\cf19 if} (ar_pos == LIST_POS)\{                                                                                  {\cf20 // If selected arch position type in list is specific position, read list position optional parameter}\par
00571     va_list args_lst;                                                                                       {\cf20 // Function optional parameters list int}\par
00572     va_start(args_lst, ar_pos);                                                                             {\cf20 // Define optional params list startin' point}\par
00573     lst_pos = va_arg(args_lst, {\cf18 int});                                                                        {\cf20 // Read the first optional parameter in funct opt params list (= define list position)}\par
00574   \}\par
00575   {\cf19 if} (nd_num >= 0 && ar_num >= 0 && ((ar_pos == LIST_POS && lst_pos >= 1) || ar_pos != LIST_POS))\{          {\cf20 // Check error conditions ok}\par
00576     {\cf20 // Assign node to arch}\par
00577     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Connecting node to"}, node_pos_in_arch_str[nd_pos]);                      {\cf20 // Connectin' node to arch fbk}\par
00578     {\cf19 switch} (nd_pos)\{                                                                                        {\cf20 // Node assignin' position in arch switch-case (where to assign node in arch)}\par
00579       {\cf19 case} ARCH_ND1:                                                                                        {\cf20 // Case: assign node to arch node1 position}\par
00580         archs_collect_vect[ar_num].nd1 = &nodes_collect_vect[nd_num];                                       {\cf20 // Assign node to arch node1 pos}\par
00581         {\cf19 break};\par
00583       {\cf19 case} ARCH_ND2:                                                                                        {\cf20 // Case: assign node to arch node2 position}\par
00584         archs_collect_vect[ar_num].nd2 = &nodes_collect_vect[nd_num];                                       {\cf20 // Assign node to arch node2 pos}\par
00585         {\cf19 break};\par
00587       {\cf19 default}:                                                                                              {\cf20 // Unknown case}\par
00588         fbk_err({\cf22 "Error, bad parameter value! A function got an unexpected patameter value"});                {\cf20 // Print error fbk}\par
00589         perror({\cf22 "Wrong \\"nd_pos\\" parameter value passsed to \\"connect_node_arch\\" function!"});              {\cf20 // Print perror fbk}\par
00590         {\cf19 break};\par
00591     \}\par
00592     {\cf20 // Assign arch to node}\par
00593     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Connecting arch to node connection archs"}, arch_pos_typ_str[ar_pos]);    {\cf20 // Connectin' node to arch fbk}\par
00594     List_elem* tmp_el = allocate_new_list_elems(1);                                                         {\cf20 // Tmp list element ptr creation}\par
00595     tmp_el->ar = &archs_collect_vect[ar_num];                                                               {\cf20 // Tmp list element ptr def with input arch memo cell addr}\par
00596     {\cf19 switch} (ar_pos)\{                                                                                        {\cf20 // Arch assignin' position type in node arches list switch-case (where to assign arch in node arches connections list) switch-case}\par
00597       {\cf19 case} LIST_HEAD:                                                                                       {\cf20 // Case: assign arch to node arches connections list (head position)}\par
00598         add_elem_at_list_head(&nodes_collect_vect[nd_num].archs_lst, tmp_el);                               {\cf20 // Assign arch (in tmp list element) to the specified node conn. arches list (head position)}\par
00599         {\cf19 break};\par
00601       {\cf19 case} LIST_POS:                                                                                        {\cf20 // Case: assign arch to node arches connections list (specific position, pos from optional funct param)}\par
00602         fbk_nl(1);  fbk_gn_lbu_ye_int({\cf22 "Specific list position number"}, lst_pos);                            {\cf20 // Specific list position num fbk}\par
00603         add_elem_at_list_pos(&nodes_collect_vect[nd_num].archs_lst, tmp_el, lst_pos);                       {\cf20 // Assign arch (in tmp list element) to the specified node conn. arches list (specific position, non-zero index)}\par
00604         {\cf19 break};\par
00606       {\cf19 case} LIST_TAIL:                                                                                       {\cf20 // Case: assign arch to node arches connections list (tail position)}\par
00607         add_elem_at_list_tail(&nodes_collect_vect[nd_num].archs_lst, tmp_el);                               {\cf20 // Assign arch (in tmp list element) to the specified node conn. arches list (tail position)}\par
00608         {\cf19 break};\par
00610       {\cf19 default}:                                                                                              {\cf20 // Unknown case}\par
00611         fbk_err({\cf22 "Error, bad parameter value! A function got an unexpected patameter value"});                {\cf20 // Print error fbk}\par
00612         perror({\cf22 "Wrong \\"ar_pos\\" parameter value passsed to \\"connect_node_arch\\" function!"});              {\cf20 // Print perror fbk}\par
00613         {\cf19 break};\par
00614     \}\par
00615     fbk_nl(1);  fbk_gn_cy({\cf22 "Bidirectional node-arch connetion correctly created!\\n"});                        {\cf20 // Bidirectional node-arch connection correctly created fbk}\par
00616   \} {\cf19 else} \{                                                                                                  {\cf20 // If error conditions ain't ok}\par
00617     fbk_err({\cf22 "Error, not able to create arch-node connection! Connection not created"});                      {\cf20 // Print error fbk}\par
00618     {\cf19 if} (ar_pos == LIST_POS && lst_pos < 1)                                                                  {\cf20 // List pos err detect cond}\par
00619       fbk_err({\cf22 "Error casued by specific list position flag enabled and invalid position value"});            {\cf20 // Print error fbk}\par
00620   \}\par
00621 \}\par
}
}
{\xe \v dijkstra_alg\:lib_graph.h}
{\xe \v lib_graph.h\:dijkstra_alg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dijkstra_alg ({\b C_str}  {\i src_nd_name}, {\b Verbose_mode}  {\i v_mode})}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to apply Dijkstra's algorithm from specified source node, to find min-cost path towards each oder node in graph, working on Dijkstra-dataset info pointers inside each node data-structure (but allocated inside heap with {\b dijk_dataset_vect}). In this way, Dijkstra-dataset memory inside heap is allocated only if, and when needed; in addition, {\b buid_shortest_path()} function can be called multiple times, reconstructing different shortest-paths starting from pre-defined source node (defined in last {\b dijkstra_alg()} function call) without continuously calling Dijstra's algorithm. Source node is selected by-name, looking for corresponding index inside {\b nodes_collect_vect} through {\b idx_by_name()} function. In addition, if advanced verbose mode has been enabled (setting 'v_mode' parameter to 'Y'), {\b print_min_paths()} sub-routine is called to print further informations. Dijkstra's algorithm is also able to detect special cases such as unreachble nodes and node equal to specified source node.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i src_nd_name} \cell }{Source node name. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i v_mode} \cell }{Advanced verbose mode (Y/N).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 637 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00637                                                          \{                                                  {\cf20 // Dijkstra's alg to find min graph-path btwn source and each destination node (Dijkstra-dataset vect allocated/reallocated inside heap) - Y/N for verbose mode}\par
00638   {\cf20 /* Body */}\par
00639   fbk_nl(1);  fbk_gn_pu({\cf22 "Looking for min path costs from specified source with Dijkstra's algorithm..."});   {\cf20 // Print lookin' 4 shortest path btwn spec src and each dest nd fbk}\par
00640   {\cf18 int} src_nd_num = idx_by_name(ND, src_nd_name);                                                            {\cf20 // Get source node idx by-name}\par
00641   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Source node name"}, src_nd_name);                                           {\cf20 // Print source node name}\par
00642   {\cf19 if} (src_nd_num >= 0)\{                                                                                     {\cf20 // Check error conditions ok}\par
00643     {\cf20 // Algorithm inits}\par
00644     {\cf18 int} min_cost_idx = 0;                                                                                   {\cf20 // Min cost node idx in dataset var init}\par
00645     Real min_cost_val = 0.0;                                                                                {\cf20 // Min cost node val in dataset var init}\par
00646     {\cf18 int} nan_nd_conn_vect_size = 0;                                                                          {\cf20 // Node (non-analyzed) connections vector size var to store selected node non-analyzed connections init}\par
00647     Real new_cost = 0.0;                                                                                    {\cf20 // New cost var init}\par
00648     Connection* nan_nd_conn_vect = NULL;                                                                    {\cf20 // Node (non-analyzed) connections vector ptr var decl}\par
00649     {\cf19 if} (realloc_flg == 0)\{                                                                                  {\cf20 // If realloc flag ain't set}\par
00650       allocate_new_dijk_dataset_vect();                                                                     {\cf20 // Dijkstra-dataset vect init (vector allocated inside heap)}\par
00651       ++realloc_flg;                                                                                        {\cf20 // Set realloc flg}\par
00652     \} {\cf19 else}                                                                                                  {\cf20 // Else if realloc flag has been set}\par
00653       reallocate_dijk_dataset_vect();                                                                       {\cf20 // Dijkstra-dataset vect realloc (vector reallocated inside heap)}\par
00654     {\cf19 for} ({\cf18 int} i = 0; i < nds_collect_size; ++i)\{                                                             {\cf20 // Inits FOR cycle}\par
00655       nodes_collect_vect[i].dd = &dijk_dataset_vect[i];                                                     {\cf20 // Define and init nodes Dijkstra-datasets}\par
00656       nodes_collect_vect[i].dd->prev_nd = NULL;                                                             {\cf20 // Node dataset prev node init}\par
00657       nodes_collect_vect[i].dd->an_flg = 0;                                                                 {\cf20 // Node dataset analyzed flag val preset (as not analyzed)}\par
00658       {\cf19 if} (i != src_nd_num)                                                                                  {\cf20 // If node is different from source node}\par
00659         nodes_collect_vect[i].dd->min_path_cost = _REAL_MAX_;                                               {\cf20 // Init unknown min costs from source node (preset val --> +inf)}\par
00660       {\cf19 else}                                                                                                  {\cf20 // Else if node ain't different from source node}\par
00661         nodes_collect_vect[i].dd->min_path_cost = 0;                                                        {\cf20 // Init source-to-source cost (preset val --> zero)}\par
00662     \}\par
00663     src_node_idx = src_nd_num;                                                                              {\cf20 // Set/upd source node idx lib-var val}\par
00664     {\cf20 // Algorithm loop}\par
00665     {\cf19 for} ({\cf18 int} j = 0; j < nds_collect_size-1; ++j)\{                                                           {\cf20 // Main algo loop}\par
00666       {\cf20 // Select node with min-cost path}\par
00667       min_cost_val = _REAL_MAX_;                                                                            {\cf20 // Min cost node val in dataset upd}\par
00668       {\cf19 for} ({\cf18 int} k = 0; k < nds_collect_size; ++k)\{                                                           {\cf20 // Scroll the entire nodes collection 2 detect min cost path node}\par
00669         {\cf19 if} (nodes_collect_vect[k].dd->an_flg == 0 &&\par
00670             nodes_collect_vect[k].dd->min_path_cost < min_cost_val)\{                                        {\cf20 // Min cost path node detectin' cond (min val and node not alredy analized)}\par
00671           min_cost_val = nodes_collect_vect[k].dd->min_path_cost;                                           {\cf20 // If detectin' cond is met, upd min cost node val}\par
00672           min_cost_idx = k;                                                                                 {\cf20 // And upd min cost node idx}\par
00673         \}\par
00674       \}\par
00675       ++nodes_collect_vect[min_cost_idx].dd->an_flg;                                                        {\cf20 // Mark selected node as alredy analized b4 processin' it}\par
00676       {\cf20 // Find non-analyzed connections of selected node}\par
00677       nan_nd_conn_vect_size = 0;                                                                            {\cf20 // Node (non-analyzed) connections vector size var to store selected node non-analyzed connections (rst)}\par
00678       nan_nd_conn_vect = not_an_node_conn(&nodes_collect_vect[min_cost_idx], &nan_nd_conn_vect_size);       {\cf20 // Define selected node non-analyzed connections vect (vector allocated inside heap)}\par
00679       {\cf19 for} ({\cf18 int} l = 0; l < nan_nd_conn_vect_size; ++l)\{                                                      {\cf20 // Scroll selected node non-analyzed connections vect}\par
00680         new_cost = nodes_collect_vect[min_cost_idx].dd->min_path_cost+nan_nd_conn_vect[l].ar->cost;         {\cf20 // New cost val upd}\par
00681         {\cf20 // Upd min path cost and previous node in shortest path}\par
00682         {\cf19 if} (new_cost < nan_nd_conn_vect[l].nd->dd->min_path_cost)\{                                          {\cf20 // In case new cost val is less than min cost val}\par
00683           nan_nd_conn_vect[l].nd->dd->min_path_cost = new_cost;                                             {\cf20 // Upd min cost val}\par
00684           nan_nd_conn_vect[l].nd->dd->prev_nd = &nodes_collect_vect[min_cost_idx];                          {\cf20 // Upd previous min path node}\par
00685         \}\par
00686       \}\par
00687       {\cf19 if} (nan_nd_conn_vect != NULL)                                                                         {\cf20 // If node non-analyzed connections vector was correctly defined}\par
00688         free(nan_nd_conn_vect);                                                                             {\cf20 // Free node non-analyzed connections vector allocated inside heap}\par
00689     \}\par
00690     {\cf20 // Print each min path cost to reach every single accessible node from specified source-node}\par
00691     {\cf19 if} (v_mode == Y)                                                                                        {\cf20 // If verbose mode is enabled, print fbks}\par
00692       print_min_paths();                                                                                    {\cf20 // Print min paths funct call}\par
00693     fbk_nl(1);  fbk_gn_cy({\cf22 "Min path costs correctly found!\\n"});                                             {\cf20 // Print min path costs correctly found fbk}\par
00694   \} {\cf19 else}                                                                                                    {\cf20 // If error conditions ain't ok}\par
00695     fbk_err({\cf22 "Error, not able to find min path costs with Dijkstra's algorithm"});                            {\cf20 // Print error fbk}\par
00696 \}\par
}
}
{\xe \v free_graph\:lib_graph.h}
{\xe \v lib_graph.h\:free_graph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void free_graph ()}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to deallocate graph-structure and clear all allocated memory inside heap.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 776 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00776                  \{                                                                                          {\cf20 // Function to free graph allocated memory inside heap}\par
00777   {\cf20 /* Body */}\par
00778   fbk_nl(1);  fbk_gn_pu({\cf22 "Clearing the whole graph structure..."});                                           {\cf20 // Clearing the whole graph from heap fbk}\par
00779   {\cf19 for} ({\cf18 int} i = 0; i < nds_collect_size; ++i)                                                                {\cf20 // Graph nodes scrollin' FOR cycle}\par
00780     {\cf19 if} (nodes_collect_vect[i].archs_lst != NULL)\{                                                           {\cf20 // If node arches list ain't null}\par
00781       free_list_elems(&nodes_collect_vect[i].archs_lst, N);                                                 {\cf20 // Free graph arches list elems associated to each graph node - NO --> without verbose mode}\par
00782       nodes_collect_vect[i].archs_lst = NULL;                                                               {\cf20 // Set node arches list to null}\par
00783     \}\par
00784   {\cf19 if} (archs_collect_vect != NULL)\{                                                                          {\cf20 // If arches collection vector needs to be cleared from heap}\par
00785     free(archs_collect_vect);                                                                               {\cf20 // Free arches collection vector allocated memo inside heap}\par
00786     archs_collect_vect = NULL;                                                                              {\cf20 // Set arches collection vector to null}\par
00787   \}\par
00788   {\cf19 if} (nodes_collect_vect != NULL)\{                                                                          {\cf20 // If nodes collection vector needs to be cleared from heap}\par
00789     free(nodes_collect_vect);                                                                               {\cf20 // Free nodes collection vector allocated memo inside heap}\par
00790     nodes_collect_vect = NULL;                                                                              {\cf20 // Set nodes collection vector to null}\par
00791   \}\par
00792   {\cf19 if} (dijk_dataset_vect != NULL)\{                                                                           {\cf20 // If Dijkstra-dataset vector needs to be cleared from heap}\par
00793     free(dijk_dataset_vect);                                                                                {\cf20 // Free Dijkstra-dataset vector allocated memo inside heap}\par
00794     dijk_dataset_vect = NULL;                                                                               {\cf20 // Set Dijkstra-dataset vector to null}\par
00795   \}\par
00796   {\cf19 if} (min_path_conn_vect != NULL)\{                                                                          {\cf20 // If min path connections vector needs to be cleared from heap}\par
00797     free(min_path_conn_vect);                                                                               {\cf20 // Free min path connections vector allocated memo inside heap}\par
00798     min_path_conn_vect = NULL;                                                                              {\cf20 // Set min path connections vector to null}\par
00799   \}\par
00800   ars_collect_size = 0;                                                                                     {\cf20 // Set graph arches number back to zero}\par
00801   nds_collect_size = 0;                                                                                     {\cf20 // Set graph nodes number back to zero}\par
00802   min_pth_conn_vect_size = 0;                                                                               {\cf20 // Set min path connections vector size back to zero}\par
00803   realloc_flg = 0;                                                                                          {\cf20 // Realloc flag rst}\par
00804   fbk_nl(1);  fbk_gn_cy({\cf22 "Graph structure correctly erased!\\n"});                                             {\cf20 // Graph structure correctly created erased from heap fbk}\par
00805 \}\par
}
}
{\xe \v idx_by_name\:lib_graph.h}
{\xe \v lib_graph.h\:idx_by_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int idx_by_name ({\b Obj_type}  {\i object_type}, {\b C_str}  {\i object_name})}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to get object (arch or node) vector index by name (inside {\b archs_collect_vect} or {\b nodes_collect_vect}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i object_type} \cell }{Object type, defined through {\b obj_type} enum-typedef value. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i object_name} \cell }{Object name string (target name).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Object (ARCH/NODE) vector index by name {\i (Special cases: -1 = No match found / -2 = Error)} . \par
}}}{
Definition at line 453 of file lib_graph.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00453                                                         \{                                                   {\cf20 // Function to get object (arch/node) vector index by name (-1 = No match found / -2 = Error)}\par
00454   {\cf20 /* Body */}\par
00455   {\cf18 int} match_found = -1;                                                                                     {\cf20 // Match found idx (-1 = No match found / -2 = Error)}\par
00456   {\cf19 switch} (object_type)\{                                                                                     {\cf20 // Object type switch-case}\par
00457     {\cf19 case} AR:                                                                                                {\cf20 // Object type = arch}\par
00458       {\cf19 for} ({\cf18 int} i = 0; i < ars_collect_size; ++i)                                                            {\cf20 // Search match by-name in arches collection vector}\par
00459         {\cf19 if} (strcmp(object_name, archs_collect_vect[i].name) == 0)                                           {\cf20 // Match detecting condition}\par
00460           match_found = i;                                                                                  {\cf20 // Retun match idx in vect}\par
00461       {\cf19 break};\par
00463     {\cf19 case} ND:                                                                                                {\cf20 // Object type = node}\par
00464       {\cf19 for} ({\cf18 int} j = 0; j < nds_collect_size; ++j)                                                            {\cf20 // Search match by-name in nodes collection vector}\par
00465         {\cf19 if} (strcmp(object_name, nodes_collect_vect[j].name) == 0)                                           {\cf20 // Match detecting condition}\par
00466           match_found = j;                                                                                  {\cf20 // Retun match idx in vect}\par
00467       {\cf19 break};\par
00469     {\cf19 default}:                                                                                                {\cf20 // Unknown object type}\par
00470       fbk_err({\cf22 "Error, bad parameter value! A function got an unexpected patameter value"});                  {\cf20 // Print error fbk}\par
00471       perror({\cf22 "Wrong \\"object_type\\" parameter value passsed to \\"idx_by_name\\" function!"});                 {\cf20 // Print perror fbk}\par
00472       --match_found;                                                                                        {\cf20 // Decrease match found val to indicate error}\par
00473       {\cf19 break};\par
00474   \}\par
00475   {\cf19 if} (match_found == -1)                                                                                    {\cf20 // No march found cond}\par
00476     fbk_err({\cf22 "Error, no match found! Specified name probably wrong or not present in collection"});           {\cf20 // Print err fbk}\par
00477   {\cf19 return} match_found;                                                                                       {\cf20 // Return val}\par
00478 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v _REAL_MAX\:lib_graph.h}
{\xe \v lib_graph.h\:_REAL_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Real} _REAL_MAX}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Constant variabile to indicate max real value, simulating +\u8734? in {\b dijkstra_alg()} function. }}\par
}
{\xe \v arch_pos_typ_str\:lib_graph.h}
{\xe \v lib_graph.h\:arch_pos_typ_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b C_str} arch_pos_typ_str[] = \{"LIST HEAD POSITION", "LIST SPECIFIC POSITION", "LIST TAIL POSITION"\}}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Global-variable description:}  Arch position in node strings vector, associated with {\b arch_pos_typ} enum to print position as string in terminal-output. }}\par
{
Definition at line 160 of file lib_graph.h.}\par
}
{\xe \v archs_collect_vect\:lib_graph.h}
{\xe \v lib_graph.h\:archs_collect_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Arch}* archs_collect_vect}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Archs collection dynamic-memory vector (pointer to first vector memory cell allocated inside heap). }}\par
{
Definition at line 25 of file lib_graph.c.}\par
}
{\xe \v ars_collect_size\:lib_graph.h}
{\xe \v lib_graph.h\:ars_collect_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ars_collect_size}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Archs collection vector size (size of {\b archs_collect_vect}). }}\par
{
Definition at line 19 of file lib_graph.c.}\par
}
{\xe \v min_path_conn_vect\:lib_graph.h}
{\xe \v lib_graph.h\:min_path_conn_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Connection}* min_path_conn_vect}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Shortest-path connections dynamic-memory vector (pointer to first vector memory cell allocated inside heap). }}\par
{
Definition at line 29 of file lib_graph.c.}\par
}
{\xe \v min_pth_conn_vect_size\:lib_graph.h}
{\xe \v lib_graph.h\:min_pth_conn_vect_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int min_pth_conn_vect_size}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Shortest-path connections vector size (size of {\b min_path_conn_vect}). }}\par
{
Definition at line 23 of file lib_graph.c.}\par
}
{\xe \v nds_collect_size\:lib_graph.h}
{\xe \v lib_graph.h\:nds_collect_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int nds_collect_size}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Nodes collection vector size (size of {\b nodes_collect_vect}). }}\par
{
Definition at line 21 of file lib_graph.c.}\par
}
{\xe \v node_pos_in_arch_str\:lib_graph.h}
{\xe \v lib_graph.h\:node_pos_in_arch_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b C_str} node_pos_in_arch_str[] = \{"ARCH NODE1 POSITION", "ARCH NODE2 POSITION"\}}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Global-variable description:}  Node position in arch strings vector, associated with {\b node_pos_in_arch} enum to print position as string in terminal-output. }}\par
{
Definition at line 147 of file lib_graph.h.}\par
}
{\xe \v nodes_collect_vect\:lib_graph.h}
{\xe \v lib_graph.h\:nodes_collect_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Node}* nodes_collect_vect}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Nodes collection dynamic-memory vector (pointer to first vector memory cell allocated inside heap). }}\par
{
Definition at line 27 of file lib_graph.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/graph/lib_graph.so File Reference\par \pard\plain 
{\tc\tcl2 \v lib/graph/lib_graph.so}
{\xe \v lib/graph/lib_graph.so}
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Graph-library object file}  }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Graph-library object file}  \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Library object file generated from {\b lib_graph.c} during compiling operations.}  \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/timer/lib_timer.c File Reference\par \pard\plain 
{\tc\tcl2 \v lib/timer/lib_timer.c}
{\xe \v lib/timer/lib_timer.c}
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Timer-library code file}  }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "lib_timer.h"}\par
{\f2 #include "../ui/lib_ui.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b Cmp_res} {\b val_in_rage} ({\b C_int} val_min, {\b C_int} val, {\b C_int} val_max)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b Cmp_res} {\b chk_date_in_range} (const {\b Date_time} date)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b delay} (const long time_ms)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Date_time} {\b get_date_time} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Date_time} {\b assign_date_time} (const int yyyy, const int mn, const int dd, const int hh, const int mm, const int ss)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Cmp_res} {\b cmp_date_time} ({\b Date_time} *const date1, const {\b Date_cmp} cmp_typ, {\b Date_time} *const date2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_date_time} (const char *const prfx_str_lbu, const {\b Date_time} *const date)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Timer-library code file}  \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i More info in {\b 'Timer library'}  section inside doxygen {\b 'Related pages'} .}  \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v assign_date_time\:lib_timer.c}
{\xe \v lib_timer.c\:assign_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Date_time} assign_date_time (const int  {\i yyyy}, const int  {\i mn}, const int  {\i dd}, const int  {\i hh}, const int  {\i mm}, const int  {\i ss})}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to manually assign specific date and time values (saving them in {\b date_time} data-structure). Check if input values are ok calling {\b chk_date_in_range()}; in case specified values are not ok, set all the values inside the dedicated data-structure to zero.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i yyyy} \cell }{Year value. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i mn} \cell }{Month value. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i dd} \cell }{Day value. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i hh} \cell }{Hours value. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i mm} \cell }{Minutes value. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ss} \cell }{Seconds value.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Return specific date/time info in dedicated data-structure. \par
}}}{
Definition at line 105 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00106                                                                     \{                                       {\cf20 // Assign date/time function}\par
00107   {\cf20 /* Body */}\par
00108   Date_time tmp_date_time;                                                                                  {\cf20 // Temporary date/time var to return}\par
00109   tmp_date_time.yyyy = yyyy;                                                                                {\cf20 // Save years var}\par
00110   tmp_date_time.mn = mn;                                                                                    {\cf20 // Save months var}\par
00111   tmp_date_time.dd = dd;                                                                                    {\cf20 // Save days var}\par
00112   tmp_date_time.hh = hh+1;                                                                                  {\cf20 // Save hours var (+1)}\par
00113   tmp_date_time.mm = mm+1;                                                                                  {\cf20 // Save minutes var (+1)}\par
00114   tmp_date_time.ss = ss+1;                                                                                  {\cf20 // Save seconds var (+1)}\par
00115   {\cf19 if} (chk_date_in_range(tmp_date_time) == NOT_OK)\{                                                          {\cf20 // Check date/time consistency (case NOT-OK)}\par
00116     fbk_err({\cf22 "Error! Invalid date/time"});                                                                    {\cf20 // Print error fbk}\par
00117     tmp_date_time.yyyy = 0;                                                                                 {\cf20 // Set years var to ZERO}\par
00118     tmp_date_time.mn = 0;                                                                                   {\cf20 // Set months var to ZERO}\par
00119     tmp_date_time.dd = 0;                                                                                   {\cf20 // Set days var to ZERO}\par
00120     tmp_date_time.hh = 0;                                                                                   {\cf20 // Set hours var to ZERO}\par
00121     tmp_date_time.mm = 0;                                                                                   {\cf20 // Set minutes var to ZERO}\par
00122     tmp_date_time.ss = 0;                                                                                   {\cf20 // Set seconds var to ZERO}\par
00123   \}\par
00124   {\cf19 return} tmp_date_time;                                                                                     {\cf20 // Return date/time var}\par
00125 \}\par
}
}
{\xe \v chk_date_in_range\:lib_timer.c}
{\xe \v lib_timer.c\:chk_date_in_range}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b Cmp_res} chk_date_in_range (const {\b Date_time}  {\i date}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Function to check if a date/time data-structure manually assigned through {\b assign_date_time()} function call, is actually correct (date/time values in range defined by macros).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i date} \cell }{Date/time data-structure to check.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
If input date/time is correct return {\b OK}, else {\b NOT_OK}. \par
}}}{
Definition at line 42 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00042                                                       \{                                                     {\cf20 // Check date/time in range function}\par
00043   {\cf20 /* Body */}\par
00044   {\cf19 if} (val_in_rage(MIN_YY, date.yyyy, MAX_YY) && val_in_rage(MIN_MN, date.mn, MAX_MN) &&\par
00045       val_in_rage(MIN_DD, date.dd, MAX_DD) && val_in_rage(MIN_HH, date.hh, MAX_HH) &&\par
00046       val_in_rage(MIN_MM, date.mm, MAX_MM) && val_in_rage(MIN_SS, date.ss, MAX_SS))                         {\cf20 // If date/time is in range}\par
00047     {\cf19 return} OK;                                                                                              {\cf20 // Return OK}\par
00048   {\cf19 else}                                                                                                      {\cf20 // Else if date/time ain't in range}\par
00049     {\cf19 return} NOT_OK;                                                                                          {\cf20 // Return NOT-OK}\par
00050 \}\par
}
}
{\xe \v cmp_date_time\:lib_timer.c}
{\xe \v lib_timer.c\:cmp_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Cmp_res} cmp_date_time ({\b Date_time} *const  {\i date1}, const {\b Date_cmp}  {\i cmp_typ}, {\b Date_time} *const  {\i date2})}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to compare two input dates, detecting if the former is NEWER or OLDER than the latter.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i date1} \cell }{First date/time data-structure in comparison. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i cmp_typ} \cell }{Dates comparison type (NEWER/OLDER). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i date2} \cell }{Second date/time data-structure in comparison.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Return dates comparison result. \par
}}}{
Definition at line 137 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00137                                                                                              \{              {\cf20 // Compare date/time function}\par
00138   {\cf20 /* Body */}\par
00139   {\cf18 int} *date1_val_ptr = &date1->yyyy, *date2_val_ptr = &date2->yyyy;                                         {\cf20 // Date/time ptrs vals}\par
00140   {\cf19 for} (Byte idx = 1; *date1_val_ptr == *date2_val_ptr && idx < 6; ++idx)\{                                   {\cf20 // Compare and redefine date1 and date2 ptr vals FOR cylce (cycle 'till years/months/days/hours/minutes/seconds are different)}\par
00141     {\cf19 switch} (idx)\{                                                                                           {\cf20 // Redefinition index switch-case}\par
00142       {\cf19 case} 1:                                                                                               {\cf20 // If years are equivalents, check months}\par
00143         date1_val_ptr = &date1->mn;                                                                         {\cf20 // Redefine date1 ptr val to date1 months}\par
00144         date2_val_ptr = &date2->mn;                                                                         {\cf20 // Redefine date2 ptr val to date2 months}\par
00145         {\cf19 break};\par
00147       {\cf19 case} 2:                                                                                               {\cf20 // If months are equivalents, check days}\par
00148         date1_val_ptr = &date1->dd;                                                                         {\cf20 // Redefine date1 ptr val to date1 days}\par
00149         date2_val_ptr = &date2->dd;                                                                         {\cf20 // Redefine date2 ptr val to date2 days}\par
00150         {\cf19 break};\par
00152       {\cf19 case} 3:                                                                                               {\cf20 // If days are equivalents, check hours}\par
00153         date1_val_ptr = &date1->hh;                                                                         {\cf20 // Redefine date1 ptr val to date1 hours}\par
00154         date2_val_ptr = &date2->hh;                                                                         {\cf20 // Redefine date2 ptr val to date2 hours}\par
00155         {\cf19 break};\par
00157       {\cf19 case} 4:                                                                                               {\cf20 // If hours are equivalents, check minutes}\par
00158         date1_val_ptr = &date1->mm;                                                                         {\cf20 // Redefine date1 ptr val to date1 minutes}\par
00159         date2_val_ptr = &date2->mm;                                                                         {\cf20 // Redefine date2 ptr val to date2 minutes}\par
00160         {\cf19 break};\par
00162       {\cf19 case} 5:                                                                                               {\cf20 // If minutes are equivalents, check seconds}\par
00163         date1_val_ptr = &date1->ss;                                                                         {\cf20 // Redefine date1 ptr val to date1 seconds}\par
00164         date2_val_ptr = &date2->ss;                                                                         {\cf20 // Redefine date2 ptr val to date2 seconds}\par
00165         {\cf19 break};        \par
00166     \}\par
00167   \}\par
00168   {\cf19 if} ((cmp_typ == OLDER && *date1_val_ptr < *date2_val_ptr) ||\par
00169       (cmp_typ == NEWER && *date1_val_ptr > *date2_val_ptr))                                                {\cf20 // Comparison conditions, if comparison is OK}\par
00170     {\cf19 return} OK;                                                                                              {\cf20 // Return compare OK}\par
00171   {\cf19 else}                                                                                                      {\cf20 // Else if comparison is NOT-OK}\par
00172     {\cf19 return} NOT_OK;                                                                                          {\cf20 // Return compare NOT-OK}\par
00173 \}\par
}
}
{\xe \v delay\:lib_timer.c}
{\xe \v lib_timer.c\:delay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void delay (const long  {\i time_ms})}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to apply delay (wait specified delay time in milliseconds).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i time_ms} \cell }{Delay time in milliseconds to wait.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 61 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00061                               \{                                                                             {\cf20 // Delay [ms] function}\par
00062   {\cf20 /* Body */}\par
00063   {\cf19 if} (time_ms > 0)\{                                                                                         {\cf20 // Check ms-dly val}\par
00064     fflush(stdout);                                                                                         {\cf20 // Force pending terminal fbk prints}\par
00065     clock_t start_time = clock();                                                                           {\cf20 // Start time = software execution time}\par
00066     {\cf19 while} ((clock() - start_time) < (time_ms * (CLOCKS_PER_SEC / 1000)));                                   {\cf20 // Check if elapsed time [ms] (time - start_time) is greater or equal to pause time, pause time calculated considering the number of clocks per second}\par
00067   \} {\cf19 else}                                                                                                    {\cf20 // If ms-dly val ain't positive}\par
00068     perror({\cf22 "Error! Delay time must be greater than ZERO!"});                                                 {\cf20 // Print perror fbk}\par
00069 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_date_time\:lib_timer.c}
{\xe \v lib_timer.c\:fbk_gn_lbu_ye_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_date_time (const char *const  {\i prfx_str_lbu}, const {\b Date_time} *const  {\i date})}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print date/time light-blue/yellow feedback on terminal. In case date/time is invalid, print red error feedback.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i prfx_str_lbu} \cell }{Prefix feedback string to print (in light-blue color). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i date} \cell }{Date/time data-structure to print (in yellow color).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 185 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00185                                                                                          \{                  {\cf20 // Green-lightblue-yellow date/time val feedback function}\par
00186   {\cf20 /* Body */}\par
00187   {\cf19 if} (date->yyyy != 0 && date->mn != 0 && date->dd != 0 && date->hh != 0 && date->mm != 0 && date->ss != 0) {\cf20 // If date/time is correct}\par
00188     printf({\cf22 "%s>>>%s %s: %s%d%c%d%c%d%c%d%c%d%c%d%s"},\par
00189             GN, LBU, prfx_str_lbu, YE, date->yyyy, DATE_DELIM_CHR, date->mn, DATE_DELIM_CHR, date->dd,\par
00190             DATE_TIME_DELIM_CHR, date->hh-1, TIME_DELIM_CHR, date->mm-1, TIME_DELIM_CHR, date->ss-1, ER);   {\cf20 // Print green-lightblue-yellow date/time val feedback}\par
00191   {\cf19 else}                                                                                                      {\cf20 // Else if date/time ain't correct}\par
00192     fbk_err({\cf22 "Error! Invalid date/time"});                                                                    {\cf20 // Print error fbk}\par
00193 \}\par
}
}
{\xe \v get_date_time\:lib_timer.c}
{\xe \v lib_timer.c\:get_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Date_time} get_date_time ()}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to get current date and time values (saving them in {\b date_time} data-structure).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Return current date/time info in dedicated data-structure. \par
}}}{
Definition at line 77 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00077                          \{                                                                                  {\cf20 // Get date/time function}\par
00078   {\cf20 /* Body */}\par
00079   Date_time tmp_date_time;                                                                                  {\cf20 // Temporary date/time var to return}\par
00080   time_t now = time(NULL);                                                                                  {\cf20 // Now timer}\par
00081   {\cf17 struct }tm tm = *localtime(&now);                                                                          {\cf20 // Get now date/time}\par
00082   tmp_date_time.yyyy = 1900+tm.tm_year;                                                                     {\cf20 // Save years var}\par
00083   tmp_date_time.mn = 1+tm.tm_mon;                                                                           {\cf20 // Save months var}\par
00084   tmp_date_time.dd = tm.tm_mday;                                                                            {\cf20 // Save days var}\par
00085   tmp_date_time.hh = tm.tm_hour+1;                                                                          {\cf20 // Save hours var (+1)}\par
00086   tmp_date_time.mm = tm.tm_min+1;                                                                           {\cf20 // Save minutes var (+1)}\par
00087   tmp_date_time.ss = tm.tm_sec+1;                                                                           {\cf20 // Save seconds var (+1)}\par
00088   {\cf19 return} tmp_date_time;                                                                                     {\cf20 // Return date/time}\par
00089 \}\par
}
}
{\xe \v val_in_rage\:lib_timer.c}
{\xe \v lib_timer.c\:val_in_rage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b Cmp_res} val_in_rage ({\b C_int}  {\i val_min}, {\b C_int}  {\i val}, {\b C_int}  {\i val_max}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Function to check if an integer value is in-range (intervall extremes included).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val_min} \cell }{Integer min value (lower extreme of the interval). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{Integer value to check. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val_max} \cell }{Integer max value (higher extreme of the interval).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
If 'val' is in range ['val_min', 'val_max'], return {\b OK} else {\b NOT_OK}. \par
}}}{
Definition at line 25 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00025                                                                    \{                                        {\cf20 // Function to check val in range}\par
00026   {\cf20 /* Body */}\par
00027   {\cf19 if} (val >= val_min && val <= val_max)                                                                     {\cf20 // If val is in range}\par
00028     {\cf19 return} OK;                                                                                              {\cf20 // Return OK}\par
00029   {\cf19 else}                                                                                                      {\cf20 // Else if val ain't in range}\par
00030     {\cf19 return} NOT_OK;                                                                                          {\cf20 // Return NOT-OK}\par
00031 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/timer/lib_timer.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/timer/lib_timer.h}
{\xe \v lib/timer/lib_timer.h}
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Timer-library header file}  }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <time.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b date_time}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Date/time data-structure (yyyy/mn/dd, hh:mm:ss), defined using {\b get_date_time()} or {\b assign_date_time()} functions.\par
 Date/time exact format: {\i (yyyy) + {\b DATE_DELIM_CHR} + (mn) + {\b DATE_DELIM_CHR} + (dd) + {\b DATE_TIME_DELIM_CHR} + (hh+1) + {\b TIME_DELIM_CHR} + (mm+1) + {\b TIME_DELIM_CHR} + (ss+1)} . }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DATE_TIME_STR_LEN}\~ 20\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Date/time string length {\i (19 + '\\0')} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DATE_DELIM_CHR}\~ '/'\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Date delimiter char. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DATE_TIME_DELIM_CHR}\~ ' '\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Date/time delimiter char. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TIME_DELIM_CHR}\~ ':'\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Time delimiter char. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_YY}\~ 2050\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Max allowed years value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MIN_YY}\~ 1910\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Min allowed years value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_MN}\~ 12\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Max allowed months value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MIN_MN}\~ 1\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Min allowed months value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_DD}\~ 31\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Max allowed days value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MIN_DD}\~ 1\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Min allowed days value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_HH}\~ 24\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Max allowed hours value {\i (hours+1)} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MIN_HH}\~ 1\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Min allowed hours value {\i (hours+1)} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_MM}\~ 60\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Max allowed minutes value {\i (minutes+1)} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MIN_MM}\~ 1\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Min allowed minutes value {\i (minutes+1)} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_SS}\~ 60\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Max allowed seconds value {\i (seconds+1)} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MIN_SS}\~ 1\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Min allowed seconds value {\i (seconds+1)} . }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b date_time} {\b Date_time}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Date/time data-structure (yyyy/mn/dd, hh:mm:ss), defined using {\b get_date_time()} or {\b assign_date_time()} functions.\par
 Date/time exact format: {\i (yyyy) + {\b DATE_DELIM_CHR} + (mn) + {\b DATE_DELIM_CHR} + (dd) + {\b DATE_TIME_DELIM_CHR} + (hh+1) + {\b TIME_DELIM_CHR} + (mm+1) + {\b TIME_DELIM_CHR} + (ss+1)} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b date_cmp} {\b Date_cmp}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Date compare enum for {\b cmp_date_time()} function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b cmp_res} {\b Cmp_res}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Compare result enum for {\b cmp_date_time()} function using {\b chk_date_in_range()} and {\b val_in_rage()}. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b date_cmp} \{ {\b OLDER}, 
{\b NEWER}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Date compare enum for {\b cmp_date_time()} function. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b cmp_res} \{ {\b NOT_OK}, 
{\b OK}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Compare result enum for {\b cmp_date_time()} function using {\b chk_date_in_range()} and {\b val_in_rage()}. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b delay} (const long time_ms)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Date_time} {\b get_date_time} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Date_time} {\b assign_date_time} (const int yyyy, const int mn, const int dd, const int hh, const int mm, const int ss)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Cmp_res} {\b cmp_date_time} ({\b Date_time} *const date1, const {\b Date_cmp} cmp_typ, {\b Date_time} *const date2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_date_time} (const char *const prfx_str_lbu, const {\b Date_time} *const date)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Timer-library header file}  \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Library header file of {\b lib_timer.c}.}  \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DATE_DELIM_CHR\:lib_timer.h}
{\xe \v lib_timer.h\:DATE_DELIM_CHR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DATE_DELIM_CHR\~ '/'}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Date delimiter char. }}\par
{
Definition at line 40 of file lib_timer.h.}\par
}
{\xe \v DATE_TIME_DELIM_CHR\:lib_timer.h}
{\xe \v lib_timer.h\:DATE_TIME_DELIM_CHR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DATE_TIME_DELIM_CHR\~ ' '}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Date/time delimiter char. }}\par
{
Definition at line 42 of file lib_timer.h.}\par
}
{\xe \v DATE_TIME_STR_LEN\:lib_timer.h}
{\xe \v lib_timer.h\:DATE_TIME_STR_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DATE_TIME_STR_LEN\~ 20}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Date/time string length {\i (19 + '\\0')} . }}\par
{
Definition at line 38 of file lib_timer.h.}\par
}
{\xe \v MAX_DD\:lib_timer.h}
{\xe \v lib_timer.h\:MAX_DD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_DD\~ 31}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Max allowed days value. }}\par
{
Definition at line 54 of file lib_timer.h.}\par
}
{\xe \v MAX_HH\:lib_timer.h}
{\xe \v lib_timer.h\:MAX_HH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_HH\~ 24}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Max allowed hours value {\i (hours+1)} . }}\par
{
Definition at line 58 of file lib_timer.h.}\par
}
{\xe \v MAX_MM\:lib_timer.h}
{\xe \v lib_timer.h\:MAX_MM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_MM\~ 60}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Max allowed minutes value {\i (minutes+1)} . }}\par
{
Definition at line 62 of file lib_timer.h.}\par
}
{\xe \v MAX_MN\:lib_timer.h}
{\xe \v lib_timer.h\:MAX_MN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_MN\~ 12}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Max allowed months value. }}\par
{
Definition at line 50 of file lib_timer.h.}\par
}
{\xe \v MAX_SS\:lib_timer.h}
{\xe \v lib_timer.h\:MAX_SS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_SS\~ 60}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Max allowed seconds value {\i (seconds+1)} . }}\par
{
Definition at line 66 of file lib_timer.h.}\par
}
{\xe \v MAX_YY\:lib_timer.h}
{\xe \v lib_timer.h\:MAX_YY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_YY\~ 2050}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Max allowed years value. }}\par
{
Definition at line 46 of file lib_timer.h.}\par
}
{\xe \v MIN_DD\:lib_timer.h}
{\xe \v lib_timer.h\:MIN_DD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MIN_DD\~ 1}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Min allowed days value. }}\par
{
Definition at line 56 of file lib_timer.h.}\par
}
{\xe \v MIN_HH\:lib_timer.h}
{\xe \v lib_timer.h\:MIN_HH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MIN_HH\~ 1}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Min allowed hours value {\i (hours+1)} . }}\par
{
Definition at line 60 of file lib_timer.h.}\par
}
{\xe \v MIN_MM\:lib_timer.h}
{\xe \v lib_timer.h\:MIN_MM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MIN_MM\~ 1}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Min allowed minutes value {\i (minutes+1)} . }}\par
{
Definition at line 64 of file lib_timer.h.}\par
}
{\xe \v MIN_MN\:lib_timer.h}
{\xe \v lib_timer.h\:MIN_MN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MIN_MN\~ 1}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Min allowed months value. }}\par
{
Definition at line 52 of file lib_timer.h.}\par
}
{\xe \v MIN_SS\:lib_timer.h}
{\xe \v lib_timer.h\:MIN_SS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MIN_SS\~ 1}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Min allowed seconds value {\i (seconds+1)} . }}\par
{
Definition at line 68 of file lib_timer.h.}\par
}
{\xe \v MIN_YY\:lib_timer.h}
{\xe \v lib_timer.h\:MIN_YY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MIN_YY\~ 1910}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Min allowed years value. }}\par
{
Definition at line 48 of file lib_timer.h.}\par
}
{\xe \v TIME_DELIM_CHR\:lib_timer.h}
{\xe \v lib_timer.h\:TIME_DELIM_CHR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TIME_DELIM_CHR\~ ':'}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Time delimiter char. }}\par
{
Definition at line 44 of file lib_timer.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v Cmp_res\:lib_timer.h}
{\xe \v lib_timer.h\:Cmp_res}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b cmp_res} {\b Cmp_res}}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Compare result enum for {\b cmp_date_time()} function using {\b chk_date_in_range()} and {\b val_in_rage()}. }}\par
}
{\xe \v Date_cmp\:lib_timer.h}
{\xe \v lib_timer.h\:Date_cmp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b date_cmp} {\b Date_cmp}}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Date compare enum for {\b cmp_date_time()} function. }}\par
}
{\xe \v Date_time\:lib_timer.h}
{\xe \v lib_timer.h\:Date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b date_time} {\b Date_time}}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Date/time data-structure (yyyy/mn/dd, hh:mm:ss), defined using {\b get_date_time()} or {\b assign_date_time()} functions.\par
 Date/time exact format: {\i (yyyy) + {\b DATE_DELIM_CHR} + (mn) + {\b DATE_DELIM_CHR} + (dd) + {\b DATE_TIME_DELIM_CHR} + (hh+1) + {\b TIME_DELIM_CHR} + (mm+1) + {\b TIME_DELIM_CHR} + (ss+1)} . }}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v cmp_res\:lib_timer.h}
{\xe \v lib_timer.h\:cmp_res}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b cmp_res}}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Compare result enum for {\b cmp_date_time()} function using {\b chk_date_in_range()} and {\b val_in_rage()}. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v NOT_OK\:lib_timer.h}
{\xe \v lib_timer.h\:NOT_OK}
{\qr NOT_OK{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Comparison result not ok. \par
}\cell }{\row }
{\xe \v OK\:lib_timer.h}
{\xe \v lib_timer.h\:OK}
{\qr OK{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Comparison result ok. \par
}\cell }{\row }
}
{
Definition at line 106 of file lib_timer.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00106 \{NOT_OK, OK\} Cmp_res;                                                                   {\cf20 // Date/time compare result enum}\par
}
}
{\xe \v date_cmp\:lib_timer.h}
{\xe \v lib_timer.h\:date_cmp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b date_cmp}}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Date compare enum for {\b cmp_date_time()} function. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v OLDER\:lib_timer.h}
{\xe \v lib_timer.h\:OLDER}
{\qr OLDER{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Strictly older comparison type. \par
}\cell }{\row }
{\xe \v NEWER\:lib_timer.h}
{\xe \v lib_timer.h\:NEWER}
{\qr NEWER{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Strictly newer comparison type. \par
}\cell }{\row }
}
{
Definition at line 97 of file lib_timer.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00097 \{OLDER, NEWER\} Date_cmp;                                                              {\cf20 // Date/time compare enum}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v assign_date_time\:lib_timer.h}
{\xe \v lib_timer.h\:assign_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Date_time} assign_date_time (const int  {\i yyyy}, const int  {\i mn}, const int  {\i dd}, const int  {\i hh}, const int  {\i mm}, const int  {\i ss})}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to manually assign specific date and time values (saving them in {\b date_time} data-structure). Check if input values are ok calling {\b chk_date_in_range()}; in case specified values are not ok, set all the values inside the dedicated data-structure to zero.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i yyyy} \cell }{Year value. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i mn} \cell }{Month value. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i dd} \cell }{Day value. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i hh} \cell }{Hours value. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i mm} \cell }{Minutes value. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ss} \cell }{Seconds value.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Return specific date/time info in dedicated data-structure. \par
}}}{
Definition at line 105 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00106                                                                     \{                                       {\cf20 // Assign date/time function}\par
00107   {\cf20 /* Body */}\par
00108   Date_time tmp_date_time;                                                                                  {\cf20 // Temporary date/time var to return}\par
00109   tmp_date_time.yyyy = yyyy;                                                                                {\cf20 // Save years var}\par
00110   tmp_date_time.mn = mn;                                                                                    {\cf20 // Save months var}\par
00111   tmp_date_time.dd = dd;                                                                                    {\cf20 // Save days var}\par
00112   tmp_date_time.hh = hh+1;                                                                                  {\cf20 // Save hours var (+1)}\par
00113   tmp_date_time.mm = mm+1;                                                                                  {\cf20 // Save minutes var (+1)}\par
00114   tmp_date_time.ss = ss+1;                                                                                  {\cf20 // Save seconds var (+1)}\par
00115   {\cf19 if} (chk_date_in_range(tmp_date_time) == NOT_OK)\{                                                          {\cf20 // Check date/time consistency (case NOT-OK)}\par
00116     fbk_err({\cf22 "Error! Invalid date/time"});                                                                    {\cf20 // Print error fbk}\par
00117     tmp_date_time.yyyy = 0;                                                                                 {\cf20 // Set years var to ZERO}\par
00118     tmp_date_time.mn = 0;                                                                                   {\cf20 // Set months var to ZERO}\par
00119     tmp_date_time.dd = 0;                                                                                   {\cf20 // Set days var to ZERO}\par
00120     tmp_date_time.hh = 0;                                                                                   {\cf20 // Set hours var to ZERO}\par
00121     tmp_date_time.mm = 0;                                                                                   {\cf20 // Set minutes var to ZERO}\par
00122     tmp_date_time.ss = 0;                                                                                   {\cf20 // Set seconds var to ZERO}\par
00123   \}\par
00124   {\cf19 return} tmp_date_time;                                                                                     {\cf20 // Return date/time var}\par
00125 \}\par
}
}
{\xe \v cmp_date_time\:lib_timer.h}
{\xe \v lib_timer.h\:cmp_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Cmp_res} cmp_date_time ({\b Date_time} *const  {\i date1}, const {\b Date_cmp}  {\i cmp_typ}, {\b Date_time} *const  {\i date2})}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to compare two input dates, detecting if the former is NEWER or OLDER than the latter.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i date1} \cell }{First date/time data-structure in comparison. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i cmp_typ} \cell }{Dates comparison type (NEWER/OLDER). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i date2} \cell }{Second date/time data-structure in comparison.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Return dates comparison result. \par
}}}{
Definition at line 137 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00137                                                                                              \{              {\cf20 // Compare date/time function}\par
00138   {\cf20 /* Body */}\par
00139   {\cf18 int} *date1_val_ptr = &date1->yyyy, *date2_val_ptr = &date2->yyyy;                                         {\cf20 // Date/time ptrs vals}\par
00140   {\cf19 for} (Byte idx = 1; *date1_val_ptr == *date2_val_ptr && idx < 6; ++idx)\{                                   {\cf20 // Compare and redefine date1 and date2 ptr vals FOR cylce (cycle 'till years/months/days/hours/minutes/seconds are different)}\par
00141     {\cf19 switch} (idx)\{                                                                                           {\cf20 // Redefinition index switch-case}\par
00142       {\cf19 case} 1:                                                                                               {\cf20 // If years are equivalents, check months}\par
00143         date1_val_ptr = &date1->mn;                                                                         {\cf20 // Redefine date1 ptr val to date1 months}\par
00144         date2_val_ptr = &date2->mn;                                                                         {\cf20 // Redefine date2 ptr val to date2 months}\par
00145         {\cf19 break};\par
00147       {\cf19 case} 2:                                                                                               {\cf20 // If months are equivalents, check days}\par
00148         date1_val_ptr = &date1->dd;                                                                         {\cf20 // Redefine date1 ptr val to date1 days}\par
00149         date2_val_ptr = &date2->dd;                                                                         {\cf20 // Redefine date2 ptr val to date2 days}\par
00150         {\cf19 break};\par
00152       {\cf19 case} 3:                                                                                               {\cf20 // If days are equivalents, check hours}\par
00153         date1_val_ptr = &date1->hh;                                                                         {\cf20 // Redefine date1 ptr val to date1 hours}\par
00154         date2_val_ptr = &date2->hh;                                                                         {\cf20 // Redefine date2 ptr val to date2 hours}\par
00155         {\cf19 break};\par
00157       {\cf19 case} 4:                                                                                               {\cf20 // If hours are equivalents, check minutes}\par
00158         date1_val_ptr = &date1->mm;                                                                         {\cf20 // Redefine date1 ptr val to date1 minutes}\par
00159         date2_val_ptr = &date2->mm;                                                                         {\cf20 // Redefine date2 ptr val to date2 minutes}\par
00160         {\cf19 break};\par
00162       {\cf19 case} 5:                                                                                               {\cf20 // If minutes are equivalents, check seconds}\par
00163         date1_val_ptr = &date1->ss;                                                                         {\cf20 // Redefine date1 ptr val to date1 seconds}\par
00164         date2_val_ptr = &date2->ss;                                                                         {\cf20 // Redefine date2 ptr val to date2 seconds}\par
00165         {\cf19 break};        \par
00166     \}\par
00167   \}\par
00168   {\cf19 if} ((cmp_typ == OLDER && *date1_val_ptr < *date2_val_ptr) ||\par
00169       (cmp_typ == NEWER && *date1_val_ptr > *date2_val_ptr))                                                {\cf20 // Comparison conditions, if comparison is OK}\par
00170     {\cf19 return} OK;                                                                                              {\cf20 // Return compare OK}\par
00171   {\cf19 else}                                                                                                      {\cf20 // Else if comparison is NOT-OK}\par
00172     {\cf19 return} NOT_OK;                                                                                          {\cf20 // Return compare NOT-OK}\par
00173 \}\par
}
}
{\xe \v delay\:lib_timer.h}
{\xe \v lib_timer.h\:delay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void delay (const long  {\i time_ms})}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to apply delay (wait specified delay time in milliseconds).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i time_ms} \cell }{Delay time in milliseconds to wait.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 61 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00061                               \{                                                                             {\cf20 // Delay [ms] function}\par
00062   {\cf20 /* Body */}\par
00063   {\cf19 if} (time_ms > 0)\{                                                                                         {\cf20 // Check ms-dly val}\par
00064     fflush(stdout);                                                                                         {\cf20 // Force pending terminal fbk prints}\par
00065     clock_t start_time = clock();                                                                           {\cf20 // Start time = software execution time}\par
00066     {\cf19 while} ((clock() - start_time) < (time_ms * (CLOCKS_PER_SEC / 1000)));                                   {\cf20 // Check if elapsed time [ms] (time - start_time) is greater or equal to pause time, pause time calculated considering the number of clocks per second}\par
00067   \} {\cf19 else}                                                                                                    {\cf20 // If ms-dly val ain't positive}\par
00068     perror({\cf22 "Error! Delay time must be greater than ZERO!"});                                                 {\cf20 // Print perror fbk}\par
00069 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_date_time\:lib_timer.h}
{\xe \v lib_timer.h\:fbk_gn_lbu_ye_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_date_time (const char *const  {\i prfx_str_lbu}, const {\b Date_time} *const  {\i date})}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print date/time light-blue/yellow feedback on terminal. In case date/time is invalid, print red error feedback.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i prfx_str_lbu} \cell }{Prefix feedback string to print (in light-blue color). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i date} \cell }{Date/time data-structure to print (in yellow color).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 185 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00185                                                                                          \{                  {\cf20 // Green-lightblue-yellow date/time val feedback function}\par
00186   {\cf20 /* Body */}\par
00187   {\cf19 if} (date->yyyy != 0 && date->mn != 0 && date->dd != 0 && date->hh != 0 && date->mm != 0 && date->ss != 0) {\cf20 // If date/time is correct}\par
00188     printf({\cf22 "%s>>>%s %s: %s%d%c%d%c%d%c%d%c%d%c%d%s"},\par
00189             GN, LBU, prfx_str_lbu, YE, date->yyyy, DATE_DELIM_CHR, date->mn, DATE_DELIM_CHR, date->dd,\par
00190             DATE_TIME_DELIM_CHR, date->hh-1, TIME_DELIM_CHR, date->mm-1, TIME_DELIM_CHR, date->ss-1, ER);   {\cf20 // Print green-lightblue-yellow date/time val feedback}\par
00191   {\cf19 else}                                                                                                      {\cf20 // Else if date/time ain't correct}\par
00192     fbk_err({\cf22 "Error! Invalid date/time"});                                                                    {\cf20 // Print error fbk}\par
00193 \}\par
}
}
{\xe \v get_date_time\:lib_timer.h}
{\xe \v lib_timer.h\:get_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Date_time} get_date_time ()}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to get current date and time values (saving them in {\b date_time} data-structure).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Return current date/time info in dedicated data-structure. \par
}}}{
Definition at line 77 of file lib_timer.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00077                          \{                                                                                  {\cf20 // Get date/time function}\par
00078   {\cf20 /* Body */}\par
00079   Date_time tmp_date_time;                                                                                  {\cf20 // Temporary date/time var to return}\par
00080   time_t now = time(NULL);                                                                                  {\cf20 // Now timer}\par
00081   {\cf17 struct }tm tm = *localtime(&now);                                                                          {\cf20 // Get now date/time}\par
00082   tmp_date_time.yyyy = 1900+tm.tm_year;                                                                     {\cf20 // Save years var}\par
00083   tmp_date_time.mn = 1+tm.tm_mon;                                                                           {\cf20 // Save months var}\par
00084   tmp_date_time.dd = tm.tm_mday;                                                                            {\cf20 // Save days var}\par
00085   tmp_date_time.hh = tm.tm_hour+1;                                                                          {\cf20 // Save hours var (+1)}\par
00086   tmp_date_time.mm = tm.tm_min+1;                                                                           {\cf20 // Save minutes var (+1)}\par
00087   tmp_date_time.ss = tm.tm_sec+1;                                                                           {\cf20 // Save seconds var (+1)}\par
00088   {\cf19 return} tmp_date_time;                                                                                     {\cf20 // Return date/time}\par
00089 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/timer/lib_timer.so File Reference\par \pard\plain 
{\tc\tcl2 \v lib/timer/lib_timer.so}
{\xe \v lib/timer/lib_timer.so}
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Timer-library object file}  }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Timer-library object file}  \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Library object file generated from {\b lib_timer.c} during compiling operations.}  \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/ui/lib_ui.c File Reference\par \pard\plain 
{\tc\tcl2 \v lib/ui/lib_ui.c}
{\xe \v lib/ui/lib_ui.c}
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b User-interface-library code file}  }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "lib_ui.h"}\par
{\f2 #include <limits.h>}\par
{\f2 #include <errno.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b unused} {\b __attribute__} (({\b unused}))\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Unused variabile to avoid compile-errors when a function has an unused return value, like scanf(). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logo} ({\b Cu_shrt} start_sp, {\b C_str} txt, {\b C_str} txt_col, {\b C_char} bkg_chr, {\b C_str} bkg_col)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b press_enter} ({\b C_str} req_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_nl} ({\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_spaces} ({\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_tabs} ({\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_separator} ({\b C_char} chr, {\b C_str} col)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_cy} ({\b C_str} fbk_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_pu} ({\b C_str} fbk_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_int} ({\b C_str} prfx_str_lbu, {\b C_int} val_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_str} ({\b C_str} prfx_str_lbu, {\b C_str} str_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_real} ({\b C_str} prfx_str_lbu, {\b C_real} val_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_lreal} ({\b C_str} prfx_str_lbu, {\b Cl_real} val_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_ptr} ({\b C_str} prfx_str_lbu, {\b C_ptr} val_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_err} ({\b C_str} fbk_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Str} {\b read_term_in} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clr_term_in} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Str} {\b read_term_in_min_chrs} ({\b C_byte} min_chrs, {\b C_str} req_str, {\b C_str} err_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Str} {\b read_term_in_min_chrs_exit_chr} ({\b C_byte} min_chrs, {\b C_str} req_str, {\b C_str} err_str, {\b C_char} exit_chr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Confirm} {\b read_term_in_confirm} ({\b C_str} req_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b read_term_in_int} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b read_term_in_int_inrange} ({\b C_int} min_val, {\b C_int} max_val, {\b C_str} req_str, {\b C_str} err_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_print} ({\b C_str} str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_str} ({\b C_str} str, {\b C_str} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_int} ({\b C_str} str, {\b C_int} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_real} ({\b C_str} str, {\b C_real} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_lreal} ({\b C_str} str, {\b Cl_real} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_ptr} ({\b C_str} str, {\b C_ptr} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_err} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_fbk} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_keyboard_interrupt} ({\b C_int} signal)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b term_in_buff} [{\b IN_BUFF_SIZE}] = ""\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Terminal-input buffer string variabile (size defined with {\b IN_BUFF_SIZE} macro), mainly used by scanf() function in terminal-input reading operations. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b User-interface-library code file}  \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i More info in {\b 'UI library'}  section inside doxygen {\b 'Related pages'} .}  \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:lib_ui.c}
{\xe \v lib_ui.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b unused} __attribute__ (({\b unused}) )}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Unused variabile to avoid compile-errors when a function has an unused return value, like scanf(). }}\par
}
{\xe \v close_err\:lib_ui.c}
{\xe \v lib_ui.c\:close_err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_err ()}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to close software with error feedback on terminal before closing (red colored error feedback).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 566 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00566                 \{                                                                                           {\cf20 // Function to close software with error feedback}\par
00567   {\cf20 /* Body */}\par
00568   printf({\cf22 "\\n%s>>>%s Closin' due to error... %sSorry! %s:(%s\\n"}, OG, RD, CY, OG, ER);                        {\cf20 // Closin' due to error fbk}\par
00569   exit(EXIT_FAILURE);                                                                                       {\cf20 // Close software}\par
00570 \}\par
}
}
{\xe \v close_fbk\:lib_ui.c}
{\xe \v lib_ui.c\:close_fbk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_fbk ()}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to close software with feedback on terminal before closing (multicolor closing feedback).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 578 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00578                 \{                                                                                           {\cf20 // Function to close software with feedback}\par
00579   {\cf20 /* Body */}\par
00580   printf({\cf22 "\\n\\n%s>>>%s Closin'... %sBye! %s;)%s\\n"}, GN, PU, CY, RD, ER);                                     {\cf20 // Closin' fbk}\par
00581   exit(EXIT_SUCCESS);                                                                                       {\cf20 // Close software}\par
00582 \}\par
}
}
{\xe \v close_keyboard_interrupt\:lib_ui.c}
{\xe \v lib_ui.c\:close_keyboard_interrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_keyboard_interrupt ({\b C_int}  {\i signal})}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to manage close keyboard interrupt signal, printing feedback to terminal and closing software with 'signal' value. Function called by {\b terminate_keyboard()} routine.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i signal} \cell }{Keyboard interrupt signal.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 593 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00593                                            \{                                                                {\cf20 // Function to close SW with fbk due to keyboard interrupt detected (ctrl+c)}\par
00594   {\cf20 /* Body */}\par
00595   printf({\cf22 "\\n\\n%s>>>%s Keyboard interrupt detected, closin'... %sBye! %s;)%s\\n"}, GN, PU, CY, RD, ER);        {\cf20 // Closin' fbk}\par
00596   exit(signal);                                                                                             {\cf20 // Exit SW with signal}\par
00597 \}\par
}
}
{\xe \v clr_term_in\:lib_ui.c}
{\xe \v lib_ui.c\:clr_term_in}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void clr_term_in ()}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to clear terminal-input buffer ({\b term_in_buff}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 287 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00287                   \{                                                                                         {\cf20 // Clear terminal input buffer function}\par
00288   {\cf20 /* Body */}\par
00289   strcpy(term_in_buff, {\cf22 "\\0"});                                                                               {\cf20 // Clear input buffer char array}\par
00290 \}\par
}
}
{\xe \v dbg\:lib_ui.c}
{\xe \v lib_ui.c\:dbg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg ()}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print debug symbol on terminal (light-green colored debug feedback).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 472 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00472           \{                                                                                                 {\cf20 // Fast debug function}\par
00473   {\cf20 /* Body */}\par
00474   printf({\cf22 "\\n\\n%s    >>>>>> %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, LGN, ER);                                   {\cf20 // Print debug line}\par
00475 \}\par
}
}
{\xe \v dbg_int\:lib_ui.c}
{\xe \v lib_ui.c\:dbg_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_int ({\b C_str}  {\i str}, {\b C_int}  {\i val})}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print integer debug feedback on terminal (light-green/yellow/orange colored debug feedback).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i str} \cell }{String to print (in yellow color). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{Integer value to print (in orange color)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 513 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00513                                   \{                                                                         {\cf20 // Debug int val print function}\par
00514   {\cf20 /* Body */}\par
00515   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%d %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);      {\cf20 // Print debug line}\par
00516 \}\par
}
}
{\xe \v dbg_lreal\:lib_ui.c}
{\xe \v lib_ui.c\:dbg_lreal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_lreal ({\b C_str}  {\i str}, {\b Cl_real}  {\i val})}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print {\b L_real} debug feedback on terminal (light-green/yellow/orange colored debug feedback).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i str} \cell }{String to print (in yellow color). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{{\b L_real} value to print (in orange color)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 541 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00541                                       \{                                                                     {\cf20 // Debug long real val print function}\par
00542   {\cf20 /* Body */}\par
00543   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%Lg %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);     {\cf20 // Print debug line}\par
00544 \}\par
}
}
{\xe \v dbg_print\:lib_ui.c}
{\xe \v lib_ui.c\:dbg_print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_print ({\b C_str}  {\i str})}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print debug feedback on terminal (light-green/yellow colored debug feedback).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i str} \cell }{String value to print (in yellow color).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 485 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00485                          \{                                                                                  {\cf20 // Debug print function}\par
00486   {\cf20 /* Body */}\par
00487   printf({\cf22 "\\n\\n%s    >>>>>>%s %s %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, LGN, ER);                     {\cf20 // Print debug line}\par
00488 \}\par
}
}
{\xe \v dbg_ptr\:lib_ui.c}
{\xe \v lib_ui.c\:dbg_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_ptr ({\b C_str}  {\i str}, {\b C_ptr}  {\i val})}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print {\b Ptr} debug feedback on terminal (light-green/yellow/orange colored debug feedback).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i str} \cell }{String to print (in yellow color). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{{\b Ptr} value to print (in orange color)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 555 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00555                                   \{                                                                         {\cf20 // Debug ptr val print function}\par
00556   {\cf20 /* Body */}\par
00557   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%p %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);      {\cf20 // Print debug line}\par
00558 \}\par
}
}
{\xe \v dbg_real\:lib_ui.c}
{\xe \v lib_ui.c\:dbg_real}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_real ({\b C_str}  {\i str}, {\b C_real}  {\i val})}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print {\b Real} debug feedback on terminal (light-green/yellow/orange colored debug feedback).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i str} \cell }{String to print (in yellow color). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{{\b Real} value to print (in orange color)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 527 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00527                                     \{                                                                       {\cf20 // Debug real val print function}\par
00528   {\cf20 /* Body */}\par
00529   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%g %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);      {\cf20 // Print debug line}\par
00530 \}\par
}
}
{\xe \v dbg_str\:lib_ui.c}
{\xe \v lib_ui.c\:dbg_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_str ({\b C_str}  {\i str}, {\b C_str}  {\i val})}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print string debug feedback on terminal (light-green/yellow/orange colored debug feedback).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i str} \cell }{String to print (in yellow color). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{String value to print (in orange color)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 499 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00499                                   \{                                                                         {\cf20 // Debug string val print function}\par
00500   {\cf20 /* Body */}\par
00501   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%s %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);      {\cf20 // Print debug line}\par
00502 \}\par
}
}
{\xe \v fbk_err\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_err ({\b C_str}  {\i fbk_str})}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print error feedback on terminal using red color.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i fbk_str} \cell }{Error feedback string to print (in red color with exclamation mark following).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 263 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00263                            \{                                                                                {\cf20 // Error feedback function}\par
00264   {\cf20 /* Body */}\par
00265   printf({\cf22 "\\n%s>>>%s %s!%s\\n"}, OG, RD, fbk_str, ER);                                                         {\cf20 // Print error fbk}\par
00266 \}\par
}
}
{\xe \v fbk_gn_cy\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_gn_cy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_cy ({\b C_str}  {\i fbk_str})}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print green/cyan feedback on terminal (generally used to print operation-completed feedbacks).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i fbk_str} \cell }{Feedback string to print.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 167 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00167                              \{                                                                              {\cf20 // Green-cyan feedback function}\par
00168   {\cf20 /* Body */}\par
00169   printf({\cf22 "%s>>>%s %s%s"}, GN, CY, fbk_str, ER);                                                              {\cf20 // Print green-cyan string fbk}\par
00170 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_int\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_gn_lbu_ye_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_int ({\b C_str}  {\i prfx_str_lbu}, {\b C_int}  {\i val_ye})}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print light-blue/yellow feedback on terminal (generally used to print integer feedbacks).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i prfx_str_lbu} \cell }{Prefix feedback string to print (in light-blue color). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val_ye} \cell }{Integer value to print (in yellow color).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 194 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00194                                                         \{                                                   {\cf20 // Green-lightblue-yellow int val feedback function}\par
00195   {\cf20 /* Body */}\par
00196   printf({\cf22 "%s>>>%s %s: %s%d%s"}, GN, LBU, prfx_str_lbu, YE, val_ye, ER);                                      {\cf20 // Print green-lightblue-yellow int val feedback}\par
00197 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_lreal\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_gn_lbu_ye_lreal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_lreal ({\b C_str}  {\i prfx_str_lbu}, {\b Cl_real}  {\i val_ye})}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print light-blue/yellow feedback on terminal (generally used to print {\b L_real} feedbacks).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i prfx_str_lbu} \cell }{Prefix feedback string to print (in light-blue color). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val_ye} \cell }{{\b L_real} value to print (in yellow color).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 236 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00236                                                             \{                                               {\cf20 // Green-lightblue-yellow long real val feedback function}\par
00237   {\cf20 /* Body */}\par
00238   printf({\cf22 "%s>>>%s %s: %s%Lg%s"}, GN, LBU, prfx_str_lbu, YE, val_ye, ER);                                     {\cf20 // Print green-lightblue-yellow long real val feedback}\par
00239 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_ptr\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_gn_lbu_ye_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_ptr ({\b C_str}  {\i prfx_str_lbu}, {\b C_ptr}  {\i val_ye})}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print light-blue/yellow feedback on terminal (generally used to print {\b Ptr} feedbacks).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i prfx_str_lbu} \cell }{Prefix feedback string to print (in light-blue color). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val_ye} \cell }{{\b Ptr} value to print (in yellow color).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 250 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00250                                                         \{                                                   {\cf20 // Green-lightblue-yellow ptr val feedback function}\par
00251   {\cf20 /* Body */}\par
00252   printf({\cf22 "%s>>>%s %s: %s%p%s"}, GN, LBU, prfx_str_lbu, YE, val_ye, ER);                                      {\cf20 // Print green-lightblue-yellow ptr val feedback}\par
00253 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_real\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_gn_lbu_ye_real}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_real ({\b C_str}  {\i prfx_str_lbu}, {\b C_real}  {\i val_ye})}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print light-blue/yellow feedback on terminal (generally used to print {\b Real} feedbacks).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i prfx_str_lbu} \cell }{Prefix feedback string to print (in light-blue color). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val_ye} \cell }{{\b Real} value to print (in yellow color).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 222 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00222                                                           \{                                                 {\cf20 // Green-lightblue-yellow real val feedback function}\par
00223   {\cf20 /* Body */}\par
00224   printf({\cf22 "%s>>>%s %s: %s%g%s"}, GN, LBU, prfx_str_lbu, YE, val_ye, ER);                                      {\cf20 // Print green-lightblue-yellow real val feedback}\par
00225 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_str\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_gn_lbu_ye_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_str ({\b C_str}  {\i prfx_str_lbu}, {\b C_str}  {\i str_ye})}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print light-blue/yellow feedback on terminal (generally used to print string feedbacks).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i prfx_str_lbu} \cell }{Prefix feedback string to print (in light-blue color). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val_ye} \cell }{String value to print (in yellow color).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 208 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00208                                                         \{                                                   {\cf20 // Green-lightblue-yellow str val feedback function}\par
00209   {\cf20 /* Body */}\par
00210   printf({\cf22 "%s>>>%s %s: %s%s%s"}, GN, LBU, prfx_str_lbu, YE, str_ye, ER);                                      {\cf20 // Print green-lightblue-yellow str val feedback}\par
00211 \}\par
}
}
{\xe \v fbk_gn_pu\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_gn_pu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_pu ({\b C_str}  {\i fbk_str})}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print green/purple feedback on terminal (generally used to print operation-start feedbacks).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i fbk_str} \cell }{Feedback string to print.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 180 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00180                              \{                                                                              {\cf20 // Green-purple feedback function}\par
00181   {\cf20 /* Body */}\par
00182   printf({\cf22 "%s>>>%s %s%s"}, GN, PU, fbk_str, ER);                                                              {\cf20 // Print green-purple string fbk}\par
00183 \}\par
}
}
{\xe \v fbk_nl\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_nl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_nl ({\b C_int}  {\i num})}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print new-lines feedback on terminal.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i num} \cell }{Number of new-lines to print.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 108 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00108                       \{                                                                                     {\cf20 // New lines feedback function}\par
00109   {\cf20 /* Body */}\par
00110   {\cf19 for} ({\cf18 int} i = 0; i < num; ++i)                                                                             {\cf20 // Chars printin' FOR cycle}\par
00111     printf({\cf22 "\\n"});                                                                                           {\cf20 // Print new line fbk}\par
00112 \}\par
}
}
{\xe \v fbk_separator\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_separator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_separator ({\b C_char}  {\i chr}, {\b C_str}  {\i col})}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print responsive text-separator on terminal depending on teminal size.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i chr} \cell }{Char to use in order to create the text-separator. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i col} \cell }{Color to use in order to create the text-separator (requires color macro).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 151 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00151                                          \{                                                                  {\cf20 // Separator feedback function}\par
00152   {\cf20 /* Body */}\par
00153   {\cf17 struct }winsize w;                                                                                         {\cf20 // Window-size struct declaration}\par
00154   ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);                                                                     {\cf20 // Save the number of terminal's rows/cloumns in window-size struct}\par
00155   {\cf19 for} ({\cf18 int} i = 0; i < w.ws_col; ++i)                                                                        {\cf20 // Chars printin' FOR cycle}\par
00156     printf({\cf22 "%s%c%s"}, col, chr, ER);                                                                         {\cf20 // Print space fbk}\par
00157 \}\par
}
}
{\xe \v fbk_spaces\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_spaces}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_spaces ({\b C_int}  {\i num})}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print spaces feedback on terminal.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i num} \cell }{Number of spaces to print.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 122 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00122                           \{                                                                                 {\cf20 // Spces feedback function}\par
00123   {\cf20 /* Body */}\par
00124   {\cf19 for} ({\cf18 int} i = 0; i < num; ++i)                                                                             {\cf20 // Chars printin' FOR cycle}\par
00125     printf({\cf22 " "});                                                                                            {\cf20 // Print space fbk}\par
00126 \}\par
}
}
{\xe \v fbk_tabs\:lib_ui.c}
{\xe \v lib_ui.c\:fbk_tabs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_tabs ({\b C_int}  {\i num})}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print tabs feedback on terminal.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i num} \cell }{Number of tabs to print.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 136 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00136                         \{                                                                                   {\cf20 // Tabs feedback function}\par
00137   {\cf20 /* Body */}\par
00138   {\cf19 for} ({\cf18 int} i = 0; i < num; ++i)                                                                             {\cf20 // Chars printin' FOR cycle}\par
00139     printf({\cf22 "\\t"});                                                                                           {\cf20 // Print tab fbk}\par
00140 \}\par
}
}
{\xe \v logo\:lib_ui.c}
{\xe \v lib_ui.c\:logo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void logo ({\b Cu_shrt}  {\i start_sp}, {\b C_str}  {\i txt}, {\b C_str}  {\i txt_col}, {\b C_char}  {\i bkg_chr}, {\b C_str}  {\i bkg_col})}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print responsive-logo on terminal depending on teminal size.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i start_sp} \cell }{Start (left) spaces in logo print; try to do the same on the right-side, rounding calculation result to integer value. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i txt} \cell }{Title text string. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i txt_col} \cell }{Title text color (requires color macro). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i bkg_chr} \cell }{Logo backgroung char. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i bkg_col} \cell }{Logo backgroung color (requires color macro).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 35 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00035                                                                                     \{                       {\cf20 // Print responsive-logo function}\par
00036   {\cf20 /* Body */}\par
00037   {\cf17 struct }winsize w;                                                                                         {\cf20 // Window-size struct declaration}\par
00038   ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);                                                                     {\cf20 // Save the number of terminal's rows/cloumns in window-size struct}\par
00039   Cu_shrt vthck = (w.ws_row / 5);                                                                           {\cf20 // Logo bkg vertical thickness calc}\par
00040   Cu_shrt lthck = (w.ws_col / 6);                                                                           {\cf20 // Logo bkg lateral thickness calc}\par
00041   Cu_shrt lsp = (Cu_shrt)(w.ws_col - 2*lthck - 2*start_sp - (Cu_shrt)strlen(txt)) / 2;                      {\cf20 // Logo internal lateral spaces calc}\par
00042   Cu_shrt len = (Cu_shrt)(2*lthck+2*lsp+(Cu_shrt)strlen(txt));                                              {\cf20 // Logo length calc}\par
00043   {\cf20 // Print logo}\par
00044   printf({\cf22 "\\n%s"}, bkg_col);                                                                                  {\cf20 // New line fbk}\par
00045   {\cf19 for} (U_shrt i = 0; i < (4*vthck+1); ++i)\{                                                                 {\cf20 // Logo lines print FOR cycle}\par
00046     {\cf19 for} (U_shrt j = 0; j < start_sp; ++j)\{                                                                  {\cf20 // Initial spaces print FOR cycle}\par
00047       printf({\cf22 " "});                                                                                          {\cf20 // Print initial spaces}\par
00048     \}\par
00049     {\cf19 if} ((i < vthck || i > (3*vthck)) && (i != (4*vthck)/2))\{                                                {\cf20 // Full bkg logo lines print cond}\par
00050       {\cf19 for} (U_shrt h = 0; h < len; ++h)\{                                                                     {\cf20 // Full bkg logo lines print FOR cycle}\par
00051         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Bkg logo char print}\par
00052       \}\par
00053       fbk_nl(1);                                                                                            {\cf20 // New line feedback function call}\par
00054     \} {\cf19 else} {\cf19 if} ((i >= vthck && i <= (3*vthck)) && (i != (4*vthck)/2)) \{                                      {\cf20 // Partial-empty bkg logo lines print cond}\par
00055       {\cf19 for} (U_shrt l = 0; l < lthck; ++l)\{                                                                   {\cf20 // Partial-empty bkg logo lines, initial full part print FOR cycle}\par
00056         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Partial-empty bkg logo lines, initial full part print}\par
00057       \}\par
00058       {\cf19 for} (U_shrt m = 0; m < (len - 2*lthck); ++m)\{                                                         {\cf20 // Partial-empty bkg logo lines, central empty part print FOR cycle}\par
00059         printf({\cf22 " "});                                                                                        {\cf20 // Partial-empty bkg logo lines, central empty part print}\par
00060       \}\par
00061       {\cf19 for} (U_shrt n = 0; n < lthck; ++n)\{                                                                   {\cf20 // Partial-empty bkg logo lines, final full part print FOR cycle}\par
00062         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Partial-empty bkg logo lines, final full part print}\par
00063       \}\par
00064       fbk_nl(1);                                                                                            {\cf20 // New line feedback function call}\par
00065     \} {\cf19 else} {\cf19 if} (i == ((4*vthck)/2)) \{                                                                        {\cf20 // Text logo line initial full part print cond}\par
00066       {\cf19 for} (U_shrt o = 0; o < lthck; ++o)\{                                                                   {\cf20 // Text logo line initial full part print FOR cycle}\par
00067         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Text logo line initial full part print}\par
00068       \}\par
00069       {\cf19 for} (U_shrt p = 0; p < lsp; ++p)\{                                                                     {\cf20 // Text logo line central empty part print FOR cycle}\par
00070         printf({\cf22 " "});                                                                                        {\cf20 // Text logo line central empty part print}\par
00071       \}\par
00072       printf({\cf22 "%s%s%s"}, txt_col, txt, bkg_col);                                                              {\cf20 // Text logo line central text part print}\par
00073       {\cf19 for} (U_shrt q = 0; q < lsp; ++q)\{                                                                     {\cf20 // Text logo line central empty part print FOR cycle}\par
00074         printf({\cf22 " "});                                                                                        {\cf20 // Text logo line central empty part print}\par
00075       \}\par
00076       {\cf19 for} (U_shrt r = 0; r < lthck; ++r)\{                                                                   {\cf20 // Text logo line final full part print FOR cycle}\par
00077         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Text logo line final full part print}\par
00078       \}\par
00079       fbk_nl(1);                                                                                            {\cf20 // New line feedback function call}\par
00080     \}\par
00081   \}\par
00082   printf(ER);                                                                                               {\cf20 // New line fbk and erase logo bkg color}\par
00083 \}\par
}
}
{\xe \v press_enter\:lib_ui.c}
{\xe \v lib_ui.c\:press_enter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void press_enter ({\b C_str}  {\i req_str})}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to request 'ENTER' key button to start software with request string printing on terminal.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i req_str} \cell }{Request string to print when asking for 'ENTER' key to start software.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 93 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00093                                \{                                                                            {\cf20 // Press enter function}\par
00094   {\cf20 /* Body */}\par
00095   printf({\cf22 "\\n\\n%s>>>%s %s! %sPress %sENTER%s to contine... %s;)%s"},\par
00096           GN, PU, req_str, CY, YE, CY, RD, ER);                                                             {\cf20 // Build map, press enter key to start fbk}\par
00097   read_term_in();                                                                                           {\cf20 // Wait enter key to start (read terminal input function call)}\par
00098 \}\par
}
}
{\xe \v read_term_in\:lib_ui.c}
{\xe \v lib_ui.c\:read_term_in}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Str} read_term_in ()}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to read user terminal-input using buffer defined in library ({\b term_in_buff}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Return user-input string inside {\b term_in_buff}. \par
}}}{
Definition at line 274 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00274                   \{                                                                                         {\cf20 // Read terminal input function}\par
00275   {\cf20 /* Body */}\par
00276   unused = scanf({\cf22 "%30[^\\n]"}, term_in_buff);                                                                 {\cf20 // Reads the string 'till '\\n' char, avoidin' scanf stop at space char and saving '\\n' chr (str var definition) --> avoid buffer overflow assigning max input str size to (31-1)=30 for '\\0' char}\par
00277   {\cf19 while} ((getchar()) != {\cf23 '\\n'});                                                                              {\cf20 // Instruction to clear input buffer when buffer overflow occurs, avoiding to save next char as new input}\par
00278   {\cf19 return} term_in_buff;                                                                                      {\cf20 // Return terminal input string}\par
00279 \}\par
}
}
{\xe \v read_term_in_confirm\:lib_ui.c}
{\xe \v lib_ui.c\:read_term_in_confirm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Confirm} read_term_in_confirm ({\b C_str}  {\i req_str})}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to read user terminal-input confirmation (YES/NO/CANEL). In addition, print request string and eventually, standard error string (in case the of unexpected answer from {\b read_term_in()} function).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i req_str} \cell }{Request string to print in green/purple color.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Return user-defined confirmation (by means of {\b confirm} enum). \par
}}}{
Definition at line 367 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00367                                            \{                                                                {\cf20 // Read terminal input confirmation function}\par
00368   {\cf20 /* Body */}\par
00369   Str in_str;                                                                                               {\cf20 // Terminal input string tmp var}\par
00370   Confirm answ;                                                                                             {\cf20 // Confirmation answer}\par
00371   Byte exit_flg = 0;                                                                                        {\cf20 // Terminal input while-loop exit flag}\par
00372   {\cf20 // Read input from terminal}\par
00373   {\cf19 do}\{\par
00374     clr_term_in();                                                                                          {\cf20 // Clear terminal input buffer function call}\par
00375     printf({\cf22 "%s>>>%s %s?%s Options %s(yes/no/cancel)%s%s: %s"}, GN, PU, req_str, BU, OG, BU, PU, ER);         {\cf20 // Print request fbk}\par
00376     in_str = read_term_in();                                                                                {\cf20 // Read terminal input function call}\par
00377     {\cf19 if} (0 == strcmp(in_str, {\cf22 "yes"}) || 0 == strcmp(in_str, {\cf22 "YES"}) || 0 == strcmp(in_str, {\cf22 "Yes"}))\{            {\cf20 // YES answer}\par
00378       answ = YES;                                                                                           {\cf20 // Set answer = YES}\par
00379       ++exit_flg;                                                                                           {\cf20 // Set exit flag}\par
00380     \} {\cf19 else} {\cf19 if} (0 == strcmp(in_str, {\cf22 "no"}) || 0 == strcmp(in_str, {\cf22 "NO"}) ||\par
00381                0 == strcmp(in_str, {\cf22 "No"}) || 0 == strcmp(in_str, {\cf22 "nO"}))\{                                     {\cf20 // NO answer}\par
00382       answ = NO;                                                                                            {\cf20 // Set answer = NO}\par
00383       ++exit_flg;                                                                                           {\cf20 // Set exit flag}\par
00384     \} {\cf19 else} {\cf19 if}(0 == strcmp(in_str, {\cf22 "cancel"}) || 0 == strcmp(in_str, {\cf22 "CANCEL"}) ||\par
00385               0 == strcmp(in_str, {\cf22 "Cancel"}))\{                                                               {\cf20 // CANCEL answer}\par
00386       answ = CANCEL;                                                                                        {\cf20 // Set answer = CANCEL}\par
00387       ++exit_flg;                                                                                           {\cf20 // Set exit flag}\par
00388     \}\par
00389     {\cf20 // Chk xit flg}\par
00390     {\cf19 if} (!exit_flg)                                                                                          {\cf20 // Exit flag val chack}\par
00391       printf({\cf22 "%s>>>%s The answer must be %s(yes/no/cancel)%s!%s\\n"}, OG, RD, YE, RD, ER);                    {\cf20 // Print terminal input error fbk}\par
00392   \} {\cf19 while}(!exit_flg);                                                                                       {\cf20 // Check while-loop exit flag val}\par
00393   \par
00394   {\cf19 return} answ;                                                                                              {\cf20 // Return confirmation answer}\par
00395 \}\par
}
}
{\xe \v read_term_in_int\:lib_ui.c}
{\xe \v lib_ui.c\:read_term_in_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int read_term_in_int ()}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to read integer terminal-input, converting string returned by {\b read_term_in()} function using strtol().\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Terminal input string converted into integer (value in LONG/INT range and string correctly converted). \par
}}}{
Definition at line 403 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00403                       \{                                                                                     {\cf20 // Read terminal input INT function}\par
00404   {\cf20 /* Body */}\par
00405   {\cf18 char} *tmp_ptr = NULL;                                                                                     {\cf20 // Tmp ptr var to check str-long conversion OK}\par
00406   {\cf18 long} val = 0;                                                                                             {\cf20 // Long converted value (then casted into integer value)}\par
00407   errno = 0;                                                                                                {\cf20 // Error lib-var}\par
00408   Byte err_flg = 0;                                                                                         {\cf20 // Error flag to quit acqisition cycle}\par
00409   {\cf20 // Read input from terminal}\par
00410   {\cf19 do} \{\par
00411     fbk_nl(1);  fbk_gn_pu({\cf22 "Please insert a value: "});                                                       {\cf20 // Print acquisition request fbk}\par
00412     val = strtol(read_term_in(), &tmp_ptr, 10);                                                             {\cf20 // Base-10 string-to-long conversion}\par
00413     {\cf20 // Chk err flg rst cond}\par
00414     {\cf19 if} (err_flg != 0)\{                                                                                      {\cf20 // Check err flg val, if it requires reset}\par
00415       err_flg = 0;                                                                                          {\cf20 // Rst it}\par
00416     \}\par
00417     {\cf19 if} (tmp_ptr == term_in_buff)\{                                                                           {\cf20 // If no characters were converted these pointers are equal}\par
00418       fbk_err({\cf22 "Ops! Encountered error during string to numerical value conversion from terminal-input"});    {\cf20 // Print error fbk}\par
00419       perror({\cf22 "Found error during string to value conversion using strtol()! Can't convert string!"});        {\cf20 // Print perror fbk}\par
00420       ++err_flg;                                                                                            {\cf20 // Set err flg}\par
00421     \} {\cf19 else} {\cf19 if} ((val == LONG_MAX || val == LONG_MIN) && errno == ERANGE)\{                                    {\cf20 // If sizeof(int) == sizeof(long), we have to explicitly check for overflows}\par
00422       fbk_err({\cf22 "Ops! Encountered error during string to long value conversion from terminal-input"});         {\cf20 // Print error fbk}\par
00423       perror({\cf22 "Found error during string to long conversion using strtol()! Number out of range for LONG!"}); {\cf20 // Print perror fbk}\par
00424       ++err_flg;                                                                                            {\cf20 // Set err flg}\par
00425     \} {\cf19 else} {\cf19 if} (val > INT_MAX || val < INT_MIN)\{                                                             {\cf20 // Because strtol produces a long, check for overflow}\par
00426       fbk_err({\cf22 "Ops! Encountered error during string to int value conversion from terminal-input"});          {\cf20 // Print error fbk}\par
00427       perror({\cf22 "Found error during string to int conversion using strtol()! Number out of range for INT!"});   {\cf20 // Print perror fbk}\par
00428       ++err_flg;                                                                                            {\cf20 // Set err flg}\par
00429     \}\par
00430   \} {\cf19 while}(err_flg != 0);                                                                                    {\cf20 // Check while-loop exit flag val (no errs)}\par
00431 \par
00432   {\cf19 return} ({\cf18 int})val;                                                                                          {\cf20 // Return integer conversion of input string}\par
00433 \}\par
}
}
{\xe \v read_term_in_int_inrange\:lib_ui.c}
{\xe \v lib_ui.c\:read_term_in_int_inrange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int read_term_in_int_inrange ({\b C_int}  {\i min_val}, {\b C_int}  {\i max_val}, {\b C_str}  {\i req_str}, {\b C_str}  {\i err_str})}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to read integer terminal-input in range (between min and max specified values - included), string to integer conversion with {\b read_term_in_int()} function.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i min_val} \cell }{Min integer range limit value. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i max_val} \cell }{Max integer range limit value. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i req_str} \cell }{Request string to print in green/purple color. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i err_str} \cell }{Error string to print in red color.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Return terminal input string converted into integer value, using function {\b read_term_in_int()}. \par
}}}{
Definition at line 446 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00446                                                                                         \{                   {\cf20 // Read terminal input INT (in-range) function}\par
00447   {\cf20 /* Body */}\par
00448   {\cf18 int} val = 0;                                                                                              {\cf20 // Terminal input value}\par
00449   Byte exit_flg = 0;                                                                                        {\cf20 // Terminal input while-loop exit flag}\par
00450   {\cf20 // Read terminal input}\par
00451   {\cf19 do}\{\par
00452     clr_term_in();                                                                                          {\cf20 // Clear terminal input buffer function call}\par
00453     printf({\cf22 "%s>>>%s %s %s(min %s%d%s, max %s%d%s)%s... %s"},\par
00454             GN, PU, req_str, BU, OG, min_val, BU, OG, max_val, BU, PU, ER);                                 {\cf20 // Enter the number of crosses to allocate fbk}\par
00455     val = read_term_in_int();                                                                               {\cf20 // Read terminal input INT function call}\par
00456     exit_flg = (val >= min_val && val <= max_val);                                                          {\cf20 // Terminal input while-loop exit flag val upd}\par
00457     {\cf20 // Chk xit flg}\par
00458     {\cf19 if} (!exit_flg)                                                                                          {\cf20 // Exit flag val chack}\par
00459       printf({\cf22 "%s>>>%s %s must be in %s[%d, %d]%s range!%s\\n\\n"},\par
00460               OG, RD, err_str, YE, min_val, max_val, RD, ER);                                               {\cf20 // Print terminal input error fbk}\par
00461   \} {\cf19 while}(!exit_flg);                                                                                       {\cf20 // Check while-loop exit flag val}\par
00462     \par
00463   {\cf19 return} val;                                                                                               {\cf20 // Return terminal input val}\par
00464 \}\par
}
}
{\xe \v read_term_in_min_chrs\:lib_ui.c}
{\xe \v lib_ui.c\:read_term_in_min_chrs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Str} read_term_in_min_chrs ({\b C_byte}  {\i min_chrs}, {\b C_str}  {\i req_str}, {\b C_str}  {\i err_str})}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to read user terminal-input expecting defined min number of chars. In addition, print request string and eventually, error string (in case the number of expected chars has not been reached - new request in loop until min number of expected chars has been reached).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i min_chrs} \cell }{Min number of expected chars in user terminal-input. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i req_str} \cell }{Request string to print in green/purple color. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i err_str} \cell }{Error string to print in red color.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Return user-input string from {\b read_term_in()} function. \par
}}}{
Definition at line 304 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00304                                                                         \{                                   {\cf20 // Read terminal input (min chars) function}\par
00305   {\cf20 /* Body */}\par
00306   Str in_str;                                                                                               {\cf20 // Terminal input string tmp var}\par
00307   Byte exit_flg = 0;                                                                                        {\cf20 // Terminal input while-loop exit flag}\par
00308   {\cf20 // Read input from terminal}\par
00309   {\cf19 do}\{\par
00310     clr_term_in();                                                                                          {\cf20 // Clear terminal input buffer function call}\par
00311     printf({\cf22 "\\n%s>>>%s %s,%s at least %s%d%s char(s), max %s%d%s chars%s: %s"},\par
00312             GN, PU, req_str, BU, OG, min_chrs, BU, OG, IN_BUFF_SIZE-1, BU, PU, ER);                         {\cf20 // Print request fbk}\par
00313     in_str = read_term_in();                                                                                {\cf20 // Read terminal input function call}\par
00314     exit_flg = (strlen(in_str) >= min_chrs);                                                                {\cf20 // Terminal input while-loop exit flag val upd}\par
00315     {\cf20 // Chk xit flg}\par
00316     {\cf19 if} (!exit_flg)                                                                                          {\cf20 // Exit flag val chack}\par
00317       printf({\cf22 "%s>>>%s %s must be at least %s%d%s char(s) long!%s\\n"},\par
00318               OG, RD, err_str, YE, min_chrs, RD, ER);                                                       {\cf20 // Print terminal input error fbk}\par
00319   \} {\cf19 while}(!exit_flg);                                                                                       {\cf20 // Check while-loop exit flag val}\par
00320   \par
00321   {\cf19 return} in_str;                                                                                            {\cf20 // Return terminal input string}\par
00322 \}\par
}
}
{\xe \v read_term_in_min_chrs_exit_chr\:lib_ui.c}
{\xe \v lib_ui.c\:read_term_in_min_chrs_exit_chr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Str} read_term_in_min_chrs_exit_chr ({\b C_byte}  {\i min_chrs}, {\b C_str}  {\i req_str}, {\b C_str}  {\i err_str}, {\b C_char}  {\i exit_chr})}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to read user terminal-input expecting defined min number of chars. In addition, print request string and eventually, error string (in case the number of expected chars has not been reached - new request in loop until min number of expected chars has been reached). Alternatively, exit acquisition loop when exit-char is detected.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i min_chrs} \cell }{Min number of expected chars in user terminal-input. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i req_str} \cell }{Request string to print in green/purple color. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i err_str} \cell }{Error string to print in red color. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i exit_chr} \cell }{Acquisition loop exit-char.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Return user-input string from {\b read_term_in()} function. \par
}}}{
Definition at line 338 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00338                                                                                                   \{         {\cf20 // Read terminal input (min chars and exit char) function}\par
00339   {\cf20 /* Body */}\par
00340   Str in_str;                                                                                               {\cf20 // Terminal input string tmp var}\par
00341   Byte exit_flg = 0;                                                                                        {\cf20 // Terminal input while-loop exit flag}\par
00342   {\cf20 // Read terminal input}\par
00343   {\cf19 do}\{\par
00344     clr_term_in();                                                                                          {\cf20 // Clear terminal input buffer function call}\par
00345     printf({\cf22 "%s>>>%s %s %s(at least %s%d%s char(s) and max %s%d%s, type %s'%c'%s char to continue)%s: %s"},\par
00346             GN, PU, req_str, BU, OG, min_chrs, BU, OG, IN_BUFF_SIZE-1, BU, OG, exit_chr, BU, PU, ER);       {\cf20 // Print request fbk}\par
00347     in_str = read_term_in();                                                                                {\cf20 // Read terminal input function call}\par
00348     exit_flg = (strlen(in_str) >= min_chrs) || (*in_str == exit_chr);                                       {\cf20 // Terminal input while-loop exit flag val upd}\par
00349     {\cf20 // Chk xit flg}\par
00350     {\cf19 if} (!exit_flg)                                                                                          {\cf20 // Exit flag val chack}\par
00351       printf({\cf22 "%s>>>%s %s must be at least %s%d%s char(s) long!%s\\n"},\par
00352               OG, RD, err_str, YE, min_chrs, RD, ER);                                                       {\cf20 // Print terminal input error fbk}\par
00353   \} {\cf19 while}(!exit_flg);                                                                                       {\cf20 // Check while-loop exit flag val}\par
00354   \par
00355   {\cf19 return} in_str;                                                                                            {\cf20 // Return terminal input string}\par
00356 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v term_in_buff\:lib_ui.c}
{\xe \v lib_ui.c\:term_in_buff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char term_in_buff[{\b IN_BUFF_SIZE}] = ""}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Terminal-input buffer string variabile (size defined with {\b IN_BUFF_SIZE} macro), mainly used by scanf() function in terminal-input reading operations. }}\par
{
Definition at line 18 of file lib_ui.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/ui/lib_ui.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/ui/lib_ui.h}
{\xe \v lib/ui/lib_ui.h}
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b User-interface-library header file}  }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <sys/ioctl.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <stdarg.h>}\par
{\f2 #include <signal.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IN_BUFF_SIZE}\~ 64\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Max terminal-input strings length in chars {\i (63 + '\\0')} , mainly used by scanf() function in terminal-input reading operations. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RD}\~ "\\033[0;31m"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  String to set terminal-color to red. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BU}\~ "\\033[0;34m"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  String to set terminal-color to blue. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LBU}\~ "\\033[1;34m"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  String to set terminal-color to light-blue. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PU}\~ "\\033[0;35m"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  String to set terminal-color to purple. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CY}\~ "\\033[0;36m"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  String to set terminal-color to cyan. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b YE}\~ "\\033[1;33m"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  String to set terminal-color to yellow. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OG}\~ "\\033[0;33m"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  String to set terminal-color to orange. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GN}\~ "\\033[0;32m"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  String to set terminal-color to green. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LGN}\~ "\\033[1;32m"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  String to set terminal-color to light-green. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LGY}\~ "\\033[0;37m"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  String to set terminal-color to light-gray. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ER}\~ "\\033[0m"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  String to erase terminal-color. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b confirm} {\b Confirm}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Confirmation enum for {\b read_term_in_confirm()} function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned char {\b Byte}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  unsigned char alias (Byte). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned short {\b U_shrt}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  unsigned short alias (U_shrt). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned int {\b U_int}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  unsigned int alias (U_int). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned long {\b U_long}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  unsigned long alias (U_long). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef double {\b Real}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  double alias (Real). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef long double {\b L_real}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  long double alias (L_real). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef char * {\b Str}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  char* alias (Str). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void * {\b Ptr}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  void* alias (Ptr). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef const {\b Cstr} {\b C_str}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  const char* const alias (C_str). }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b confirm} \{ {\b YES}, 
{\b NO}, 
{\b CANCEL}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Confirmation enum for {\b read_term_in_confirm()} function. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logo} ({\b Cu_shrt} start_sp, {\b C_str} txt, {\b C_str} txt_col, {\b C_char} bkg_chr, {\b C_str} bkg_col)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b press_enter} ({\b C_str} req_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_nl} ({\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_spaces} ({\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_tabs} ({\b C_int} num)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_separator} ({\b C_char} chr, {\b C_str} col)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_cy} ({\b C_str} fbk_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_pu} ({\b C_str} fbk_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_int} ({\b C_str} prfx_str_lbu, {\b C_int} val_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_str} ({\b C_str} prfx_str_lbu, {\b C_str} str_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_real} ({\b C_str} prfx_str_lbu, {\b C_real} val_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_lreal} ({\b C_str} prfx_str_lbu, {\b Cl_real} val_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_gn_lbu_ye_ptr} ({\b C_str} prfx_str_lbu, {\b C_ptr} val_ye)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fbk_err} ({\b C_str} fbk_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Str} {\b read_term_in} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clr_term_in} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Str} {\b read_term_in_min_chrs} ({\b C_byte} min_chrs, {\b C_str} req_str, {\b C_str} err_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Str} {\b read_term_in_min_chrs_exit_chr} ({\b C_byte} min_chrs, {\b C_str} req_str, {\b C_str} err_str, {\b C_char} exit_chr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Confirm} {\b read_term_in_confirm} ({\b C_str} req_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b read_term_in_int} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b read_term_in_int_inrange} ({\b C_int} min_val, {\b C_int} max_val, {\b C_str} req_str, {\b C_str} err_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_print} ({\b C_str} str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_str} ({\b C_str} str, {\b C_str} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_int} ({\b C_str} str, {\b C_int} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_real} ({\b C_str} str, {\b C_real} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_lreal} ({\b C_str} str, {\b Cl_real} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbg_ptr} ({\b C_str} str, {\b C_ptr} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_err} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_fbk} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_keyboard_interrupt} ({\b C_int} signal)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const typedef char {\b C_char}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  const char alias (C_char). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const typedef {\b Byte} {\b C_byte}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  const unsigned short alias (C_byte). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const typedef int {\b C_int}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  const int alias (C_int). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const typedef {\b Real} {\b C_real}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  const real alias (C_real). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const typedef long double {\b Cl_real}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  const long double alias (Cl_real). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const typedef {\b Str} {\b Cstr}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  const char* alias (Cstr). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const typedef {\b U_shrt} {\b Cu_shrt}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  const unsigned short alias (CU_shrt). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const typedef void *const {\b C_ptr}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  const void* const alias (C_ptr). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b term_in_buff} [{\b IN_BUFF_SIZE}]\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Terminal-input buffer string variabile (size defined with {\b IN_BUFF_SIZE} macro), mainly used by scanf() function in terminal-input reading operations. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b unused}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Unused variabile to avoid compile-errors when a function has an unused return value, like scanf(). }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b User-interface-library header file}  \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Library header file of {\b lib_ui.c}.}  \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v BU\:lib_ui.h}
{\xe \v lib_ui.h\:BU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BU\~ "\\033[0;34m"}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  String to set terminal-color to blue. }}\par
{
Definition at line 47 of file lib_ui.h.}\par
}
{\xe \v CY\:lib_ui.h}
{\xe \v lib_ui.h\:CY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CY\~ "\\033[0;36m"}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  String to set terminal-color to cyan. }}\par
{
Definition at line 53 of file lib_ui.h.}\par
}
{\xe \v ER\:lib_ui.h}
{\xe \v lib_ui.h\:ER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ER\~ "\\033[0m"}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  String to erase terminal-color. }}\par
{
Definition at line 65 of file lib_ui.h.}\par
}
{\xe \v GN\:lib_ui.h}
{\xe \v lib_ui.h\:GN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GN\~ "\\033[0;32m"}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  String to set terminal-color to green. }}\par
{
Definition at line 59 of file lib_ui.h.}\par
}
{\xe \v IN_BUFF_SIZE\:lib_ui.h}
{\xe \v lib_ui.h\:IN_BUFF_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IN_BUFF_SIZE\~ 64}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Max terminal-input strings length in chars {\i (63 + '\\0')} , mainly used by scanf() function in terminal-input reading operations. }}\par
{
Definition at line 43 of file lib_ui.h.}\par
}
{\xe \v LBU\:lib_ui.h}
{\xe \v lib_ui.h\:LBU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LBU\~ "\\033[1;34m"}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  String to set terminal-color to light-blue. }}\par
{
Definition at line 49 of file lib_ui.h.}\par
}
{\xe \v LGN\:lib_ui.h}
{\xe \v lib_ui.h\:LGN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LGN\~ "\\033[1;32m"}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  String to set terminal-color to light-green. }}\par
{
Definition at line 61 of file lib_ui.h.}\par
}
{\xe \v LGY\:lib_ui.h}
{\xe \v lib_ui.h\:LGY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LGY\~ "\\033[0;37m"}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  String to set terminal-color to light-gray. }}\par
{
Definition at line 63 of file lib_ui.h.}\par
}
{\xe \v OG\:lib_ui.h}
{\xe \v lib_ui.h\:OG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OG\~ "\\033[0;33m"}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  String to set terminal-color to orange. }}\par
{
Definition at line 57 of file lib_ui.h.}\par
}
{\xe \v PU\:lib_ui.h}
{\xe \v lib_ui.h\:PU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PU\~ "\\033[0;35m"}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  String to set terminal-color to purple. }}\par
{
Definition at line 51 of file lib_ui.h.}\par
}
{\xe \v RD\:lib_ui.h}
{\xe \v lib_ui.h\:RD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RD\~ "\\033[0;31m"}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  String to set terminal-color to red. }}\par
{
Definition at line 45 of file lib_ui.h.}\par
}
{\xe \v YE\:lib_ui.h}
{\xe \v lib_ui.h\:YE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define YE\~ "\\033[1;33m"}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  String to set terminal-color to yellow. }}\par
{
Definition at line 55 of file lib_ui.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v Byte\:lib_ui.h}
{\xe \v lib_ui.h\:Byte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned char {\b Byte}}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  unsigned char alias (Byte). }}\par
{
Definition at line 83 of file lib_ui.h.}\par
}
{\xe \v C_str\:lib_ui.h}
{\xe \v lib_ui.h\:C_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef const {\b Cstr} {\b C_str}}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  const char* const alias (C_str). }}\par
{
Definition at line 111 of file lib_ui.h.}\par
}
{\xe \v Confirm\:lib_ui.h}
{\xe \v lib_ui.h\:Confirm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b confirm} {\b Confirm}}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Confirmation enum for {\b read_term_in_confirm()} function. }}\par
}
{\xe \v L_real\:lib_ui.h}
{\xe \v lib_ui.h\:L_real}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef long double {\b L_real}}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  long double alias (L_real). }}\par
{
Definition at line 93 of file lib_ui.h.}\par
}
{\xe \v Ptr\:lib_ui.h}
{\xe \v lib_ui.h\:Ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void* {\b Ptr}}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  void* alias (Ptr). }}\par
{
Definition at line 97 of file lib_ui.h.}\par
}
{\xe \v Real\:lib_ui.h}
{\xe \v lib_ui.h\:Real}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef double {\b Real}}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  double alias (Real). }}\par
{
Definition at line 91 of file lib_ui.h.}\par
}
{\xe \v Str\:lib_ui.h}
{\xe \v lib_ui.h\:Str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef char* {\b Str}}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  char* alias (Str). }}\par
{
Definition at line 95 of file lib_ui.h.}\par
}
{\xe \v U_int\:lib_ui.h}
{\xe \v lib_ui.h\:U_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned int {\b U_int}}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  unsigned int alias (U_int). }}\par
{
Definition at line 87 of file lib_ui.h.}\par
}
{\xe \v U_long\:lib_ui.h}
{\xe \v lib_ui.h\:U_long}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned long {\b U_long}}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  unsigned long alias (U_long). }}\par
{
Definition at line 89 of file lib_ui.h.}\par
}
{\xe \v U_shrt\:lib_ui.h}
{\xe \v lib_ui.h\:U_shrt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned short {\b U_shrt}}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  unsigned short alias (U_shrt). }}\par
{
Definition at line 85 of file lib_ui.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v confirm\:lib_ui.h}
{\xe \v lib_ui.h\:confirm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b confirm}}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Confirmation enum for {\b read_term_in_confirm()} function. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v YES\:lib_ui.h}
{\xe \v lib_ui.h\:YES}
{\qr YES{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Yes, confirm request. \par
}\cell }{\row }
{\xe \v NO\:lib_ui.h}
{\xe \v lib_ui.h\:NO}
{\qr NO{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
No, do not confirm request. \par
}\cell }{\row }
{\xe \v CANCEL\:lib_ui.h}
{\xe \v lib_ui.h\:CANCEL}
{\qr CANCEL{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Cancel request. \par
}\cell }{\row }
}
{
Definition at line 78 of file lib_ui.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00078 \{YES, NO, CANCEL\} Confirm;                                                             {\cf20 // Confirmation enum typedef}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v close_err\:lib_ui.h}
{\xe \v lib_ui.h\:close_err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_err ()}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to close software with error feedback on terminal before closing (red colored error feedback).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 566 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00566                 \{                                                                                           {\cf20 // Function to close software with error feedback}\par
00567   {\cf20 /* Body */}\par
00568   printf({\cf22 "\\n%s>>>%s Closin' due to error... %sSorry! %s:(%s\\n"}, OG, RD, CY, OG, ER);                        {\cf20 // Closin' due to error fbk}\par
00569   exit(EXIT_FAILURE);                                                                                       {\cf20 // Close software}\par
00570 \}\par
}
}
{\xe \v close_fbk\:lib_ui.h}
{\xe \v lib_ui.h\:close_fbk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_fbk ()}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to close software with feedback on terminal before closing (multicolor closing feedback).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 578 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00578                 \{                                                                                           {\cf20 // Function to close software with feedback}\par
00579   {\cf20 /* Body */}\par
00580   printf({\cf22 "\\n\\n%s>>>%s Closin'... %sBye! %s;)%s\\n"}, GN, PU, CY, RD, ER);                                     {\cf20 // Closin' fbk}\par
00581   exit(EXIT_SUCCESS);                                                                                       {\cf20 // Close software}\par
00582 \}\par
}
}
{\xe \v close_keyboard_interrupt\:lib_ui.h}
{\xe \v lib_ui.h\:close_keyboard_interrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_keyboard_interrupt ({\b C_int}  {\i signal})}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to manage close keyboard interrupt signal, printing feedback to terminal and closing software with 'signal' value. Function called by {\b terminate_keyboard()} routine.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i signal} \cell }{Keyboard interrupt signal.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 593 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00593                                            \{                                                                {\cf20 // Function to close SW with fbk due to keyboard interrupt detected (ctrl+c)}\par
00594   {\cf20 /* Body */}\par
00595   printf({\cf22 "\\n\\n%s>>>%s Keyboard interrupt detected, closin'... %sBye! %s;)%s\\n"}, GN, PU, CY, RD, ER);        {\cf20 // Closin' fbk}\par
00596   exit(signal);                                                                                             {\cf20 // Exit SW with signal}\par
00597 \}\par
}
}
{\xe \v clr_term_in\:lib_ui.h}
{\xe \v lib_ui.h\:clr_term_in}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void clr_term_in ()}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to clear terminal-input buffer ({\b term_in_buff}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 287 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00287                   \{                                                                                         {\cf20 // Clear terminal input buffer function}\par
00288   {\cf20 /* Body */}\par
00289   strcpy(term_in_buff, {\cf22 "\\0"});                                                                               {\cf20 // Clear input buffer char array}\par
00290 \}\par
}
}
{\xe \v dbg\:lib_ui.h}
{\xe \v lib_ui.h\:dbg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg ()}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print debug symbol on terminal (light-green colored debug feedback).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 472 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00472           \{                                                                                                 {\cf20 // Fast debug function}\par
00473   {\cf20 /* Body */}\par
00474   printf({\cf22 "\\n\\n%s    >>>>>> %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, LGN, ER);                                   {\cf20 // Print debug line}\par
00475 \}\par
}
}
{\xe \v dbg_int\:lib_ui.h}
{\xe \v lib_ui.h\:dbg_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_int ({\b C_str}  {\i str}, {\b C_int}  {\i val})}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print integer debug feedback on terminal (light-green/yellow/orange colored debug feedback).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i str} \cell }{String to print (in yellow color). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{Integer value to print (in orange color)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 513 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00513                                   \{                                                                         {\cf20 // Debug int val print function}\par
00514   {\cf20 /* Body */}\par
00515   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%d %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);      {\cf20 // Print debug line}\par
00516 \}\par
}
}
{\xe \v dbg_lreal\:lib_ui.h}
{\xe \v lib_ui.h\:dbg_lreal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_lreal ({\b C_str}  {\i str}, {\b Cl_real}  {\i val})}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print {\b L_real} debug feedback on terminal (light-green/yellow/orange colored debug feedback).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i str} \cell }{String to print (in yellow color). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{{\b L_real} value to print (in orange color)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 541 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00541                                       \{                                                                     {\cf20 // Debug long real val print function}\par
00542   {\cf20 /* Body */}\par
00543   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%Lg %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);     {\cf20 // Print debug line}\par
00544 \}\par
}
}
{\xe \v dbg_print\:lib_ui.h}
{\xe \v lib_ui.h\:dbg_print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_print ({\b C_str}  {\i str})}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print debug feedback on terminal (light-green/yellow colored debug feedback).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i str} \cell }{String value to print (in yellow color).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 485 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00485                          \{                                                                                  {\cf20 // Debug print function}\par
00486   {\cf20 /* Body */}\par
00487   printf({\cf22 "\\n\\n%s    >>>>>>%s %s %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, LGN, ER);                     {\cf20 // Print debug line}\par
00488 \}\par
}
}
{\xe \v dbg_ptr\:lib_ui.h}
{\xe \v lib_ui.h\:dbg_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_ptr ({\b C_str}  {\i str}, {\b C_ptr}  {\i val})}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print {\b Ptr} debug feedback on terminal (light-green/yellow/orange colored debug feedback).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i str} \cell }{String to print (in yellow color). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{{\b Ptr} value to print (in orange color)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 555 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00555                                   \{                                                                         {\cf20 // Debug ptr val print function}\par
00556   {\cf20 /* Body */}\par
00557   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%p %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);      {\cf20 // Print debug line}\par
00558 \}\par
}
}
{\xe \v dbg_real\:lib_ui.h}
{\xe \v lib_ui.h\:dbg_real}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_real ({\b C_str}  {\i str}, {\b C_real}  {\i val})}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print {\b Real} debug feedback on terminal (light-green/yellow/orange colored debug feedback).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i str} \cell }{String to print (in yellow color). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{{\b Real} value to print (in orange color)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 527 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00527                                     \{                                                                       {\cf20 // Debug real val print function}\par
00528   {\cf20 /* Body */}\par
00529   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%g %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);      {\cf20 // Print debug line}\par
00530 \}\par
}
}
{\xe \v dbg_str\:lib_ui.h}
{\xe \v lib_ui.h\:dbg_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbg_str ({\b C_str}  {\i str}, {\b C_str}  {\i val})}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print string debug feedback on terminal (light-green/yellow/orange colored debug feedback).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i str} \cell }{String to print (in yellow color). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{String value to print (in orange color)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 499 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00499                                   \{                                                                         {\cf20 // Debug string val print function}\par
00500   {\cf20 /* Body */}\par
00501   printf({\cf22 "\\n\\n%s    >>>>>>%s %s: %s%s %s/*** DEBUG PRINT ***/%s\\n\\n"}, LGN, YE, str, OG, val, LGN, ER);      {\cf20 // Print debug line}\par
00502 \}\par
}
}
{\xe \v fbk_err\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_err ({\b C_str}  {\i fbk_str})}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print error feedback on terminal using red color.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i fbk_str} \cell }{Error feedback string to print (in red color with exclamation mark following).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 263 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00263                            \{                                                                                {\cf20 // Error feedback function}\par
00264   {\cf20 /* Body */}\par
00265   printf({\cf22 "\\n%s>>>%s %s!%s\\n"}, OG, RD, fbk_str, ER);                                                         {\cf20 // Print error fbk}\par
00266 \}\par
}
}
{\xe \v fbk_gn_cy\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_gn_cy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_cy ({\b C_str}  {\i fbk_str})}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print green/cyan feedback on terminal (generally used to print operation-completed feedbacks).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i fbk_str} \cell }{Feedback string to print.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 167 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00167                              \{                                                                              {\cf20 // Green-cyan feedback function}\par
00168   {\cf20 /* Body */}\par
00169   printf({\cf22 "%s>>>%s %s%s"}, GN, CY, fbk_str, ER);                                                              {\cf20 // Print green-cyan string fbk}\par
00170 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_int\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_gn_lbu_ye_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_int ({\b C_str}  {\i prfx_str_lbu}, {\b C_int}  {\i val_ye})}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print light-blue/yellow feedback on terminal (generally used to print integer feedbacks).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i prfx_str_lbu} \cell }{Prefix feedback string to print (in light-blue color). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val_ye} \cell }{Integer value to print (in yellow color).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 194 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00194                                                         \{                                                   {\cf20 // Green-lightblue-yellow int val feedback function}\par
00195   {\cf20 /* Body */}\par
00196   printf({\cf22 "%s>>>%s %s: %s%d%s"}, GN, LBU, prfx_str_lbu, YE, val_ye, ER);                                      {\cf20 // Print green-lightblue-yellow int val feedback}\par
00197 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_lreal\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_gn_lbu_ye_lreal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_lreal ({\b C_str}  {\i prfx_str_lbu}, {\b Cl_real}  {\i val_ye})}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print light-blue/yellow feedback on terminal (generally used to print {\b L_real} feedbacks).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i prfx_str_lbu} \cell }{Prefix feedback string to print (in light-blue color). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val_ye} \cell }{{\b L_real} value to print (in yellow color).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 236 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00236                                                             \{                                               {\cf20 // Green-lightblue-yellow long real val feedback function}\par
00237   {\cf20 /* Body */}\par
00238   printf({\cf22 "%s>>>%s %s: %s%Lg%s"}, GN, LBU, prfx_str_lbu, YE, val_ye, ER);                                     {\cf20 // Print green-lightblue-yellow long real val feedback}\par
00239 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_ptr\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_gn_lbu_ye_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_ptr ({\b C_str}  {\i prfx_str_lbu}, {\b C_ptr}  {\i val_ye})}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print light-blue/yellow feedback on terminal (generally used to print {\b Ptr} feedbacks).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i prfx_str_lbu} \cell }{Prefix feedback string to print (in light-blue color). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val_ye} \cell }{{\b Ptr} value to print (in yellow color).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 250 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00250                                                         \{                                                   {\cf20 // Green-lightblue-yellow ptr val feedback function}\par
00251   {\cf20 /* Body */}\par
00252   printf({\cf22 "%s>>>%s %s: %s%p%s"}, GN, LBU, prfx_str_lbu, YE, val_ye, ER);                                      {\cf20 // Print green-lightblue-yellow ptr val feedback}\par
00253 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_real\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_gn_lbu_ye_real}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_real ({\b C_str}  {\i prfx_str_lbu}, {\b C_real}  {\i val_ye})}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print light-blue/yellow feedback on terminal (generally used to print {\b Real} feedbacks).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i prfx_str_lbu} \cell }{Prefix feedback string to print (in light-blue color). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val_ye} \cell }{{\b Real} value to print (in yellow color).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 222 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00222                                                           \{                                                 {\cf20 // Green-lightblue-yellow real val feedback function}\par
00223   {\cf20 /* Body */}\par
00224   printf({\cf22 "%s>>>%s %s: %s%g%s"}, GN, LBU, prfx_str_lbu, YE, val_ye, ER);                                      {\cf20 // Print green-lightblue-yellow real val feedback}\par
00225 \}\par
}
}
{\xe \v fbk_gn_lbu_ye_str\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_gn_lbu_ye_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_lbu_ye_str ({\b C_str}  {\i prfx_str_lbu}, {\b C_str}  {\i str_ye})}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print light-blue/yellow feedback on terminal (generally used to print string feedbacks).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i prfx_str_lbu} \cell }{Prefix feedback string to print (in light-blue color). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val_ye} \cell }{String value to print (in yellow color).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 208 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00208                                                         \{                                                   {\cf20 // Green-lightblue-yellow str val feedback function}\par
00209   {\cf20 /* Body */}\par
00210   printf({\cf22 "%s>>>%s %s: %s%s%s"}, GN, LBU, prfx_str_lbu, YE, str_ye, ER);                                      {\cf20 // Print green-lightblue-yellow str val feedback}\par
00211 \}\par
}
}
{\xe \v fbk_gn_pu\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_gn_pu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_gn_pu ({\b C_str}  {\i fbk_str})}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print green/purple feedback on terminal (generally used to print operation-start feedbacks).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i fbk_str} \cell }{Feedback string to print.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 180 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00180                              \{                                                                              {\cf20 // Green-purple feedback function}\par
00181   {\cf20 /* Body */}\par
00182   printf({\cf22 "%s>>>%s %s%s"}, GN, PU, fbk_str, ER);                                                              {\cf20 // Print green-purple string fbk}\par
00183 \}\par
}
}
{\xe \v fbk_nl\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_nl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_nl ({\b C_int}  {\i num})}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print new-lines feedback on terminal.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i num} \cell }{Number of new-lines to print.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 108 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00108                       \{                                                                                     {\cf20 // New lines feedback function}\par
00109   {\cf20 /* Body */}\par
00110   {\cf19 for} ({\cf18 int} i = 0; i < num; ++i)                                                                             {\cf20 // Chars printin' FOR cycle}\par
00111     printf({\cf22 "\\n"});                                                                                           {\cf20 // Print new line fbk}\par
00112 \}\par
}
}
{\xe \v fbk_separator\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_separator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_separator ({\b C_char}  {\i chr}, {\b C_str}  {\i col})}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print responsive text-separator on terminal depending on teminal size.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i chr} \cell }{Char to use in order to create the text-separator. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i col} \cell }{Color to use in order to create the text-separator (requires color macro).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 151 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00151                                          \{                                                                  {\cf20 // Separator feedback function}\par
00152   {\cf20 /* Body */}\par
00153   {\cf17 struct }winsize w;                                                                                         {\cf20 // Window-size struct declaration}\par
00154   ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);                                                                     {\cf20 // Save the number of terminal's rows/cloumns in window-size struct}\par
00155   {\cf19 for} ({\cf18 int} i = 0; i < w.ws_col; ++i)                                                                        {\cf20 // Chars printin' FOR cycle}\par
00156     printf({\cf22 "%s%c%s"}, col, chr, ER);                                                                         {\cf20 // Print space fbk}\par
00157 \}\par
}
}
{\xe \v fbk_spaces\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_spaces}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_spaces ({\b C_int}  {\i num})}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print spaces feedback on terminal.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i num} \cell }{Number of spaces to print.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 122 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00122                           \{                                                                                 {\cf20 // Spces feedback function}\par
00123   {\cf20 /* Body */}\par
00124   {\cf19 for} ({\cf18 int} i = 0; i < num; ++i)                                                                             {\cf20 // Chars printin' FOR cycle}\par
00125     printf({\cf22 " "});                                                                                            {\cf20 // Print space fbk}\par
00126 \}\par
}
}
{\xe \v fbk_tabs\:lib_ui.h}
{\xe \v lib_ui.h\:fbk_tabs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fbk_tabs ({\b C_int}  {\i num})}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print tabs feedback on terminal.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i num} \cell }{Number of tabs to print.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 136 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00136                         \{                                                                                   {\cf20 // Tabs feedback function}\par
00137   {\cf20 /* Body */}\par
00138   {\cf19 for} ({\cf18 int} i = 0; i < num; ++i)                                                                             {\cf20 // Chars printin' FOR cycle}\par
00139     printf({\cf22 "\\t"});                                                                                           {\cf20 // Print tab fbk}\par
00140 \}\par
}
}
{\xe \v logo\:lib_ui.h}
{\xe \v lib_ui.h\:logo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void logo ({\b Cu_shrt}  {\i start_sp}, {\b C_str}  {\i txt}, {\b C_str}  {\i txt_col}, {\b C_char}  {\i bkg_chr}, {\b C_str}  {\i bkg_col})}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to print responsive-logo on terminal depending on teminal size.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i start_sp} \cell }{Start (left) spaces in logo print; try to do the same on the right-side, rounding calculation result to integer value. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i txt} \cell }{Title text string. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i txt_col} \cell }{Title text color (requires color macro). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i bkg_chr} \cell }{Logo backgroung char. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i bkg_col} \cell }{Logo backgroung color (requires color macro).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 35 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00035                                                                                     \{                       {\cf20 // Print responsive-logo function}\par
00036   {\cf20 /* Body */}\par
00037   {\cf17 struct }winsize w;                                                                                         {\cf20 // Window-size struct declaration}\par
00038   ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);                                                                     {\cf20 // Save the number of terminal's rows/cloumns in window-size struct}\par
00039   Cu_shrt vthck = (w.ws_row / 5);                                                                           {\cf20 // Logo bkg vertical thickness calc}\par
00040   Cu_shrt lthck = (w.ws_col / 6);                                                                           {\cf20 // Logo bkg lateral thickness calc}\par
00041   Cu_shrt lsp = (Cu_shrt)(w.ws_col - 2*lthck - 2*start_sp - (Cu_shrt)strlen(txt)) / 2;                      {\cf20 // Logo internal lateral spaces calc}\par
00042   Cu_shrt len = (Cu_shrt)(2*lthck+2*lsp+(Cu_shrt)strlen(txt));                                              {\cf20 // Logo length calc}\par
00043   {\cf20 // Print logo}\par
00044   printf({\cf22 "\\n%s"}, bkg_col);                                                                                  {\cf20 // New line fbk}\par
00045   {\cf19 for} (U_shrt i = 0; i < (4*vthck+1); ++i)\{                                                                 {\cf20 // Logo lines print FOR cycle}\par
00046     {\cf19 for} (U_shrt j = 0; j < start_sp; ++j)\{                                                                  {\cf20 // Initial spaces print FOR cycle}\par
00047       printf({\cf22 " "});                                                                                          {\cf20 // Print initial spaces}\par
00048     \}\par
00049     {\cf19 if} ((i < vthck || i > (3*vthck)) && (i != (4*vthck)/2))\{                                                {\cf20 // Full bkg logo lines print cond}\par
00050       {\cf19 for} (U_shrt h = 0; h < len; ++h)\{                                                                     {\cf20 // Full bkg logo lines print FOR cycle}\par
00051         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Bkg logo char print}\par
00052       \}\par
00053       fbk_nl(1);                                                                                            {\cf20 // New line feedback function call}\par
00054     \} {\cf19 else} {\cf19 if} ((i >= vthck && i <= (3*vthck)) && (i != (4*vthck)/2)) \{                                      {\cf20 // Partial-empty bkg logo lines print cond}\par
00055       {\cf19 for} (U_shrt l = 0; l < lthck; ++l)\{                                                                   {\cf20 // Partial-empty bkg logo lines, initial full part print FOR cycle}\par
00056         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Partial-empty bkg logo lines, initial full part print}\par
00057       \}\par
00058       {\cf19 for} (U_shrt m = 0; m < (len - 2*lthck); ++m)\{                                                         {\cf20 // Partial-empty bkg logo lines, central empty part print FOR cycle}\par
00059         printf({\cf22 " "});                                                                                        {\cf20 // Partial-empty bkg logo lines, central empty part print}\par
00060       \}\par
00061       {\cf19 for} (U_shrt n = 0; n < lthck; ++n)\{                                                                   {\cf20 // Partial-empty bkg logo lines, final full part print FOR cycle}\par
00062         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Partial-empty bkg logo lines, final full part print}\par
00063       \}\par
00064       fbk_nl(1);                                                                                            {\cf20 // New line feedback function call}\par
00065     \} {\cf19 else} {\cf19 if} (i == ((4*vthck)/2)) \{                                                                        {\cf20 // Text logo line initial full part print cond}\par
00066       {\cf19 for} (U_shrt o = 0; o < lthck; ++o)\{                                                                   {\cf20 // Text logo line initial full part print FOR cycle}\par
00067         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Text logo line initial full part print}\par
00068       \}\par
00069       {\cf19 for} (U_shrt p = 0; p < lsp; ++p)\{                                                                     {\cf20 // Text logo line central empty part print FOR cycle}\par
00070         printf({\cf22 " "});                                                                                        {\cf20 // Text logo line central empty part print}\par
00071       \}\par
00072       printf({\cf22 "%s%s%s"}, txt_col, txt, bkg_col);                                                              {\cf20 // Text logo line central text part print}\par
00073       {\cf19 for} (U_shrt q = 0; q < lsp; ++q)\{                                                                     {\cf20 // Text logo line central empty part print FOR cycle}\par
00074         printf({\cf22 " "});                                                                                        {\cf20 // Text logo line central empty part print}\par
00075       \}\par
00076       {\cf19 for} (U_shrt r = 0; r < lthck; ++r)\{                                                                   {\cf20 // Text logo line final full part print FOR cycle}\par
00077         printf({\cf22 "%c"}, bkg_chr);                                                                              {\cf20 // Text logo line final full part print}\par
00078       \}\par
00079       fbk_nl(1);                                                                                            {\cf20 // New line feedback function call}\par
00080     \}\par
00081   \}\par
00082   printf(ER);                                                                                               {\cf20 // New line fbk and erase logo bkg color}\par
00083 \}\par
}
}
{\xe \v press_enter\:lib_ui.h}
{\xe \v lib_ui.h\:press_enter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void press_enter ({\b C_str}  {\i req_str})}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to request 'ENTER' key button to start software with request string printing on terminal.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i req_str} \cell }{Request string to print when asking for 'ENTER' key to start software.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 93 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00093                                \{                                                                            {\cf20 // Press enter function}\par
00094   {\cf20 /* Body */}\par
00095   printf({\cf22 "\\n\\n%s>>>%s %s! %sPress %sENTER%s to contine... %s;)%s"},\par
00096           GN, PU, req_str, CY, YE, CY, RD, ER);                                                             {\cf20 // Build map, press enter key to start fbk}\par
00097   read_term_in();                                                                                           {\cf20 // Wait enter key to start (read terminal input function call)}\par
00098 \}\par
}
}
{\xe \v read_term_in\:lib_ui.h}
{\xe \v lib_ui.h\:read_term_in}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Str} read_term_in ()}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to read user terminal-input using buffer defined in library ({\b term_in_buff}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Return user-input string inside {\b term_in_buff}. \par
}}}{
Definition at line 274 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00274                   \{                                                                                         {\cf20 // Read terminal input function}\par
00275   {\cf20 /* Body */}\par
00276   unused = scanf({\cf22 "%30[^\\n]"}, term_in_buff);                                                                 {\cf20 // Reads the string 'till '\\n' char, avoidin' scanf stop at space char and saving '\\n' chr (str var definition) --> avoid buffer overflow assigning max input str size to (31-1)=30 for '\\0' char}\par
00277   {\cf19 while} ((getchar()) != {\cf23 '\\n'});                                                                              {\cf20 // Instruction to clear input buffer when buffer overflow occurs, avoiding to save next char as new input}\par
00278   {\cf19 return} term_in_buff;                                                                                      {\cf20 // Return terminal input string}\par
00279 \}\par
}
}
{\xe \v read_term_in_confirm\:lib_ui.h}
{\xe \v lib_ui.h\:read_term_in_confirm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Confirm} read_term_in_confirm ({\b C_str}  {\i req_str})}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to read user terminal-input confirmation (YES/NO/CANEL). In addition, print request string and eventually, standard error string (in case the of unexpected answer from {\b read_term_in()} function).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i req_str} \cell }{Request string to print in green/purple color.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Return user-defined confirmation (by means of {\b confirm} enum). \par
}}}{
Definition at line 367 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00367                                            \{                                                                {\cf20 // Read terminal input confirmation function}\par
00368   {\cf20 /* Body */}\par
00369   Str in_str;                                                                                               {\cf20 // Terminal input string tmp var}\par
00370   Confirm answ;                                                                                             {\cf20 // Confirmation answer}\par
00371   Byte exit_flg = 0;                                                                                        {\cf20 // Terminal input while-loop exit flag}\par
00372   {\cf20 // Read input from terminal}\par
00373   {\cf19 do}\{\par
00374     clr_term_in();                                                                                          {\cf20 // Clear terminal input buffer function call}\par
00375     printf({\cf22 "%s>>>%s %s?%s Options %s(yes/no/cancel)%s%s: %s"}, GN, PU, req_str, BU, OG, BU, PU, ER);         {\cf20 // Print request fbk}\par
00376     in_str = read_term_in();                                                                                {\cf20 // Read terminal input function call}\par
00377     {\cf19 if} (0 == strcmp(in_str, {\cf22 "yes"}) || 0 == strcmp(in_str, {\cf22 "YES"}) || 0 == strcmp(in_str, {\cf22 "Yes"}))\{            {\cf20 // YES answer}\par
00378       answ = YES;                                                                                           {\cf20 // Set answer = YES}\par
00379       ++exit_flg;                                                                                           {\cf20 // Set exit flag}\par
00380     \} {\cf19 else} {\cf19 if} (0 == strcmp(in_str, {\cf22 "no"}) || 0 == strcmp(in_str, {\cf22 "NO"}) ||\par
00381                0 == strcmp(in_str, {\cf22 "No"}) || 0 == strcmp(in_str, {\cf22 "nO"}))\{                                     {\cf20 // NO answer}\par
00382       answ = NO;                                                                                            {\cf20 // Set answer = NO}\par
00383       ++exit_flg;                                                                                           {\cf20 // Set exit flag}\par
00384     \} {\cf19 else} {\cf19 if}(0 == strcmp(in_str, {\cf22 "cancel"}) || 0 == strcmp(in_str, {\cf22 "CANCEL"}) ||\par
00385               0 == strcmp(in_str, {\cf22 "Cancel"}))\{                                                               {\cf20 // CANCEL answer}\par
00386       answ = CANCEL;                                                                                        {\cf20 // Set answer = CANCEL}\par
00387       ++exit_flg;                                                                                           {\cf20 // Set exit flag}\par
00388     \}\par
00389     {\cf20 // Chk xit flg}\par
00390     {\cf19 if} (!exit_flg)                                                                                          {\cf20 // Exit flag val chack}\par
00391       printf({\cf22 "%s>>>%s The answer must be %s(yes/no/cancel)%s!%s\\n"}, OG, RD, YE, RD, ER);                    {\cf20 // Print terminal input error fbk}\par
00392   \} {\cf19 while}(!exit_flg);                                                                                       {\cf20 // Check while-loop exit flag val}\par
00393   \par
00394   {\cf19 return} answ;                                                                                              {\cf20 // Return confirmation answer}\par
00395 \}\par
}
}
{\xe \v read_term_in_int\:lib_ui.h}
{\xe \v lib_ui.h\:read_term_in_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int read_term_in_int ()}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to read integer terminal-input, converting string returned by {\b read_term_in()} function using strtol().\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Terminal input string converted into integer (value in LONG/INT range and string correctly converted). \par
}}}{
Definition at line 403 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00403                       \{                                                                                     {\cf20 // Read terminal input INT function}\par
00404   {\cf20 /* Body */}\par
00405   {\cf18 char} *tmp_ptr = NULL;                                                                                     {\cf20 // Tmp ptr var to check str-long conversion OK}\par
00406   {\cf18 long} val = 0;                                                                                             {\cf20 // Long converted value (then casted into integer value)}\par
00407   errno = 0;                                                                                                {\cf20 // Error lib-var}\par
00408   Byte err_flg = 0;                                                                                         {\cf20 // Error flag to quit acqisition cycle}\par
00409   {\cf20 // Read input from terminal}\par
00410   {\cf19 do} \{\par
00411     fbk_nl(1);  fbk_gn_pu({\cf22 "Please insert a value: "});                                                       {\cf20 // Print acquisition request fbk}\par
00412     val = strtol(read_term_in(), &tmp_ptr, 10);                                                             {\cf20 // Base-10 string-to-long conversion}\par
00413     {\cf20 // Chk err flg rst cond}\par
00414     {\cf19 if} (err_flg != 0)\{                                                                                      {\cf20 // Check err flg val, if it requires reset}\par
00415       err_flg = 0;                                                                                          {\cf20 // Rst it}\par
00416     \}\par
00417     {\cf19 if} (tmp_ptr == term_in_buff)\{                                                                           {\cf20 // If no characters were converted these pointers are equal}\par
00418       fbk_err({\cf22 "Ops! Encountered error during string to numerical value conversion from terminal-input"});    {\cf20 // Print error fbk}\par
00419       perror({\cf22 "Found error during string to value conversion using strtol()! Can't convert string!"});        {\cf20 // Print perror fbk}\par
00420       ++err_flg;                                                                                            {\cf20 // Set err flg}\par
00421     \} {\cf19 else} {\cf19 if} ((val == LONG_MAX || val == LONG_MIN) && errno == ERANGE)\{                                    {\cf20 // If sizeof(int) == sizeof(long), we have to explicitly check for overflows}\par
00422       fbk_err({\cf22 "Ops! Encountered error during string to long value conversion from terminal-input"});         {\cf20 // Print error fbk}\par
00423       perror({\cf22 "Found error during string to long conversion using strtol()! Number out of range for LONG!"}); {\cf20 // Print perror fbk}\par
00424       ++err_flg;                                                                                            {\cf20 // Set err flg}\par
00425     \} {\cf19 else} {\cf19 if} (val > INT_MAX || val < INT_MIN)\{                                                             {\cf20 // Because strtol produces a long, check for overflow}\par
00426       fbk_err({\cf22 "Ops! Encountered error during string to int value conversion from terminal-input"});          {\cf20 // Print error fbk}\par
00427       perror({\cf22 "Found error during string to int conversion using strtol()! Number out of range for INT!"});   {\cf20 // Print perror fbk}\par
00428       ++err_flg;                                                                                            {\cf20 // Set err flg}\par
00429     \}\par
00430   \} {\cf19 while}(err_flg != 0);                                                                                    {\cf20 // Check while-loop exit flag val (no errs)}\par
00431 \par
00432   {\cf19 return} ({\cf18 int})val;                                                                                          {\cf20 // Return integer conversion of input string}\par
00433 \}\par
}
}
{\xe \v read_term_in_int_inrange\:lib_ui.h}
{\xe \v lib_ui.h\:read_term_in_int_inrange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int read_term_in_int_inrange ({\b C_int}  {\i min_val}, {\b C_int}  {\i max_val}, {\b C_str}  {\i req_str}, {\b C_str}  {\i err_str})}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to read integer terminal-input in range (between min and max specified values - included), string to integer conversion with {\b read_term_in_int()} function.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i min_val} \cell }{Min integer range limit value. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i max_val} \cell }{Max integer range limit value. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i req_str} \cell }{Request string to print in green/purple color. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i err_str} \cell }{Error string to print in red color.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Return terminal input string converted into integer value, using function {\b read_term_in_int()}. \par
}}}{
Definition at line 446 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00446                                                                                         \{                   {\cf20 // Read terminal input INT (in-range) function}\par
00447   {\cf20 /* Body */}\par
00448   {\cf18 int} val = 0;                                                                                              {\cf20 // Terminal input value}\par
00449   Byte exit_flg = 0;                                                                                        {\cf20 // Terminal input while-loop exit flag}\par
00450   {\cf20 // Read terminal input}\par
00451   {\cf19 do}\{\par
00452     clr_term_in();                                                                                          {\cf20 // Clear terminal input buffer function call}\par
00453     printf({\cf22 "%s>>>%s %s %s(min %s%d%s, max %s%d%s)%s... %s"},\par
00454             GN, PU, req_str, BU, OG, min_val, BU, OG, max_val, BU, PU, ER);                                 {\cf20 // Enter the number of crosses to allocate fbk}\par
00455     val = read_term_in_int();                                                                               {\cf20 // Read terminal input INT function call}\par
00456     exit_flg = (val >= min_val && val <= max_val);                                                          {\cf20 // Terminal input while-loop exit flag val upd}\par
00457     {\cf20 // Chk xit flg}\par
00458     {\cf19 if} (!exit_flg)                                                                                          {\cf20 // Exit flag val chack}\par
00459       printf({\cf22 "%s>>>%s %s must be in %s[%d, %d]%s range!%s\\n\\n"},\par
00460               OG, RD, err_str, YE, min_val, max_val, RD, ER);                                               {\cf20 // Print terminal input error fbk}\par
00461   \} {\cf19 while}(!exit_flg);                                                                                       {\cf20 // Check while-loop exit flag val}\par
00462     \par
00463   {\cf19 return} val;                                                                                               {\cf20 // Return terminal input val}\par
00464 \}\par
}
}
{\xe \v read_term_in_min_chrs\:lib_ui.h}
{\xe \v lib_ui.h\:read_term_in_min_chrs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Str} read_term_in_min_chrs ({\b C_byte}  {\i min_chrs}, {\b C_str}  {\i req_str}, {\b C_str}  {\i err_str})}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to read user terminal-input expecting defined min number of chars. In addition, print request string and eventually, error string (in case the number of expected chars has not been reached - new request in loop until min number of expected chars has been reached).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i min_chrs} \cell }{Min number of expected chars in user terminal-input. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i req_str} \cell }{Request string to print in green/purple color. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i err_str} \cell }{Error string to print in red color.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Return user-input string from {\b read_term_in()} function. \par
}}}{
Definition at line 304 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00304                                                                         \{                                   {\cf20 // Read terminal input (min chars) function}\par
00305   {\cf20 /* Body */}\par
00306   Str in_str;                                                                                               {\cf20 // Terminal input string tmp var}\par
00307   Byte exit_flg = 0;                                                                                        {\cf20 // Terminal input while-loop exit flag}\par
00308   {\cf20 // Read input from terminal}\par
00309   {\cf19 do}\{\par
00310     clr_term_in();                                                                                          {\cf20 // Clear terminal input buffer function call}\par
00311     printf({\cf22 "\\n%s>>>%s %s,%s at least %s%d%s char(s), max %s%d%s chars%s: %s"},\par
00312             GN, PU, req_str, BU, OG, min_chrs, BU, OG, IN_BUFF_SIZE-1, BU, PU, ER);                         {\cf20 // Print request fbk}\par
00313     in_str = read_term_in();                                                                                {\cf20 // Read terminal input function call}\par
00314     exit_flg = (strlen(in_str) >= min_chrs);                                                                {\cf20 // Terminal input while-loop exit flag val upd}\par
00315     {\cf20 // Chk xit flg}\par
00316     {\cf19 if} (!exit_flg)                                                                                          {\cf20 // Exit flag val chack}\par
00317       printf({\cf22 "%s>>>%s %s must be at least %s%d%s char(s) long!%s\\n"},\par
00318               OG, RD, err_str, YE, min_chrs, RD, ER);                                                       {\cf20 // Print terminal input error fbk}\par
00319   \} {\cf19 while}(!exit_flg);                                                                                       {\cf20 // Check while-loop exit flag val}\par
00320   \par
00321   {\cf19 return} in_str;                                                                                            {\cf20 // Return terminal input string}\par
00322 \}\par
}
}
{\xe \v read_term_in_min_chrs_exit_chr\:lib_ui.h}
{\xe \v lib_ui.h\:read_term_in_min_chrs_exit_chr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Str} read_term_in_min_chrs_exit_chr ({\b C_byte}  {\i min_chrs}, {\b C_str}  {\i req_str}, {\b C_str}  {\i err_str}, {\b C_char}  {\i exit_chr})}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Function to read user terminal-input expecting defined min number of chars. In addition, print request string and eventually, error string (in case the number of expected chars has not been reached - new request in loop until min number of expected chars has been reached). Alternatively, exit acquisition loop when exit-char is detected.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i min_chrs} \cell }{Min number of expected chars in user terminal-input. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i req_str} \cell }{Request string to print in green/purple color. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i err_str} \cell }{Error string to print in red color. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i exit_chr} \cell }{Acquisition loop exit-char.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Return user-input string from {\b read_term_in()} function. \par
}}}{
Definition at line 338 of file lib_ui.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00338                                                                                                   \{         {\cf20 // Read terminal input (min chars and exit char) function}\par
00339   {\cf20 /* Body */}\par
00340   Str in_str;                                                                                               {\cf20 // Terminal input string tmp var}\par
00341   Byte exit_flg = 0;                                                                                        {\cf20 // Terminal input while-loop exit flag}\par
00342   {\cf20 // Read terminal input}\par
00343   {\cf19 do}\{\par
00344     clr_term_in();                                                                                          {\cf20 // Clear terminal input buffer function call}\par
00345     printf({\cf22 "%s>>>%s %s %s(at least %s%d%s char(s) and max %s%d%s, type %s'%c'%s char to continue)%s: %s"},\par
00346             GN, PU, req_str, BU, OG, min_chrs, BU, OG, IN_BUFF_SIZE-1, BU, OG, exit_chr, BU, PU, ER);       {\cf20 // Print request fbk}\par
00347     in_str = read_term_in();                                                                                {\cf20 // Read terminal input function call}\par
00348     exit_flg = (strlen(in_str) >= min_chrs) || (*in_str == exit_chr);                                       {\cf20 // Terminal input while-loop exit flag val upd}\par
00349     {\cf20 // Chk xit flg}\par
00350     {\cf19 if} (!exit_flg)                                                                                          {\cf20 // Exit flag val chack}\par
00351       printf({\cf22 "%s>>>%s %s must be at least %s%d%s char(s) long!%s\\n"},\par
00352               OG, RD, err_str, YE, min_chrs, RD, ER);                                                       {\cf20 // Print terminal input error fbk}\par
00353   \} {\cf19 while}(!exit_flg);                                                                                       {\cf20 // Check while-loop exit flag val}\par
00354   \par
00355   {\cf19 return} in_str;                                                                                            {\cf20 // Return terminal input string}\par
00356 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v C_byte\:lib_ui.h}
{\xe \v lib_ui.h\:C_byte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const typedef {\b Byte} C_byte}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  const unsigned short alias (C_byte). }}\par
{
Definition at line 101 of file lib_ui.h.}\par
}
{\xe \v C_char\:lib_ui.h}
{\xe \v lib_ui.h\:C_char}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const typedef char C_char}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  const char alias (C_char). }}\par
{
Definition at line 99 of file lib_ui.h.}\par
}
{\xe \v C_int\:lib_ui.h}
{\xe \v lib_ui.h\:C_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const typedef int C_int}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  const int alias (C_int). }}\par
{
Definition at line 103 of file lib_ui.h.}\par
}
{\xe \v C_ptr\:lib_ui.h}
{\xe \v lib_ui.h\:C_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const typedef void* const C_ptr}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  const void* const alias (C_ptr). }}\par
{
Definition at line 115 of file lib_ui.h.}\par
}
{\xe \v C_real\:lib_ui.h}
{\xe \v lib_ui.h\:C_real}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const typedef {\b Real} C_real}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  const real alias (C_real). }}\par
{
Definition at line 105 of file lib_ui.h.}\par
}
{\xe \v Cl_real\:lib_ui.h}
{\xe \v lib_ui.h\:Cl_real}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const typedef long double Cl_real}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  const long double alias (Cl_real). }}\par
{
Definition at line 107 of file lib_ui.h.}\par
}
{\xe \v Cstr\:lib_ui.h}
{\xe \v lib_ui.h\:Cstr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const typedef {\b Str} Cstr}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  const char* alias (Cstr). }}\par
{
Definition at line 109 of file lib_ui.h.}\par
}
{\xe \v Cu_shrt\:lib_ui.h}
{\xe \v lib_ui.h\:Cu_shrt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const typedef {\b U_shrt} Cu_shrt}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Typedef description:}  const unsigned short alias (CU_shrt). }}\par
{
Definition at line 113 of file lib_ui.h.}\par
}
{\xe \v term_in_buff\:lib_ui.h}
{\xe \v lib_ui.h\:term_in_buff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char term_in_buff[{\b IN_BUFF_SIZE}]}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Terminal-input buffer string variabile (size defined with {\b IN_BUFF_SIZE} macro), mainly used by scanf() function in terminal-input reading operations. }}\par
{
Definition at line 18 of file lib_ui.c.}\par
}
{\xe \v unused\:lib_ui.h}
{\xe \v lib_ui.h\:unused}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int unused}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Public-variable description:}  Unused variabile to avoid compile-errors when a function has an unused return value, like scanf(). }}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/ui/lib_ui.so File Reference\par \pard\plain 
{\tc\tcl2 \v lib/ui/lib_ui.so}
{\xe \v lib/ui/lib_ui.so}
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b User-interface-library object file}  }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b User-interface-library object file}  \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Library object file generated from {\b lib_ui.c} during compiling operations.}  \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
main/graph_test.c File Reference\par \pard\plain 
{\tc\tcl2 \v main/graph_test.c}
{\xe \v main/graph_test.c}
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Graph-library test software main code file}  }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../lib/graph/lib_graph.h"}\par
{\f2 #include "../lib/files/lib_files.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b street}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Street struct typedef for graph-library test (use crosses and streets as example of archs and nodes). }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VERBOSE}\~ {\b Y}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Advanced verbose mode (Y/N) for {\b dijkstra_alg()} and {\b buid_shortest_path()} functions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SOURCE_NODE_NAME}\~ "Cross4"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Source node name for graph-library prepared testing mode, for {\b dijkstra_alg()} function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DESTINATION_NODE_NAME}\~ "Cross9"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Destination node name for graph-library prepared testing mode, for {\b buid_shortest_path()} function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEST_NODE_NAME_SPECIAL_CASE1}\~ "Cross4"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Destination node name for graph-library prepared testing mode special case1 (source = destination), for {\b buid_shortest_path()} function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEST_NODE_NAME_SPECIAL_CASE2}\~ "Cross10"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Destination node name for graph-library prepared testing mode special case2 (destination node unreachble), for {\b buid_shortest_path()} function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GPLOT_TEST_GRAPH_LAYOUT_CMD}\~ "gnuplot -e \\"load 'gnuplot/graph_plot.cmd'; pause -1\\""\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot graph plotting system command, for {\b display_test_graph()} function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GPLOT_SHORTEST_PATH_CMD}\~ "gnuplot -e \\"load 'gnuplot/shortest_plot.cmd'; pause -1\\""\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot graph and shortest path plotting system command, for {\b display_test_graph()} function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ARCHS_DAT_FILE}\~ "gnuplot/archs.dat"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot archs data file, for {\b build_shortest_path_graphics_data()} function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COSTS_DAT_FILE}\~ "gnuplot/costs.dat"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot arch-costs data file, for {\b build_shortest_path_graphics_data()} function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NODES_DAT_FILE}\~ "gnuplot/nodes.dat"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot nodes data file, for {\b build_shortest_path_graphics_data()} function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHORTEST_ARCHS_DAT_FILE}\~ "gnuplot/shortest_archs.dat"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot shortest-path archs data file, for {\b build_shortest_path_graphics_data()} function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHORTEST_COSTS_DAT_FILE}\~ "gnuplot/shortest_costs.dat"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot shortest-path arch-costs data file, for {\b build_shortest_path_graphics_data()} function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHORTEST_NODES_DAT_FILE}\~ "gnuplot/shortest_nodes.dat"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot shortest-path nodes data file (source and destination nodes excluded), for {\b build_shortest_path_graphics_data()} function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SRC_DEST_NODES_DAT_FILE}\~ "gnuplot/src_dest_nodes.dat"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot shortest-path source and destination nodes data file, for {\b build_shortest_path_graphics_data()} function. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b test_choice} {\b Test_choice}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Test-choice enum typedef to define graph-library testing mode: prepared test, personalized test or exit and close test software. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b street} {\b Street}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Street struct typedef for graph-library test (use crosses and streets as example of archs and nodes). }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b test_choice} \{ {\b PREPARED} =1, 
{\b PERSONALIZED}, 
{\b EXIT}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Test-choice enum typedef to define graph-library testing mode: prepared test, personalized test or exit and close test software. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b terminate_keyboard} (int signal)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b create_archs} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b create_nodes} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b create_connections} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b test_option_choice} ({\b Test_choice} *const choice)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b build_shortest_path_graphics_data} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b display_test_graph} ({\b C_str} cmd)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b apply_dijkstra} ({\b C_str} src_nd_name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b reconstruct_min_path} ({\b C_str} dest_nd_name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b define_src_node_name} ({\b Str} *src_nd_nm)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b define_dest_node_name} ({\b Str} *dest_nd_nm)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Street} {\b strts_vect} []\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Global-variable description:}  Street-structs vector (to dynamically initalize archs). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b C_str} {\b crss_names_vect} []\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Global-variable description:}  Cross-names vector (to dynamically initalize nodes). }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Graph-library test software main code file}  \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i More info in {\b 'Testing software'}  section inside doxygen {\b 'Related pages'} .}  \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ARCHS_DAT_FILE\:graph_test.c}
{\xe \v graph_test.c\:ARCHS_DAT_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ARCHS_DAT_FILE\~ "gnuplot/archs.dat"}}
\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot archs data file, for {\b build_shortest_path_graphics_data()} function. }}\par
{
Definition at line 152 of file graph_test.c.}\par
}
{\xe \v COSTS_DAT_FILE\:graph_test.c}
{\xe \v graph_test.c\:COSTS_DAT_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COSTS_DAT_FILE\~ "gnuplot/costs.dat"}}
\par
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot arch-costs data file, for {\b build_shortest_path_graphics_data()} function. }}\par
{
Definition at line 154 of file graph_test.c.}\par
}
{\xe \v DEST_NODE_NAME_SPECIAL_CASE1\:graph_test.c}
{\xe \v graph_test.c\:DEST_NODE_NAME_SPECIAL_CASE1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEST_NODE_NAME_SPECIAL_CASE1\~ "Cross4"}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Destination node name for graph-library prepared testing mode special case1 (source = destination), for {\b buid_shortest_path()} function. }}\par
{
Definition at line 144 of file graph_test.c.}\par
}
{\xe \v DEST_NODE_NAME_SPECIAL_CASE2\:graph_test.c}
{\xe \v graph_test.c\:DEST_NODE_NAME_SPECIAL_CASE2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEST_NODE_NAME_SPECIAL_CASE2\~ "Cross10"}}
\par
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Destination node name for graph-library prepared testing mode special case2 (destination node unreachble), for {\b buid_shortest_path()} function. }}\par
{
Definition at line 146 of file graph_test.c.}\par
}
{\xe \v DESTINATION_NODE_NAME\:graph_test.c}
{\xe \v graph_test.c\:DESTINATION_NODE_NAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DESTINATION_NODE_NAME\~ "Cross9"}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Destination node name for graph-library prepared testing mode, for {\b buid_shortest_path()} function. }}\par
{
Definition at line 142 of file graph_test.c.}\par
}
{\xe \v GPLOT_SHORTEST_PATH_CMD\:graph_test.c}
{\xe \v graph_test.c\:GPLOT_SHORTEST_PATH_CMD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GPLOT_SHORTEST_PATH_CMD\~ "gnuplot -e \\"load 'gnuplot/shortest_plot.cmd'; pause -1\\""}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot graph and shortest path plotting system command, for {\b display_test_graph()} function. }}\par
{
Definition at line 150 of file graph_test.c.}\par
}
{\xe \v GPLOT_TEST_GRAPH_LAYOUT_CMD\:graph_test.c}
{\xe \v graph_test.c\:GPLOT_TEST_GRAPH_LAYOUT_CMD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GPLOT_TEST_GRAPH_LAYOUT_CMD\~ "gnuplot -e \\"load 'gnuplot/graph_plot.cmd'; pause -1\\""}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot graph plotting system command, for {\b display_test_graph()} function. }}\par
{
Definition at line 148 of file graph_test.c.}\par
}
{\xe \v NODES_DAT_FILE\:graph_test.c}
{\xe \v graph_test.c\:NODES_DAT_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NODES_DAT_FILE\~ "gnuplot/nodes.dat"}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot nodes data file, for {\b build_shortest_path_graphics_data()} function. }}\par
{
Definition at line 156 of file graph_test.c.}\par
}
{\xe \v SHORTEST_ARCHS_DAT_FILE\:graph_test.c}
{\xe \v graph_test.c\:SHORTEST_ARCHS_DAT_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHORTEST_ARCHS_DAT_FILE\~ "gnuplot/shortest_archs.dat"}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot shortest-path archs data file, for {\b build_shortest_path_graphics_data()} function. }}\par
{
Definition at line 158 of file graph_test.c.}\par
}
{\xe \v SHORTEST_COSTS_DAT_FILE\:graph_test.c}
{\xe \v graph_test.c\:SHORTEST_COSTS_DAT_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHORTEST_COSTS_DAT_FILE\~ "gnuplot/shortest_costs.dat"}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot shortest-path arch-costs data file, for {\b build_shortest_path_graphics_data()} function. }}\par
{
Definition at line 160 of file graph_test.c.}\par
}
{\xe \v SHORTEST_NODES_DAT_FILE\:graph_test.c}
{\xe \v graph_test.c\:SHORTEST_NODES_DAT_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHORTEST_NODES_DAT_FILE\~ "gnuplot/shortest_nodes.dat"}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot shortest-path nodes data file (source and destination nodes excluded), for {\b build_shortest_path_graphics_data()} function. }}\par
{
Definition at line 162 of file graph_test.c.}\par
}
{\xe \v SOURCE_NODE_NAME\:graph_test.c}
{\xe \v graph_test.c\:SOURCE_NODE_NAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SOURCE_NODE_NAME\~ "Cross4"}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Source node name for graph-library prepared testing mode, for {\b dijkstra_alg()} function. }}\par
{
Definition at line 140 of file graph_test.c.}\par
}
{\xe \v SRC_DEST_NODES_DAT_FILE\:graph_test.c}
{\xe \v graph_test.c\:SRC_DEST_NODES_DAT_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SRC_DEST_NODES_DAT_FILE\~ "gnuplot/src_dest_nodes.dat"}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Gnuplot shortest-path source and destination nodes data file, for {\b build_shortest_path_graphics_data()} function. }}\par
{
Definition at line 164 of file graph_test.c.}\par
}
{\xe \v VERBOSE\:graph_test.c}
{\xe \v graph_test.c\:VERBOSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VERBOSE\~ {\b Y}}}
\par
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Macro description:}  Advanced verbose mode (Y/N) for {\b dijkstra_alg()} and {\b buid_shortest_path()} functions. }}\par
{
Definition at line 138 of file graph_test.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v Street\:graph_test.c}
{\xe \v graph_test.c\:Street}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b street} {\b Street}}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Struct-typedef description:}  Street struct typedef for graph-library test (use crosses and streets as example of archs and nodes). }}\par
}
{\xe \v Test_choice\:graph_test.c}
{\xe \v graph_test.c\:Test_choice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b test_choice} {\b Test_choice}}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Test-choice enum typedef to define graph-library testing mode: prepared test, personalized test or exit and close test software. }}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v test_choice\:graph_test.c}
{\xe \v graph_test.c\:test_choice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b test_choice}}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enum-typedef description:}  Test-choice enum typedef to define graph-library testing mode: prepared test, personalized test or exit and close test software. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v PREPARED\:graph_test.c}
{\xe \v graph_test.c\:PREPARED}
{\qr PREPARED{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prepared-test testing option: pre-defined source and destination nodes in graph to find min-cost path (defined with macros {\b SOURCE_NODE_NAME} and {\b DESTINATION_NODE_NAME}). \par
}\cell }{\row }
{\xe \v PERSONALIZED\:graph_test.c}
{\xe \v graph_test.c\:PERSONALIZED}
{\qr PERSONALIZED{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Personalized-test testing option: choose source and destination nodes in graph to find min-cost path. \par
}\cell }{\row }
{\xe \v EXIT\:graph_test.c}
{\xe \v graph_test.c\:EXIT}
{\qr EXIT{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exit option: deallocate graph structure and close software. \par
}\cell }{\row }
}
{
Definition at line 177 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00177 \{PREPARED=1, PERSONALIZED, EXIT\} Test_choice;                                      {\cf20 // Test-choice enum typedef}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v apply_dijkstra\:graph_test.c}
{\xe \v graph_test.c\:apply_dijkstra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void apply_dijkstra ({\b C_str}  {\i src_nd_name}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Static routine to apply Dijkstra's algorithm with verbose-mode enabled, from specified source node (selected by-name and checking if contained in nodes collection). Find min-cost paths from specified source node, towards each other node inside allocated graph. Find out if a specific possible destination node is unreachble, or if it corresponds to the source node.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i src_nd_name} \cell }{Source node name, from which to apply Dijkstra's algorithm.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 478 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00478                                              \{                                                              {\cf20 // Routine to apply Dijkstra's algorithm}\par
00479   {\cf20 /* Body */}\par
00480   dijkstra_alg(src_nd_name, VERBOSE);                                                                       {\cf20 // Apply Dijkstra alg using defined source node (find all min path-costs and prev nodes in shortest paths, Dijkstra-dataset vect allocated/reallocated inside heap) - Y/N for verbose mode}\par
00481 \}\par
}
}
{\xe \v build_shortest_path_graphics_data\:graph_test.c}
{\xe \v graph_test.c\:build_shortest_path_graphics_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void build_shortest_path_graphics_data (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Static routine to build shortest-path graphical data, working on gnuplt .dat data files (listed below) and defined with macros.{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Test-graph gnuplot data files (gnuplot data source)} :{
\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Archs data file} : {\b archs.dat} data file which contains the coordinates to draw arches in graph, with target name as comment in the previous line (defined in {\b ARCHS_DAT_FILE}).\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Costs data file} : {\b costs.dat} data file which contains the coordinates to draw arch-costs in graph, with target name as comment in the previous line (defined in {\b COSTS_DAT_FILE}).\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Nodes data file} : {\b nodes.dat} data file which contains the coordinates to draw nodes in graph, with target name as comment in the previous line (defined in {\b NODES_DAT_FILE}).\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Test-graph shortest path gnuplot data files (gnuplot data destination of selected elements to graphically recreate the min-cost path)} :{
\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Shortest-path archs data file} : {\b shortest_archs.dat} data file which contains the coordinates to draw arches in shortest-path graph, with target name as comment in the previous line (defined in {\b SHORTEST_ARCHS_DAT_FILE}).\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Shortest-path costs data file} : {\b shortest_costs.dat} data file which contains the coordinates to draw arch-costs in shortest-path graph, with target name as comment in the previous line (defined in {\b SHORTEST_ARCHS_DAT_FILE}).\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Shortest-path nodes data file (source-destination nodes excluded)} : {\b shortest_nodes.dat} data file which contains the coordinates to draw nodes in shortest-path graph (source-destination nodes excluded), with target name as comment in the previous line (defined in {\b SHORTEST_NODES_DAT_FILE}).\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Shortest-path source and destination nodes data file} : {\b src_dest_nodes.dat} data file which contains the coordinates to draw source and destination nodes in shortest-path graph, with target name as comment in the previous line (defined in {\b SRC_DEST_NODES_DAT_FILE}).\par}
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 345 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00345                                                \{                                                            {\cf20 // Routine to build the shortest-path graphics data for gnuplot}\par
00346   {\cf20 /* Body */}\par
00347   fbk_nl(1);  fbk_gn_pu({\cf22 "Building shortest-path graphics data (working on .dat files) for gnuplot..."});     {\cf20 // Print workin' on gnuplot graphics data files fbk}\par
00348   {\cf20 // Open .dat files}\par
00349   Fl archs_dat_file = open_file(ARCHS_DAT_FILE, {\cf22 "r"});                                                       {\cf20 // Open test-graph gnuplot arch-coords .dat file in read mode}\par
00350   Fl costs_dat_file = open_file(COSTS_DAT_FILE, {\cf22 "r"});                                                       {\cf20 // Open test-graph gnuplot arches cost-coords .dat file in read mode}\par
00351   Fl nodes_dat_file = open_file(NODES_DAT_FILE, {\cf22 "r"});                                                       {\cf20 // Open test-graph gnuplot node-coords .dat file in read mode}\par
00352   Fl shortest_archs_dat_file = open_file(SHORTEST_ARCHS_DAT_FILE, {\cf22 "w"});                                     {\cf20 // Open test-graph shortest path gnuplot arch-coords .dat file in write mode, clearin' file at open}\par
00353   Fl shortest_costs_dat_file = open_file(SHORTEST_COSTS_DAT_FILE, {\cf22 "w"});                                     {\cf20 // Open test-graph shortest path gnuplot arches cost-coords .dat file in write mode, clearin' file at open}\par
00354   Fl shortest_nodes_dat_file = open_file(SHORTEST_NODES_DAT_FILE, {\cf22 "w"});                                     {\cf20 // Open test-graph shortest path gnuplot node-coords .dat file in write mode, clearin' file at open}\par
00355   Fl src_dest_nodes_dat_file = open_file(SRC_DEST_NODES_DAT_FILE, {\cf22 "w"});                                     {\cf20 // Open test-graph gnuplot source and destination node-coords .dat file in write mode, clearin' file at open}\par
00356   {\cf20 // Check .dat files correctly opened}\par
00357   {\cf19 if} (archs_dat_file != NULL && costs_dat_file != NULL && nodes_dat_file != NULL &&\par
00358       shortest_archs_dat_file != NULL && shortest_costs_dat_file != NULL &&\par
00359       shortest_nodes_dat_file != NULL && src_dest_nodes_dat_file != NULL)\{                                  {\cf20 // If gnuplot .dat files has been correctly opened}\par
00360     {\cf20 // Vars init to modify gnuplot .dat files}\par
00361     {\cf18 int} tgt_line_num = 0;                                                                                   {\cf20 // Define target-line number var to find path archs/nodes coordinates in test-graph .dat files}\par
00362     Str tgt_line_str = NULL;                                                                                {\cf20 // Define target-line string var to copy path archs/nodes coordinates from test-graph .dat files to shortest-path and src-dest nodes .dat files}\par
00363     {\cf20 // Archs}\par
00364     {\cf19 for} ({\cf18 int} i = 1; i < min_pth_conn_vect_size; ++i)\{                                                       {\cf20 // Shortest-path archs scrollin' FOR cycle}\par
00365       rewind(archs_dat_file);                                                                               {\cf20 // Start/restart scannin' file from line 0}\par
00366       tgt_line_num = get_substr_line_from_file(archs_dat_file, min_path_conn_vect[i].ar->name);             {\cf20 // Define target line number by shortest-path arch name}\par
00367       {\cf19 if} (tgt_line_num >= 0)\{                                                                               {\cf20 // If arch name has been found in shortest-path archs}\par
00368         {\cf19 for} ({\cf18 int} j = 0; j < 3; ++j, ++tgt_line_num)\{                                                        {\cf20 // Extract target-line and the two following lines FOR cycle}\par
00369           rewind(archs_dat_file);                                                                           {\cf20 // Restart scannin' file from line 0}\par
00370           tgt_line_str = get_line_str_from_file(archs_dat_file, tgt_line_num);                              {\cf20 // Get extracted line content (str)}\par
00371           {\cf19 if} (tgt_line_str != NULL)\{                                                                        {\cf20 // If target string ain't NULL (no errors and string correctly acquired)}\par
00372             write_str_on_file(shortest_archs_dat_file, tgt_line_str);                                       {\cf20 // Write extracted string inside dedicated shortest-path gnuplot .dat file}\par
00373           \} {\cf19 else}                                                                                            {\cf20 // Else in case of target string null}\par
00374             fbk_err({\cf22 "Found error durig archs data copy in shortest path file! Check archs .dat file"});      {\cf20 // Print error fbk}\par
00375         \}\par
00376         write_nl_on_file(shortest_archs_dat_file);                                                          {\cf20 // Write new line inside dedicated shortest-path gnuplot .dat file}\par
00377       \} {\cf19 else}                                                                                                {\cf20 // Else in case of no-match found}\par
00378         fbk_err({\cf22 "Encountered error durig archs data copy in shortest path file! Check archs .dat file"});    {\cf20 // Print error fbk}\par
00379     \}\par
00380     {\cf20 // Arch-costs}\par
00381     {\cf19 for} ({\cf18 int} i = 1; i < min_pth_conn_vect_size; ++i)\{                                                       {\cf20 // Shortest-path arch-costs scrollin' FOR cycle}\par
00382       rewind(costs_dat_file);                                                                               {\cf20 // Start/restart scannin' file from line 0}\par
00383       tgt_line_num = get_substr_line_from_file(costs_dat_file, min_path_conn_vect[i].ar->name);             {\cf20 // Define target line number by shortest-path arch name}\par
00384       {\cf19 if} (tgt_line_num >= 0)\{                                                                               {\cf20 // If arch name has been found in shortest-path archs}\par
00385         {\cf19 for} ({\cf18 int} j = 0; j < 2; ++j, ++tgt_line_num)\{                                                        {\cf20 // Extract target-line and the following line FOR cycle}\par
00386           rewind(costs_dat_file);                                                                           {\cf20 // Restart scannin' file from line 0}\par
00387           tgt_line_str = get_line_str_from_file(costs_dat_file, tgt_line_num);                              {\cf20 // Get extracted line content (str)}\par
00388           {\cf19 if} (tgt_line_str != NULL)\{                                                                        {\cf20 // If target string ain't NULL (no errors and string correctly acquired)}\par
00389             write_str_on_file(shortest_costs_dat_file, tgt_line_str);                                       {\cf20 // Write extracted string inside dedicated shortest-path gnuplot .dat file}\par
00390           \} {\cf19 else}                                                                                            {\cf20 // Else in case of target string null}\par
00391             fbk_err({\cf22 "Found error durig costs data copy in shortest path file! Check costs .dat file"});      {\cf20 // Print error fbk}\par
00392         \}\par
00393         write_nl_on_file(shortest_costs_dat_file);                                                          {\cf20 // Write new line inside dedicated shortest-path gnuplot .dat file}\par
00394       \} {\cf19 else}                                                                                                {\cf20 // Else in case of no-match found}\par
00395         fbk_err({\cf22 "Encountered error durig costs data copy in shortest path file! Check costs .dat file"});    {\cf20 // Print error fbk}\par
00396     \}\par
00397     {\cf20 // Nodes (source and destination excluded)}\par
00398     {\cf19 for} ({\cf18 int} i = 1; i < min_pth_conn_vect_size-1; ++i)\{                                                     {\cf20 // Shortest-path intermediate-nodes scrollin' FOR cycle}\par
00399       rewind(nodes_dat_file);                                                                               {\cf20 // Start/restart scannin' file from line 0}\par
00400       tgt_line_num = get_substr_line_from_file(nodes_dat_file, min_path_conn_vect[i].nd->name);             {\cf20 // Define target line number by shortest-path node name}\par
00401       {\cf19 if} (tgt_line_num >= 0)\{                                                                               {\cf20 // If node name has been found in shortest-path nodes}\par
00402         {\cf19 for} ({\cf18 int} j = 0; j < 2; ++j, ++tgt_line_num)\{                                                        {\cf20 // Extract target-line and the following line FOR cycle}\par
00403           rewind(nodes_dat_file);                                                                           {\cf20 // Restart scannin' file from line 0}\par
00404           tgt_line_str = get_line_str_from_file(nodes_dat_file, tgt_line_num);                              {\cf20 // Get extracted line content (str)}\par
00405           {\cf19 if} (tgt_line_str != NULL)\{                                                                        {\cf20 // If target string ain't NULL (no errors and string correctly acquired)}\par
00406             write_str_on_file(shortest_nodes_dat_file, tgt_line_str);                                       {\cf20 // Write extracted string inside dedicated shortest-path gnuplot .dat file}\par
00407           \} {\cf19 else}                                                                                            {\cf20 // Else in case of target string null}\par
00408             fbk_err({\cf22 "Found error durig nodes data copy in shortest path file! Check nodes .dat file"});      {\cf20 // Print error fbk}\par
00409         \}\par
00410         write_nl_on_file(shortest_nodes_dat_file);                                                          {\cf20 // Write new line inside dedicated shortest-path gnuplot .dat file}\par
00411       \} {\cf19 else}                                                                                                {\cf20 // Else in case of no-match found}\par
00412         fbk_err({\cf22 "Encountered error durig nodes data copy in shortest path file! Check nodes .dat file"});    {\cf20 // Print error fbk}\par
00413     \}\par
00414     {\cf20 // Source and destination nodes}\par
00415     {\cf19 for} ({\cf18 int} i = 0; i < min_pth_conn_vect_size; i += (min_pth_conn_vect_size-1))\{                           {\cf20 // Shortest-path source and destination nodes scrollin' FOR cycle}\par
00416       rewind(nodes_dat_file);                                                                               {\cf20 // Restart scannin' file from line 0}\par
00417       tgt_line_num = get_substr_line_from_file(nodes_dat_file, min_path_conn_vect[i].nd->name);             {\cf20 // Define target line number by shortest-path node name}\par
00418       {\cf19 if} (tgt_line_num >= 0)\{                                                                               {\cf20 // If node name has been found in shortest-path nodes}\par
00419         {\cf19 for} ({\cf18 int} j = 0; j < 2; ++j, ++tgt_line_num)\{                                                        {\cf20 // Extract target-line and the following line FOR cycle}\par
00420           rewind(nodes_dat_file);                                                                           {\cf20 // Restart scannin' file from line 0}\par
00421           tgt_line_str = get_line_str_from_file(nodes_dat_file, tgt_line_num);                              {\cf20 // Get extracted line content (str)}\par
00422           {\cf19 if} (tgt_line_str != NULL)\{                                                                        {\cf20 // If target string ain't NULL (no errors and string correctly acquired)}\par
00423             write_str_on_file(src_dest_nodes_dat_file, tgt_line_str);                                       {\cf20 // Write extracted string inside dedicated shortest-path gnuplot .dat file}\par
00424           \} {\cf19 else}                                                                                            {\cf20 // Else in case of target string null}\par
00425             fbk_err({\cf22 "Found error durig src-dest data copy in shortest path file! Check nodes .dat file"});   {\cf20 // Print error fbk}\par
00426         \}\par
00427         write_nl_on_file(src_dest_nodes_dat_file);                                                          {\cf20 // Write new line inside dedicated shortest-path gnuplot .dat file}\par
00428       \} {\cf19 else}                                                                                                {\cf20 // Else in case of no-match found}\par
00429         fbk_err({\cf22 "Encountered error durig src-dest data copy in shortest path file! Check nodes .dat file"}); {\cf20 // Print error fbk}\par
00430     \}\par
00431     {\cf20 // Close .dat files}\par
00432     close_file(archs_dat_file);                                                                             {\cf20 // Close test-graph gnuplot arch-coords .dat file}\par
00433     close_file(costs_dat_file);                                                                             {\cf20 // Close test-graph gnuplot arches cost-coords .dat file}\par
00434     close_file(nodes_dat_file);                                                                             {\cf20 // Close test-graph gnuplot node-coords .dat file}\par
00435     close_file(shortest_archs_dat_file);                                                                    {\cf20 // Close test-graph shortest path gnuplot arch-coords .dat file}\par
00436     close_file(shortest_costs_dat_file);                                                                    {\cf20 // Close test-graph shortest path gnuplot arches cost-coords .dat file}\par
00437     close_file(shortest_nodes_dat_file);                                                                    {\cf20 // Close test-graph shortest path gnuplot node-coords .dat file}\par
00438     close_file(src_dest_nodes_dat_file);                                                                    {\cf20 // Close test-graph gnuplot source and destination node-coords .dat file}\par
00439     fbk_nl(1);  fbk_gn_cy({\cf22 "Shortest-path graphics data managenent for gnuplot completed!\\n"});               {\cf20 // Print Shortest-path graphics data managenent completed fbk}\par
00440   \} {\cf19 else}                                                                                                    {\cf20 // Else if gnuplot .dat files ain't been correctly opened}\par
00441     fbk_err({\cf22 "Ops! Something went wrong during shortest-path graphics data managenent for gnuplot"});         {\cf20 // Print err fbk}\par
00442 \}\par
}
}
{\xe \v create_archs\:graph_test.c}
{\xe \v graph_test.c\:create_archs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void create_archs (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Static routine to create test-graph arches, working on graph-library public variables.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 220 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00220                           \{                                                                                 {\cf20 // Routine to create archs}\par
00221   {\cf20 /* Body */}\par
00222   {\cf19 for} ({\cf18 int} i = 0; i < (int)({\cf17 sizeof}(strts_vect)/{\cf17 sizeof}({\cf17 const} Street)); ++i)                                  {\cf20 // Streets allocation FOR cycle}\par
00223     add_new_arch((C_str)strts_vect[i].name, strts_vect[i].length);                                          {\cf20 // Create new street (arch allocated inside heap)}\par
00224 \}\par
}
}
{\xe \v create_connections\:graph_test.c}
{\xe \v graph_test.c\:create_connections}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void create_connections (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Static routine to create test-graph arch-nodes connections, working on graph-library public variables.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 244 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00244                                 \{                                                                           {\cf20 // Routine to create connections btwn archs & nodes}\par
00245   {\cf20 /* Body */}\par
00246   connect_node_arch((C_str)strts_vect[0].name, crss_names_vect[0], ARCH_ND1, LIST_TAIL);                    {\cf20 // Connect "Street1" to "Cross1"}\par
00247   connect_node_arch((C_str)strts_vect[0].name, crss_names_vect[1], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street1" to "Cross2"}\par
00248   connect_node_arch((C_str)strts_vect[1].name, crss_names_vect[0], ARCH_ND1, LIST_TAIL);                    {\cf20 // Connect "Street2" to "Cross1"}\par
00249   connect_node_arch((C_str)strts_vect[1].name, crss_names_vect[2], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street2" to "Cross3"}\par
00250   connect_node_arch((C_str)strts_vect[2].name, crss_names_vect[0], ARCH_ND1, LIST_HEAD);                    {\cf20 // Connect "Street3" to "Cross1", add at list head position instead of list tail pos}\par
00251   connect_node_arch((C_str)strts_vect[2].name, crss_names_vect[3], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street3" to "Cross4"}\par
00252   connect_node_arch((C_str)strts_vect[3].name, crss_names_vect[0], ARCH_ND1, LIST_POS, 2);                  {\cf20 // Connect "Street4" to "Cross1", opt param --> add arch at specific pos in archs list, non-zero index}\par
00253   connect_node_arch((C_str)strts_vect[3].name, crss_names_vect[4], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street4" to "Cross5"}\par
00254   connect_node_arch((C_str)strts_vect[4].name, crss_names_vect[4], ARCH_ND1, LIST_TAIL);                    {\cf20 // Connect "Street5" to "Cross5"}\par
00255   connect_node_arch((C_str)strts_vect[4].name, crss_names_vect[5], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street5" to "Cross6"}\par
00256   connect_node_arch((C_str)strts_vect[5].name, crss_names_vect[5], ARCH_ND1, LIST_TAIL);                    {\cf20 // Connect "Street6" to "Cross6"}\par
00257   connect_node_arch((C_str)strts_vect[5].name, crss_names_vect[6], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street6" to "Cross7"}\par
00258   connect_node_arch((C_str)strts_vect[6].name, crss_names_vect[5], ARCH_ND1, LIST_TAIL);                    {\cf20 // Connect "Street7" to "Cross6"}\par
00259   connect_node_arch((C_str)strts_vect[6].name, crss_names_vect[7], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street7" to "Cross8"}\par
00260   connect_node_arch((C_str)strts_vect[7].name, crss_names_vect[7], ARCH_ND1, LIST_TAIL);                    {\cf20 // Connect "Street8" to "Cross8"}\par
00261   connect_node_arch((C_str)strts_vect[7].name, crss_names_vect[8], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street8" to "Cross9"}\par
00262   connect_node_arch((C_str)strts_vect[8].name, crss_names_vect[0], ARCH_ND1, LIST_TAIL);                    {\cf20 // Connect "Street9" to "Cross1"}\par
00263   connect_node_arch((C_str)strts_vect[8].name, crss_names_vect[6], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street9" to "Cross7"}\par
00264   connect_node_arch((C_str)strts_vect[9].name, crss_names_vect[0], ARCH_ND1, LIST_TAIL);                    {\cf20 // Connect "Street10" to "Cross1"}\par
00265   connect_node_arch((C_str)strts_vect[9].name, crss_names_vect[5], ARCH_ND2, LIST_TAIL);                    {\cf20 // Connect "Street10" to "Cross6"}\par
00266   connect_node_arch((C_str)strts_vect[10].name, crss_names_vect[3], ARCH_ND1, LIST_TAIL);                   {\cf20 // Connect "Street11" to "Cross4"}\par
00267   connect_node_arch((C_str)strts_vect[10].name, crss_names_vect[4], ARCH_ND2, LIST_TAIL);                   {\cf20 // Connect "Street11" to "Cross5"}\par
00268   connect_node_arch((C_str)strts_vect[11].name, crss_names_vect[4], ARCH_ND1, LIST_TAIL);                   {\cf20 // Connect "Street12" to "Cross5"}\par
00269   connect_node_arch((C_str)strts_vect[11].name, crss_names_vect[7], ARCH_ND2, LIST_TAIL);                   {\cf20 // Connect "Street12" to "Cross8"}\par
00270   connect_node_arch((C_str)strts_vect[12].name, crss_names_vect[4], ARCH_ND1, LIST_TAIL);                   {\cf20 // Connect "Street13" to "Cross5"}\par
00271   connect_node_arch((C_str)strts_vect[12].name, crss_names_vect[8], ARCH_ND2, LIST_TAIL);                   {\cf20 // Connect "Street13" to "Cross9"}\par
00272 \}\par
}
}
{\xe \v create_nodes\:graph_test.c}
{\xe \v graph_test.c\:create_nodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void create_nodes (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Static routine to create test-graph nodes, working on graph-library public variables.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 232 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00232                           \{                                                                                 {\cf20 // Routine to create nodes}\par
00233   {\cf20 /* Body */}\par
00234   {\cf19 for} ({\cf18 int} j = 0; j < (int)({\cf17 sizeof}(crss_names_vect)/{\cf17 sizeof}(C_str)); ++j)                                    {\cf20 // Crosses allocation FOR cycle}\par
00235     add_new_node(crss_names_vect[j]);                                                                       {\cf20 // Create new cross (node allocated inside heap)}\par
00236 \}\par
}
}
{\xe \v define_dest_node_name\:graph_test.c}
{\xe \v graph_test.c\:define_dest_node_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void define_dest_node_name ({\b Str} *  {\i dest_nd_nm}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Static routine to define destination node name from user terminal-input, to be abe to reconstruct min-cost pah from source node defined when calling Dijkstra's algorithm. After that, function checks if specified node is contained in nodes collection.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i dest_nd_nm} \cell }{Destination node name terminal-input, to reconstruct min-cost path.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 525 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00525                                                   \{                                                         {\cf20 // Routine to define presonalized destination-node name}\par
00526   {\cf20 /* Body */}\par
00527   {\cf19 for} ({\cf18 int} i = 0; i < nds_collect_size; ++i)\{                                                               {\cf20 // Nodes collection vect scrollin' FOR cycle}\par
00528     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Node name"}, nodes_collect_vect[i].name);                                 {\cf20 // Print node name fbk}\par
00529   \}\par
00530   {\cf19 do} \{                                                                                                      {\cf20 // Cycle to define personalized destination-node name}\par
00531     *dest_nd_nm = read_term_in_min_chrs(1, {\cf22 "Choose a destination node (by name)"}, {\cf22 "Destination node name"}); {\cf20 // Read user input str}\par
00532   \} {\cf19 while}(idx_by_name(ND, *dest_nd_nm) < 0);                                                                {\cf20 // Check whether node-name specified by the user exists in nodes collection vect, otherwise repeat question}\par
00533 \}\par
}
}
{\xe \v define_src_node_name\:graph_test.c}
{\xe \v graph_test.c\:define_src_node_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void define_src_node_name ({\b Str} *  {\i src_nd_nm}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Static routine to define source node name for Dijkstra's algorithm function, from user terminal-input. After that, function checks if specified node is contained in nodes collection.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i src_nd_nm} \cell }{Source node name terminal-input, for Dijkstra's algorithm.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 506 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00506                                                 \{                                                           {\cf20 // Routine to define presonalized source-node name}\par
00507   {\cf20 /* Body */}\par
00508   {\cf19 for} ({\cf18 int} i = 0; i < nds_collect_size; ++i)\{                                                               {\cf20 // Nodes collection vect scrollin' FOR cycle}\par
00509     fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Node name"}, nodes_collect_vect[i].name);                                 {\cf20 // Print node name fbk}\par
00510   \}\par
00511   {\cf19 do} \{                                                                                                      {\cf20 // Cycle to define personalized source-node name}\par
00512     *src_nd_nm = read_term_in_min_chrs(1, {\cf22 "Choose a source node (by name)"}, {\cf22 "Source node name"});            {\cf20 // Read user input str}\par
00513   \} {\cf19 while}(idx_by_name(ND, *src_nd_nm) < 0);                                                                 {\cf20 // Check whether node-name specified by the user exists in nodes collection vect, otherwise repeat question}\par
00514 \}\par
}
}
{\xe \v display_test_graph\:graph_test.c}
{\xe \v graph_test.c\:display_test_graph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void display_test_graph ({\b C_str}  {\i cmd}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Static routine to send gnuplot system command string, with the aim of printing graphical data contained inside .dat files. In case command is the one to print graph and highlight the shortest-path, call a specific function ({\b build_shortest_path_graphics_data()}) to manipulate gnuplot data and graphically recreate the min cost path. Gnuplot system commands listed below:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Plot graph} : calls gnuplot and load plotting command in .cmd file ({\b graph_plot.cmd}, defined with a macro: {\b GPLOT_TEST_GRAPH_LAYOUT_CMD}), in order to plot: arches, arch-costs and nodes in graph. \par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Plot graph with shortest-path} : calls gnuplot and load plotting command in .cmd file ({\b shortest_plot.cmd}, defined with a macro: {\b GPLOT_SHORTEST_PATH_CMD}), in order to plot: arches, arch-costs and nodes in graph highlighting the shortest path. \par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i cmd} \cell }{Display test-graph gnuplot system command string.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 456 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00456                                          \{                                                                  {\cf20 // Routine to display test-graph through gnuplot}\par
00457   {\cf20 /* Body */}\par
00458   fbk_gn_pu({\cf22 "Close gnuplot to continue graph-library test..."}); fbk_nl(1);                                  {\cf20 // Print close gnuplot to continue fbk}\par
00459   {\cf19 if} (strcmp(cmd, GPLOT_SHORTEST_PATH_CMD) == 0)                                                            {\cf20 // If display command request min path}\par
00460     build_shortest_path_graphics_data();                                                                    {\cf20 // Routine call to build the shortest-path graphics data for gnuplot}\par
00461   fflush(stdout);                                                                                           {\cf20 // Force fbk print b4 openin' gnuplot}\par
00462   {\cf18 int} ret_val = system(cmd);                                                                                {\cf20 // Display test-graph layout with gnuplot}\par
00463   {\cf19 if} (ret_val == 0)\{                                                                                        {\cf20 // Chack command return val, if ok}\par
00464     fbk_nl(1);  fbk_gn_cy({\cf22 "Test-graph layout correctly displayed with gnuplot!\\n"});                         {\cf20 // Test-graph layout correctly displayed with gnuplot fbk}\par
00465   \} {\cf19 else}                                                                                                    {\cf20 // Else if command return val ain't ok}\par
00466     fbk_err({\cf22 "Ops! Encountered error during gnuplot command exec, make sure to have gnuplot installed"});     {\cf20 // Error fbk}\par
00467 \}\par
}
}
{\xe \v main\:graph_test.c}
{\xe \v graph_test.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Function description:} \par
Main software routine to dynamically allocate a test-graph, asking for graph-library test mode, (eventually) displaying results and graphichs through gnuplot and finally clearing allocated memory inside heap.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 543 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00543           \{                                                                                                 {\cf20 // Main SW cycle}\par
00544   {\cf20 /* Main vars */}\par
00545   Test_choice choice = 0;                                                                                   {\cf20 // Test choice var}\par
00546 \par
00547   {\cf20 /* Code */}\par
00548   signal(SIGINT, terminate_keyboard);                                                                       {\cf20 // Manage program exit from keyboard ctrl+c shortcut}\par
00549   logo(6, {\cf22 "GRAPHS MANAGEMENT LIBRARY TEST SOFTWARE"}, LBU, {\cf23 '#'}, OG);                                         {\cf20 // Print responsive-logo function call (start_spaces, text, txt_color, background_char, bkgchr_color)}\par
00550   press_enter({\cf22 "Hi"});                                                                                        {\cf20 // Press enter to start SW fbk}\par
00551 \par
00553   {\cf20 //                                          LIBRARY TEST SOFTWATRE                                        // --> TEST BEGIN}\par
00555 {\cf20 }  {\cf20 // (1.1) Create some archs                                                                                // --------------------------------------------------------- (1.1)}\par
00556   fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                                   {\cf20 // Print separator fbk}\par
00557   fbk_nl(1);  fbk_gn_pu({\cf22 "(1.1) Creatin' some archs..."});                                                    {\cf20 // Print creatin' archs fbk}\par
00558   fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                        {\cf20 // Print separator fbk}\par
00559   create_archs();                                                                                           {\cf20 // Routine call to create archs}\par
00560   {\cf20 // (1.2) Create some nodes                                                                                // --------------------------------------------------------- (1.2)}\par
00561   fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                                   {\cf20 // Print separator fbk}\par
00562   fbk_nl(1);  fbk_gn_pu({\cf22 "(1.2) Creatin' some nodes..."});                                                    {\cf20 // Print creatin' nodes fbk}\par
00563   fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                        {\cf20 // Print separator fbk}\par
00564   create_nodes();                                                                                           {\cf20 // Routine call to create nodes}\par
00565   {\cf20 // (2.1) Connect archs & nodes (excluding node "Cross10")                                                 // --------------------------------------------------------- (2.1)}\par
00566   fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                                   {\cf20 // Print separator fbk}\par
00567   fbk_nl(1);  fbk_gn_pu({\cf22 "(2.1) Connectin' archs & nodes..."});                                               {\cf20 // Print connectin' archs and nodes fbk}\par
00568   fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                        {\cf20 // Print separator fbk}\par
00569   create_connections();                                                                                     {\cf20 // Routine call to create connections btwn archs & nodes}\par
00570   {\cf20 // (2.2) Test mode choice                                                                                 // --------------------------------------------------------- (2.2)}\par
00571   fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                                   {\cf20 // Print separator fbk}\par
00572   fbk_nl(1);  fbk_gn_pu({\cf22 "(2.2) Testin' mode choice..."});                                                    {\cf20 // Print testin' mode choice fbk}\par
00573   fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                        {\cf20 // Print separator fbk}\par
00574   test_option_choice(&choice);                                                                              {\cf20 // Routine call to choose testing option}\par
00575   {\cf19 if} (choice == PREPARED || choice == PERSONALIZED)\{                                                        {\cf20 // If exit mode ain't been selected}\par
00576     {\cf20 // (2.3) Display test-graph layout with gnuplot                                                         // --------------------------------------------------------- (2.3)}\par
00577     fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                                 {\cf20 // Print separator fbk}\par
00578     fbk_nl(1);  fbk_gn_pu({\cf22 "(2.3) Displayin' test-graph layout with gnuplot..."});                            {\cf20 // Print displayin' test-graph layout with gnuplot fbk}\par
00579     fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                      {\cf20 // Print separator fbk}\par
00580     display_test_graph(GPLOT_TEST_GRAPH_LAYOUT_CMD);                                                        {\cf20 // Routine call to display test-graph through gnuplot}\par
00581   \}                                                                                                         {\cf20 //}\par
00582   {\cf20 // (3.1) Apply Dijkstra's algorithm and find min parh                                                     //}\par
00583   {\cf19 switch} (choice)\{                                                                                          {\cf20 // Testin' option switch-case}\par
00584     {\cf19 case} PREPARED:                                                                                          {\cf20 // Option [1] -> Prepared test (requires gnuplot)}\par
00585       {\cf20 // (3.1.1) Apply Dijkstra's algorithm (from Cross4)                                                   // --------------------------------------------------------- (3.1.1)}\par
00586       fbk_nl(2);  fbk_separator(SEP_CHR, OG); fbk_nl(1);                                                    {\cf20 // Print separator fbk}\par
00587       fbk_gn_pu({\cf22 "(3.1.1) Applyin' Dijkstra's algorithm to find min paths from \\"Cross4\\" source node..."});  {\cf20 // Print applyin' Dijkstra's algorithm to find min paths fbk}\par
00588       fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                    {\cf20 // Print separator fbk}\par
00589       apply_dijkstra(SOURCE_NODE_NAME);                                                                     {\cf20 // Routine call to apply Dijkstra's algorithm}\par
00590       {\cf20 // (3.2.1) Reconstruct test min path (from Cross4 to Cross9)                                          // --------------------------------------------------------- (3.2.1)}\par
00591       fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                               {\cf20 // Print separator fbk}\par
00592       fbk_nl(1);  fbk_gn_pu({\cf22 "(3.2.1) Reconstructin' test min path (Cross4-Cross9) with delays..."});         {\cf20 // Print reconstructin' test min path fbk}\par
00593       fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                    {\cf20 // Print separator fbk}\par
00594       reconstruct_min_path(DESTINATION_NODE_NAME);                                                          {\cf20 // Routine call to reconstruct min path}\par
00595       {\cf20 // (3.3.1) Display test-graph layout and shortest path with gnuplot (from Cr4 to Cr9)                 // --------------------------------------------------------- (3.3.1)}\par
00596       {\cf19 if} (min_pth_conn_vect_size > 1)\{                                                                      {\cf20 // If min path contains at least src and dest nodes}\par
00597         fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                             {\cf20 // Print separator fbk}\par
00598         fbk_nl(1);  fbk_gn_pu({\cf22 "(3.3.1) Displayin' test-graph and shortest path with gnuplot (Cr4-Cr9)..."}); {\cf20 // Print displayin' test-graph layout and shortest path with gnuplot fbk}\par
00599         fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                  {\cf20 // Print separator fbk}\par
00600         display_test_graph(GPLOT_SHORTEST_PATH_CMD);                                                        {\cf20 // Routine call to display test-graph through gnuplot}\par
00601       \}                                                                                                     {\cf20 //}\par
00602       {\cf20 // (3.4.1) Reconstruct some special-cases paths (Cr4-Cr4 and Cr4-Cr10)                                // --------------------------------------------------------- (3.4.1)}\par
00603       fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                               {\cf20 // Print separator fbk}\par
00604       fbk_nl(1);  fbk_gn_pu({\cf22 "(3.4.1) Reconstructin' some special-cases paths (Cr4-Cr4 and Cr4-Cr10)..."});   {\cf20 // Print reconstructin' some special-cases paths fbk}\par
00605       fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                    {\cf20 // Print separator fbk}\par
00606       reconstruct_min_path(DEST_NODE_NAME_SPECIAL_CASE1);                                                   {\cf20 // Routine call to reconstruct min path}\par
00607       reconstruct_min_path(DEST_NODE_NAME_SPECIAL_CASE2);                                                   {\cf20 // Routine call to reconstruct min path}\par
00608       {\cf19 break};                                                                                                {\cf20 //}\par
00610 {\cf20 }    {\cf19 case} PERSONALIZED:                                                                                      {\cf20 // Option [2] -> Personalized test (requires gnuplot)}\par
00611       {\cf20 // (3.1.2) Apply Dijkstra's algorithm                                                                 // --------------------------------------------------------- (3.1.2)}\par
00612       fbk_nl(2);  fbk_separator(SEP_CHR, OG); fbk_nl(1);                                                    {\cf20 // Print separator fbk}\par
00613       fbk_gn_pu({\cf22 "(3.1.2) Applyin' Dijkstra's algorithm to find min paths from specified source node..."});   {\cf20 // Print applyin' Dijkstra's algorithm to find min paths fbk}\par
00614       fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                    {\cf20 // Print separator fbk}\par
00615       {\cf18 char}* src_nd_nm = NULL;                                                                               {\cf20 // Personalized source-node name str init}\par
00616       define_src_node_name(&src_nd_nm);                                                                     {\cf20 // Routine call to define presonalized source-node name}\par
00617       apply_dijkstra(src_nd_nm);                                                                            {\cf20 // Routine call to apply Dijkstra's algorithm}\par
00618       {\cf20 // (3.2.2) Reconstruct test min path                                                                  // --------------------------------------------------------- (3.2.2)}\par
00619       fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                               {\cf20 // Print separator fbk}\par
00620       fbk_nl(1);  fbk_gn_pu({\cf22 "(3.2.2) Reconstructin' requested min path with delays..."});                    {\cf20 // Print reconstructin' requested min path fbk}\par
00621       fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                    {\cf20 // Print separator fbk}\par
00622       {\cf18 char}* dest_nd_nm = NULL;                                                                              {\cf20 // Personalized destination-node name str init}\par
00623       define_dest_node_name(&dest_nd_nm);                                                                   {\cf20 // Routine call to define presonalized destination-node name}\par
00624       reconstruct_min_path(dest_nd_nm);                                                                     {\cf20 // Routine call to reconstruct min path}\par
00625       {\cf20 // (3.3.2) Display test-graph layout and shortest path with gnuplot                                   // --------------------------------------------------------- (3.3.2)}\par
00626       {\cf19 if} (min_pth_conn_vect_size > 1)\{                                                                      {\cf20 // If min path contains at least src and dest nodes}\par
00627         fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                             {\cf20 // Print separator fbk}\par
00628         fbk_nl(1);  fbk_gn_pu({\cf22 "(3.3.2) Displayin' test-graph and shortest path with gnuplot..."});           {\cf20 // Print displayin' test-graph layout and shortest path with gnuplot fbk}\par
00629         fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                  {\cf20 // Print separator fbk}\par
00630         display_test_graph(GPLOT_SHORTEST_PATH_CMD);                                                        {\cf20 // Routine call to display test-graph through gnuplot}\par
00631       \}                                                                                                     {\cf20 //}\par
00632       {\cf19 break};                                                                                                {\cf20 //}\par
00634 {\cf20 }    {\cf19 default}:                                                                                                {\cf20 // Unknown option (avoid compile errors)}\par
00635       {\cf19 break};                                                                                                {\cf20 //}\par
00636   \}                                                                                                         {\cf20 //}\par
00637   {\cf20 // (4.1) Deallocate the whole graph structure                                                             // --------------------------------------------------------- (4.1)}\par
00638   fbk_nl(2);  fbk_separator(SEP_CHR, OG);                                                                   {\cf20 // Print separator fbk}\par
00639   fbk_nl(1);  fbk_gn_pu({\cf22 "(4.1) Deallocatin' the whole graph structure..."});                                 {\cf20 // Print clearin' the whole graph structre fbk}\par
00640   fbk_nl(1);  fbk_separator(SEP_CHR, OG); fbk_nl(2);                                                        {\cf20 // Print separator fbk}\par
00641   free_graph();                                                                                             {\cf20 // Clear graph structure from heap and reset some flags to be able to use again lib functions}\par
00643 {\cf20 }  {\cf20 //                                          LIBRARY TEST SOFTWATRE                                        // --> TEST END}\par
00645 {\cf20 }\par
00646   close_fbk();                                                                                              {\cf20 // Close SW with fbk}\par
00647   {\cf19 return} EXIT_SUCCESS;                                                                                      {\cf20 // Check errors --> if=0 (NO ERRORS) / if=1 (ERRORS)}\par
00648 \}\par
}
}
{\xe \v reconstruct_min_path\:graph_test.c}
{\xe \v graph_test.c\:reconstruct_min_path}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void reconstruct_min_path ({\b C_str}  {\i dest_nd_name}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Static routine to reconstruct min-cost path with verbose-mode enabled, towards specified destination node (from source node defined when calling Dijkstra's algoritm; destination node selected by-name, checking if node is contained in nodes collection). Find out if a specific possible destination node is unreachble, or if it corresponds to the source node.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i dest_nd_name} \cell }{Destination node name towards which min-cost path must be reconstructed (backwards).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 492 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00492                                                     \{                                                       {\cf20 // Routine to reconstruct min path}\par
00493   {\cf20 /* Body */}\par
00494   buid_shortest_path(dest_nd_name, VERBOSE);                                                                {\cf20 // Reconstruct min path to defined destination node startin' from pre-defined source node, (min path connections vect allocated/reallocated inside heap) - Y/N for verbose mode}\par
00495 \}\par
}
}
{\xe \v terminate_keyboard\:graph_test.c}
{\xe \v graph_test.c\:terminate_keyboard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void terminate_keyboard (int  {\i signal}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Static routine to manage close keyboard interrupt signal calling {\b close_keyboard_interrupt()} function.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i signal} \cell }{Keyboard interrupt signal.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 209 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00209                                           \{                                                                 {\cf20 // Manage program exit from keyboard ctrl+c shortcut}\par
00210   {\cf20 /* Body */}\par
00211   close_keyboard_interrupt(signal);                                                                         {\cf20 // Close SW with fbk due to keyboard interrupt detected (ctrl+c)}\par
00212 \}\par
}
}
{\xe \v test_option_choice\:graph_test.c}
{\xe \v graph_test.c\:test_option_choice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void test_option_choice ({\b Test_choice} *const  {\i choice}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Static function description:} \par
Static routine to give give to the user the possibility to choose a testing option, using pre-defined graph dynamically generated with graph-library functions:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Prepared test} : find shortest path from 'Cross4' to 'Cross9' nodes (defined with macros {\b SOURCE_NODE_NAME} and {\b DESTINATION_NODE_NAME}), applying Dijkstra's algorithm. In addition, show two special cases: shortest path from 'Cross4' to 'Cross4' (source = destination) and from 'Cross4' to 'Cross10' (unreachble node). In conclusion clear dynamic memory allocated inside heap. This option requires gnuplot to display graphical data.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Personalized test} : find shortest path from user-defined source and destination nodes, applying Dijkstra's algorithm. In conclusion clear dynamic memory allocated inside heap. This option requires gnuplot to display graphical data.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Close test software} : clear dynamic memory allocated inside heap and close test software.\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i choice} \cell }{Option chosen by the user (enum).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
None. \par
}}}{
Definition at line 286 of file graph_test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00286                                                          \{                                                  {\cf20 // Routine to choose testing option}\par
00287   {\cf20 /* Body */}\par
00288   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "[1]"}, {\cf22 "Prepared test (requires gnuplot)"});                                 {\cf20 // Print opt 1 fbk}\par
00289   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "[2]"}, {\cf22 "Personalized test (requires gnuplot)"});                             {\cf20 // Print opt 2 fbk}\par
00290   fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "[3]"}, {\cf22 "Exit"}); fbk_nl(1);                                                  {\cf20 // Print opt 3 fbk}\par
00291   *choice = (Byte)read_term_in_int_inrange(1, 3, {\cf22 "Choose a testing option"}, {\cf22 "Error! Option"});               {\cf20 // Print opt choice fbk}\par
00292   {\cf19 switch} (*choice)\{                                                                                         {\cf20 // Testin' option switch-case}\par
00293     {\cf19 case} PREPARED:                                                                                          {\cf20 // Option [1] -> Prepared test (requires gnuplot)}\par
00294       fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Choosen option"}, {\cf22 "[1] -> Prepared test (requires gnuplot)"});           {\cf20 // Print choosen opt fbk}\par
00295       {\cf19 break};\par
00297     {\cf19 case} PERSONALIZED:                                                                                      {\cf20 // Option [2] -> Personalized test (requires gnuplot)}\par
00298       fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Choosen option"}, {\cf22 "[2] -> Personalized test (requires gnuplot)"});       {\cf20 // Print choosen opt fbk}\par
00299       {\cf19 break};\par
00301     {\cf19 case} EXIT:                                                                                              {\cf20 // Option [3] -> Exit}\par
00302       fbk_nl(1);  fbk_gn_lbu_ye_str({\cf22 "Choosen option"}, {\cf22 "[3] -> Exit"}); fbk_nl(1);                            {\cf20 // Print choosen opt fbk}\par
00303       Confirm answ = read_term_in_confirm({\cf22 "Are you sure you want to close test software"});                  {\cf20 // Ask confirm}\par
00304       {\cf19 switch} (answ)\{                                                                                        {\cf20 // Confirm answ switch-case}\par
00305         {\cf19 case} YES:                                                                                           {\cf20 // YES answer}\par
00306           {\cf19 break};\par
00308         {\cf19 case} NO:                                                                                            {\cf20 // NO answer}\par
00309           test_option_choice(choice);                                                                       {\cf20 // Go back}\par
00310           {\cf19 break};\par
00312         {\cf19 case} CANCEL:                                                                                        {\cf20 // CANCEL answer}\par
00313           test_option_choice(choice);                                                                       {\cf20 // Go back}\par
00314           {\cf19 break};\par
00316         {\cf19 default}:                                                                                            {\cf20 // Unknown answer}\par
00317           fbk_err({\cf22 "Error, bad confirmation answer"});                                                        {\cf20 // Print error fbk}\par
00318           perror({\cf22 "Bad confirmation answer, 'read_term_in_confirm()' requires 'Confirm' data-type!"});        {\cf20 // Print perror fbk}\par
00319           close_err();                                                                                      {\cf20 // Close with error fbk}\par
00320       \}\par
00321       {\cf19 break};\par
00323     {\cf19 default}:                                                                                                {\cf20 // Unknown option}\par
00324       fbk_err({\cf22 "Error, bad testing option value"});                                                           {\cf20 // Print error fbk}\par
00325       perror({\cf22 "Testing option value out of range, check 'read_term_in_int_inrange()' parameter-values!"});    {\cf20 // Print perror fbk}\par
00326       close_err();                                                                                          {\cf20 // Close with error fbk}\par
00327   \}\par
00328 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v crss_names_vect\:graph_test.c}
{\xe \v graph_test.c\:crss_names_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b C_str} crss_names_vect[]}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{{\cf22 "Cross1"}, {\cf22 "Cross2"}, {\cf22 "Cross3"}, {\cf22 "Cross4"}, {\cf22 "Cross5"}, {\cf22 "Cross6"}, {\cf22 "Cross7"},\par
   {\cf22 "Cross8"}, {\cf22 "Cross9"}, {\cf22 "Cross10"}\}\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Global-variable description:}  Cross-names vector (to dynamically initalize nodes). }}\par
{
Definition at line 197 of file graph_test.c.}\par
}
{\xe \v strts_vect\:graph_test.c}
{\xe \v graph_test.c\:strts_vect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Street} strts_vect[]}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\{{\cf22 "Street1"},1.1\}, \{{\cf22 "Street2"},2.2\}, \{{\cf22 "Street3"},3.3\}, \{{\cf22 "Street4"},4.4\}, \par
   \{{\cf22 "Street5"},5.5\}, \{{\cf22 "Street6"},6.6\}, \{{\cf22 "Street7"},7.7\}, \{{\cf22 "Street8"},8.8\},\par
   \{{\cf22 "Street9"},6.3\}, \{{\cf22 "Street10"},0.2\}, \{{\cf22 "Street11"},9.3\}, \{{\cf22 "Street12"},7.1\},\par
   \{{\cf22 "Street13"},12.8\}\}\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Global-variable description:}  Street-structs vector (to dynamically initalize archs). }}\par
{
Definition at line 192 of file graph_test.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
main/graph_test.o File Reference\par \pard\plain 
{\tc\tcl2 \v main/graph_test.o}
{\xe \v main/graph_test.o}
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Graph-library test software main object file}  }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Graph-library test software main object file}  \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i Object file generated from {\b graph_test.c} during compiling operations.}  \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
makefile File Reference\par \pard\plain 
{\tc\tcl2 \v makefile}
{\xe \v makefile}
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Makefile to compile/run software, make/view doxygen documentation and view LaTeX abstract pdf}  }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Makefile to compile/run software, make/view doxygen documentation and view LaTeX abstract pdf}  \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\i More info in {\b 'Makefile'}  section inside doxygen {\b 'Related pages'} .}  \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}